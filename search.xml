<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指 Offer 题解 - 60~68</title>
    <url>/blog/post/75f4fee9.html</url>
    <content><![CDATA[<ul>
<li><a href="#60-n-个骰子的点数">60. n 个骰子的点数</a></li>
<li><a href="#61-扑克牌顺子">61. 扑克牌顺子</a></li>
<li><a href="#62-圆圈中最后剩下的数">62. 圆圈中最后剩下的数</a></li>
<li><a href="#63-股票的最大利润">63. 股票的最大利润</a></li>
<li><a href="#64-求-123n">64. 求 1+2+3+...+n</a></li>
<li><a href="#65-不用加减乘除做加法">65. 不用加减乘除做加法</a></li>
<li><a href="#66-构建乘积数组">66. 构建乘积数组</a></li>
<li><a href="#67-把字符串转换成整数">67. 把字符串转换成整数</a></li>
<li><a href="#68-树中两个节点的最低公共祖先">68. 树中两个节点的最低公共祖先</a><!-- GFM-TOC -->


</li>
</ul><h1 id="60-n-个骰子的点数"><a href="#60-n-个骰子的点数" class="headerlink" title="60. n 个骰子的点数"></a>60. n 个骰子的点数</h1><p><a href="https://www.lintcode.com/en/problem/dices-sum/" target="_blank" rel="noopener">Lintcode</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a><!-- GFM-TOC -->


<p>把 n 个骰子扔在地上，求点数和为 s 的概率。</p>
<div align="center"> <img src="../pics/195f8693-5ec4-4987-8560-f25e365879dd.png" width="300px"> </div><br>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。</p>
<p>空间复杂度：O(N<sup>2</sup>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointNum = face * n;</span><br><span class="line">    <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[n + <span class="number">1</span>][pointNum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= face; i++)</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= pointNum; j++)     <span class="comment">/* 使用 i 个骰子最小点数为 i */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face &amp;&amp; k &lt;= j; k++)</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> totalNum = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">    List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= pointNum; i++)</span><br><span class="line">        ret.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dp[n][i] / totalNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-旋转数组"><a href="#动态规划-旋转数组" class="headerlink" title="动态规划 + 旋转数组"></a>动态规划 + 旋转数组</h3><p>空间复杂度：O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pointNum = face * n;</span><br><span class="line">    <span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>][pointNum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= face; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;                                     <span class="comment">/* 旋转标记 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++, flag = <span class="number">1</span> - flag) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= pointNum; j++)</span><br><span class="line">            dp[flag][j] = <span class="number">0</span>;                          <span class="comment">/* 旋转数组清零 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= pointNum; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face &amp;&amp; k &lt;= j; k++)</span><br><span class="line">                dp[flag][j] += dp[<span class="number">1</span> - flag][j - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> totalNum = Math.pow(<span class="number">6</span>, n);</span><br><span class="line">    List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt;= pointNum; i++)</span><br><span class="line">        ret.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dp[<span class="number">1</span> - flag][i] / totalNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="61-扑克牌顺子"><a href="#61-扑克牌顺子" class="headerlink" title="61. 扑克牌顺子"></a>61. 扑克牌顺子</h1><p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&tqId=11198&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p>
<div align="center"> <img src="../pics/eaa506b6-0747-4bee-81f8-3cda795d8154.png" width="350px"> </div><br>


<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt; <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计癞子数量</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            cnt++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用癞子去补全不连续的顺子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i + <span class="number">1</span>] == nums[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        cnt -= nums[i + <span class="number">1</span>] - nums[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="62-圆圈中最后剩下的数"><a href="#62-圆圈中最后剩下的数" class="headerlink" title="62. 圆圈中最后剩下的数"></a>62. 圆圈中最后剩下的数</h1><p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&tqId=11199&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)     <span class="comment">/* 特殊输入的处理 */</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)     <span class="comment">/* 递归返回条件 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a>63. 股票的最大利润</h1><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>可以有一次买入和一次卖出，买入必须在前。求最大收益。</p>
<div align="center"> <img src="../pics/42661013-750f-420b-b3c1-437e9a11fb65.png" width="220px"> </div><br>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> soFarMin = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        soFarMin = Math.min(soFarMin, prices[i]);</span><br><span class="line">        maxProfit = Math.max(maxProfit, prices[i] - soFarMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="64-求-1-2-3-n"><a href="#64-求-1-2-3-n" class="headerlink" title="64. 求 1+2+3+...+n"></a>64. 求 1+2+3+...+n</h1><p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&tqId=11200&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。</p>
<p>条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。</p>
<p>本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">boolean</span> b = (n &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="number">1</span>)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65. 不用加减乘除做加法"></a>65. 不用加减乘除做加法</h1><p><a href="https://www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215?tpId=13&tqId=11201&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : Add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h1><p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&tqId=11204&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。要求不能使用除法。</p>
<div align="center"> <img src="../pics/4240a69f-4d51-4d16-b797-2dfe110f30bd.png" width="250px"> </div><br>


<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, product = <span class="number">1</span>; i &lt; n; product *= A[i], i++)       <span class="comment">/* 从左往右累乘 */</span></span><br><span class="line">        B[i] = product;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>, product = <span class="number">1</span>; i &gt;= <span class="number">0</span>; product *= A[i], i--)  <span class="comment">/* 从右往左累乘 */</span></span><br><span class="line">        B[i] *= product;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67. 把字符串转换成整数"></a>67. 把字符串转换成整数</h1><p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Iuput:</span><br><span class="line">+2147483647</span><br><span class="line">1a33</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2147483647</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>))  <span class="comment">/* 符号判定 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)                <span class="comment">/* 非法输入 */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ret = ret * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNegative ? -ret : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="68-树中两个节点的最低公共祖先"><a href="#68-树中两个节点的最低公共祖先" class="headerlink" title="68. 树中两个节点的最低公共祖先"></a>68. 树中两个节点的最低公共祖先</h1><h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p>二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val。</p>
<div align="center"> <img src="../pics/047faac4-a368-4565-8331-2b66253080d3.jpg" width="220"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="普通二叉树"><a href="#普通二叉树" class="headerlink" title="普通二叉树"></a>普通二叉树</h3><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode : 236. Lowest Common Ancestor of a Binary Tree</a></p>
<p>在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p>
<div align="center"> <img src="../pics/d27c99f0-7881-4f2d-9675-c75cbdee3acd.jpg" width="250"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 50~59</title>
    <url>/blog/post/6e7ee76c.html</url>
    <content><![CDATA[<ul>
<li><a href="#50-第一个只出现一次的字符位置">50. 第一个只出现一次的字符位置</a></li>
<li><a href="#51-数组中的逆序对">51. 数组中的逆序对</a></li>
<li><a href="#52-两个链表的第一个公共结点">52. 两个链表的第一个公共结点</a></li>
<li><a href="#53-数字在排序数组中出现的次数">53. 数字在排序数组中出现的次数</a></li>
<li><a href="#54-二叉查找树的第-k-个结点">54. 二叉查找树的第 K 个结点</a></li>
<li><a href="#551-二叉树的深度">55.1 二叉树的深度</a></li>
<li><a href="#552-平衡二叉树">55.2 平衡二叉树</a></li>
<li><a href="#56-数组中只出现一次的数字">56. 数组中只出现一次的数字</a></li>
<li><a href="#571-和为-s-的两个数字">57.1 和为 S 的两个数字</a></li>
<li><a href="#572-和为-s-的连续正数序列">57.2 和为 S 的连续正数序列</a></li>
<li><a href="#581-翻转单词顺序列">58.1 翻转单词顺序列</a></li>
<li><a href="#582-左旋转字符串">58.2 左旋转字符串</a></li>
<li><a href="#59-滑动窗口的最大值">59. 滑动窗口的最大值</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="50-第一个只出现一次的字符位置"><a href="#50-第一个只出现一次的字符位置" class="headerlink" title="50. 第一个只出现一次的字符位置"></a>50. 第一个只出现一次的字符位置</h1><p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: abacc</span><br><span class="line">Output: b</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        cnts[str.charAt(i)]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        <span class="keyword">if</span> (cnts[str.charAt(i)] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar2</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    BitSet bs1 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">    BitSet bs2 = <span class="keyword">new</span> BitSet(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs1.set(c);     <span class="comment">// 0 0 -&gt; 0 1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c))</span><br><span class="line">            bs2.set(c);     <span class="comment">// 0 1 -&gt; 1 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (bs1.get(c) &amp;&amp; !bs2.get(c))  <span class="comment">// 0 1</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h1><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&tqId=11188&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] tmp;  <span class="comment">// 在这里声明辅助数组，而不是在 merge() 递归函数中声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    tmp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (cnt % <span class="number">1000000007</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h - l &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">    mergeSort(nums, l, m);</span><br><span class="line">    mergeSort(nums, m + <span class="number">1</span>, h);</span><br><span class="line">    merge(nums, l, m, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= m || j &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; m)</span><br><span class="line">            tmp[k] = nums[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; h)</span><br><span class="line">            tmp[k] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt;= nums[j])</span><br><span class="line">            tmp[k] = nums[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k] = nums[j++];</span><br><span class="line">            <span class="keyword">this</span>.cnt += m - i + <span class="number">1</span>;  <span class="comment">// nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = l; k &lt;= h; k++)</span><br><span class="line">        nums[k] = tmp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52. 两个链表的第一个公共结点"></a>52. 两个链表的第一个公共结点</h1><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&tqId=11189&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/5f1cb999-cb9a-4f6c-a0af-d90377295ab8.png" width="500"> </div><br>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = pHead1, l2 = pHead2;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? pHead2 : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? pHead1 : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="53-数字在排序数组中出现的次数"><a href="#53-数字在排序数组中出现的次数" class="headerlink" title="53. 数字在排序数组中出现的次数"></a>53. 数字在排序数组中出现的次数</h1><p><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&tqId=11190&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums = 1, 2, 3, 3, 3, 3, 4, 6</span><br><span class="line">K = 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = binarySearch(nums, K);</span><br><span class="line">    <span class="keyword">int</span> last = binarySearch(nums, K + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (first == nums.length || nums[first] != K) ? <span class="number">0</span> : last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= K)</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="54-二叉查找树的第-K-个结点"><a href="#54-二叉查找树的第-K-个结点" class="headerlink" title="54. 二叉查找树的第 K 个结点"></a>54. 二叉查找树的第 K 个结点</h1><p><a href="https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=13&tqId=11215&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>利用二叉查找树中序遍历有序的特点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode ret;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inOrder(pRoot, k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || cnt &gt;= k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left, k);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k)</span><br><span class="line">        ret = root;</span><br><span class="line">    inOrder(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h1><p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&tqId=11191&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div align="center"> <img src="../pics/ba355101-4a93-4c71-94fb-1da83639727b.jpg" width="350px"> </div><br>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root == <span class="keyword">null</span> ? <span class="number">0</span> : <span class="number">1</span> + Math.max(TreeDepth(root.left), TreeDepth(root.right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h1><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&tqId=11192&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>平衡二叉树左右子树高度差不超过 1。</p>
<div align="center"> <img src="../pics/af1d1166-63af-47b6-9aa3-2bf2bd37bd03.jpg" width="250px"> </div><br>

<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isBalanced = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    height(root);</span><br><span class="line">    <span class="keyword">return</span> isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || !isBalanced)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = height(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = height(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">        isBalanced = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="56-数组中只出现一次的数字"><a href="#56-数组中只出现一次的数字" class="headerlink" title="56. 数组中只出现一次的数字"></a>56. 数组中只出现一次的数字</h1><p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&tqId=11193&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        diff ^= num;</span><br><span class="line">    diff &amp;= -diff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>)</span><br><span class="line">            num1[<span class="number">0</span>] ^= num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num2[<span class="number">0</span>] ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="57-1-和为-S-的两个数字"><a href="#57-1-和为-S-的两个数字" class="headerlink" title="57.1 和为 S 的两个数字"></a>57.1 和为 S 的两个数字</h1><p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&tqId=11195&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = array[i] + array[j];</span><br><span class="line">        <span class="keyword">if</span> (cur == sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array[i], array[j]));</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; sum)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="57-2-和为-S-的连续正数序列"><a href="#57-2-和为-S-的连续正数序列" class="headerlink" title="57.2 和为 S 的连续正数序列"></a>57.2 和为 S 的连续正数序列</h1><p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&tqId=11194&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输出所有和为 S 的连续正数序列。</p>
<p>例如和为 100 的连续序列有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[9, 10, 11, 12, 13, 14, 15, 16]</span><br><span class="line">[18, 19, 20, 21, 22]。</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, end = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; sum) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curSum &gt; sum) &#123;</span><br><span class="line">            curSum -= start;</span><br><span class="line">            start++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curSum &lt; sum) &#123;</span><br><span class="line">            end++;</span><br><span class="line">            curSum += end;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">                list.add(i);</span><br><span class="line">            ret.add(list);</span><br><span class="line">            curSum -= start;</span><br><span class="line">            start++;</span><br><span class="line">            end++;</span><br><span class="line">            curSum += end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="58-1-翻转单词顺序列"><a href="#58-1-翻转单词顺序列" class="headerlink" title="58.1 翻转单词顺序列"></a>58.1 翻转单词顺序列</h1><p><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">"I am a student."</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"student. a am I"</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p>
<p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.length();</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == n || chars[j] == <span class="string">' '</span>) &#123;</span><br><span class="line">            reverse(chars, i, j - <span class="number">1</span>);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(c, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = c[i];</span><br><span class="line">    c[i] = c[j];</span><br><span class="line">    c[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h1><p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">S="abcXYZdef"</span><br><span class="line">K=3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"XYZdefabc"</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>先将 &quot;abc&quot; 和 &quot;XYZdef&quot; 分别翻转，得到 &quot;cbafedZYX&quot;，然后再把整个字符串翻转得到 &quot;XYZdefabc&quot;。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= str.length())</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    reverse(chars, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, n, chars.length - <span class="number">1</span>);</span><br><span class="line">    reverse(chars, <span class="number">0</span>, chars.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">        swap(chars, i++, j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> t = chars[i];</span><br><span class="line">    chars[i] = chars[j];</span><br><span class="line">    chars[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="59-滑动窗口的最大值"><a href="#59-滑动窗口的最大值" class="headerlink" title="59. 滑动窗口的最大值"></a>59. 滑动窗口的最大值</h1><p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&tqId=11217&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p>
<h2 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; num.length || size &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);  <span class="comment">/* 大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heap.add(num[i]);</span><br><span class="line">    ret.add(heap.peek());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + size; j &lt; num.length; i++, j++) &#123;            <span class="comment">/* 维护一个大小为 size 的大顶堆 */</span></span><br><span class="line">        heap.remove(num[i]);</span><br><span class="line">        heap.add(num[j]);</span><br><span class="line">        ret.add(heap.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 40~49</title>
    <url>/blog/post/4a05ff9d.html</url>
    <content><![CDATA[<ul>
<li><a href="#40-最小的-k-个数">40. 最小的 K 个数</a></li>
<li><a href="#411-数据流中的中位数">41.1 数据流中的中位数</a></li>
<li><a href="#412-字符流中第一个不重复的字符">41.2 字符流中第一个不重复的字符</a></li>
<li><a href="#42-连续子数组的最大和">42. 连续子数组的最大和</a></li>
<li><a href="#43-从-1-到-n-整数中-1-出现的次数">43. 从 1 到 n 整数中 1 出现的次数</a></li>
<li><a href="#44-数字序列中的某一位数字">44. 数字序列中的某一位数字</a></li>
<li><a href="#45-把数组排成最小的数">45. 把数组排成最小的数</a></li>
<li><a href="#46-把数字翻译成字符串">46. 把数字翻译成字符串</a></li>
<li><a href="#47-礼物的最大价值">47. 礼物的最大价值</a></li>
<li><a href="#48-最长不含重复字符的子字符串">48. 最长不含重复字符的子字符串</a></li>
<li><a href="#49-丑数">49. 丑数</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="40-最小的-K-个数"><a href="#40-最小的-K-个数" class="headerlink" title="40. 最小的 K 个数"></a>40. 最小的 K 个数</h1><p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><ul>
<li>复杂度：O(N) + O(1)</li>
<li>只有当允许修改数组元素时才可以使用</li>
</ul>
<p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    findKthSmallest(nums, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        ret.add(nums[i]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j == k)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; k)</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = nums[l];     <span class="comment">/* 切分元素 */</span></span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i != h &amp;&amp; nums[++i] &lt; p) ;</span><br><span class="line">        <span class="keyword">while</span> (j != l &amp;&amp; nums[--j] &gt; p) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大小为-K-的最小堆"><a href="#大小为-K-的最小堆" class="headerlink" title="大小为 K 的最小堆"></a>大小为 K 的最小堆</h3><ul>
<li>复杂度：O(NlogK) + O(K)</li>
<li>特别适合处理海量数据</li>
</ul>
<p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p>
<p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        maxHeap.add(num);</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.size() &gt; k)</span><br><span class="line">            maxHeap.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(maxHeap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="41-1-数据流中的中位数"><a href="#41-1-数据流中的中位数" class="headerlink" title="41.1 数据流中的中位数"></a>41.1 数据流中的中位数</h1><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 大顶堆，存储左半边元素 */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; left = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line"><span class="comment">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue&lt;Integer&gt; right = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"><span class="comment">/* 当前数据流读入的元素个数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 插入要保证两个堆存于平衡状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* N 为偶数的情况下插入到右半边。</span></span><br><span class="line"><span class="comment">         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，</span></span><br><span class="line"><span class="comment">         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span></span><br><span class="line">        left.add(val);</span><br><span class="line">        right.add(left.poll());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.add(val);</span><br><span class="line">        left.add(right.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    N++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (left.peek() + right.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) right.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="41-2-字符流中第一个不重复的字符"><a href="#41-2-字符流中第一个不重复的字符" class="headerlink" title="41.2 字符流中第一个不重复的字符"></a>41.2 字符流中第一个不重复的字符</h1><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &quot;go&quot; 时，第一个只出现一次的字符是 &quot;g&quot;。当从该字符流中读出前六个字符“google&quot; 时，第一个只出现一次的字符是 &quot;l&quot;。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">private</span> Queue&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    cnts[ch]++;</span><br><span class="line">    queue.add(ch);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; <span class="number">1</span>)</span><br><span class="line">        queue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.isEmpty() ? <span class="string">'#'</span> : queue.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h1><p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&tqId=11183&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> greatestSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">        sum = sum &lt;= <span class="number">0</span> ? val : sum + val;</span><br><span class="line">        greatestSum = Math.max(greatestSum, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> greatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="43-从-1-到-n-整数中-1-出现的次数"><a href="#43-从-1-到-n-整数中-1-出现的次数" class="headerlink" title="43. 从 1 到 n 整数中 1 出现的次数"></a>43. 从 1 到 n 整数中 1 出现的次数</h1><p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&tqId=11184&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = n / m, b = n % m;</span><br><span class="line">        cnt += (a + <span class="number">8</span>) / <span class="number">10</span> * m + (a % <span class="number">10</span> == <span class="number">1</span> ? b + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython" target="_blank" rel="noopener">Leetcode : 233. Number of Digit One</a></p>
</blockquote>
<h1 id="44-数字序列中的某一位数字"><a href="#44-数字序列中的某一位数字" class="headerlink" title="44. 数字序列中的某一位数字"></a>44. 数字序列中的某一位数字</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p>
<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDigitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> place = <span class="number">1</span>;  <span class="comment">// 1 表示个位，2 表示 十位...</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> amount = getAmountOfPlace(place);</span><br><span class="line">        <span class="keyword">int</span> totalAmount = amount * place;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; totalAmount)</span><br><span class="line">            <span class="keyword">return</span> getDigitAtIndex(index, place);</span><br><span class="line">        index -= totalAmount;</span><br><span class="line">        place++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * place 位数的数字组成的字符串长度</span></span><br><span class="line"><span class="comment"> * 10, 90, 900, ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getAmountOfPlace</span><span class="params">(<span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (place == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, place - <span class="number">1</span>) * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * place 位数的起始数字</span></span><br><span class="line"><span class="comment"> * 0, 10, 100, ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBeginNumberOfPlace</span><span class="params">(<span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (place == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, place - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 place 位数组成的字符串中，第 index 个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDigitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> place)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> beginNumber = getBeginNumberOfPlace(place);</span><br><span class="line">    <span class="keyword">int</span> shiftNumber = index / place;</span><br><span class="line">    String number = (beginNumber + shiftNumber) + <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> count = index % place;</span><br><span class="line">    <span class="keyword">return</span> number.charAt(count) - <span class="string">'0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45. 把数组排成最小的数"></a>45. 把数组排成最小的数</h1><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&tqId=11185&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> n = numbers.length;</span><br><span class="line">    String[] nums = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = numbers[i] + <span class="string">""</span>;</span><br><span class="line">    Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));</span><br><span class="line">    String ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : nums)</span><br><span class="line">        ret += str;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h1><p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Leetcode</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> one = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (one != <span class="number">0</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) == <span class="string">'0'</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> two = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (two &lt;= <span class="number">26</span>)</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a>47. 礼物的最大价值</h1><p><a href="https://www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1    10   3    8</span><br><span class="line">12   2    9    6</span><br><span class="line">5    7    4    11</span><br><span class="line">3    7    16   5</span><br></pre></td></tr></table></figure>

<p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span> || values.length == <span class="number">0</span> || values[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = values[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] value : values) &#123;</span><br><span class="line">        dp[<span class="number">0</span>] += value[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>]) + value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48. 最长不含重复字符的子字符串"></a>48. 最长不含重复字符的子字符串</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubStringWithoutDuplication</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] preIndexs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    Arrays.fill(preIndexs, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curI = <span class="number">0</span>; curI &lt; str.length(); curI++) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = str.charAt(curI) - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">int</span> preI = preIndexs[c];</span><br><span class="line">        <span class="keyword">if</span> (preI == -<span class="number">1</span> || curI - preI &gt; curLen) &#123;</span><br><span class="line">            curLen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, curLen);</span><br><span class="line">            curLen = curI - preI;</span><br><span class="line">        &#125;</span><br><span class="line">        preIndexs[c] = curI;</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen = Math.max(maxLen, curLen);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49. 丑数"></a>49. 丑数</h1><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&tqId=11186&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">6</span>)</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> next2 = dp[i2] * <span class="number">2</span>, next3 = dp[i3] * <span class="number">3</span>, next5 = dp[i5] * <span class="number">5</span>;</span><br><span class="line">        dp[i] = Math.min(next2, Math.min(next3, next5));</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next2)</span><br><span class="line">            i2++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next3)</span><br><span class="line">            i3++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == next5)</span><br><span class="line">            i5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 30~39</title>
    <url>/blog/post/b764b54a.html</url>
    <content><![CDATA[<ul>
<li><a href="#30-包含-min-函数的栈">30. 包含 min 函数的栈</a></li>
<li><a href="#31-栈的压入弹出序列">31. 栈的压入、弹出序列</a></li>
<li><a href="#321-从上往下打印二叉树">32.1 从上往下打印二叉树</a></li>
<li><a href="#322-把二叉树打印成多行">32.2 把二叉树打印成多行</a></li>
<li><a href="#323-按之字形顺序打印二叉树">32.3 按之字形顺序打印二叉树</a></li>
<li><a href="#33-二叉搜索树的后序遍历序列">33. 二叉搜索树的后序遍历序列</a></li>
<li><a href="#34-二叉树中和为某一值的路径">34. 二叉树中和为某一值的路径</a></li>
<li><a href="#35-复杂链表的复制">35. 复杂链表的复制</a></li>
<li><a href="#36-二叉搜索树与双向链表">36. 二叉搜索树与双向链表</a></li>
<li><a href="#37-序列化二叉树">37. 序列化二叉树</a></li>
<li><a href="#38-字符串的排列">38. 字符串的排列</a></li>
<li><a href="#39-数组中出现次数超过一半的数字">39. 数组中出现次数超过一半的数字</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="30-包含-min-函数的栈"><a href="#30-包含-min-函数的栈" class="headerlink" title="30. 包含 min 函数的栈"></a>30. 包含 min 函数的栈</h1><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    dataStack.push(node);</span><br><span class="line">    minStack.push(minStack.isEmpty() ? node : Math.min(minStack.peek(), node));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataStack.pop();</span><br><span class="line">    minStack.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minStack.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31. 栈的压入、弹出序列"></a>31. 栈的压入、弹出序列</h1><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&tqId=11174&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p>
<p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个栈来模拟压入弹出操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushSequence, <span class="keyword">int</span>[] popSequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = pushSequence.length;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>; pushIndex &lt; n; pushIndex++) &#123;</span><br><span class="line">        stack.push(pushSequence[pushIndex]);</span><br><span class="line">        <span class="keyword">while</span> (popIndex &lt; n &amp;&amp; !stack.isEmpty() </span><br><span class="line">                &amp;&amp; stack.peek() == popSequence[popIndex]) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            popIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1 从上往下打印二叉树"></a>32.1 从上往下打印二叉树</h1><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&tqId=11175&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p>
<div align="center"> <img src="../pics/d5e838cf-d8a2-49af-90df-1b2a714ee676.jpg" width="250"> </div><br>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用队列来进行层次遍历。</p>
<p>不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode t = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ret.add(t.val);</span><br><span class="line">            queue.add(t.left);</span><br><span class="line">            queue.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-2-把二叉树打印成多行"><a href="#32-2-把二叉树打印成多行" class="headerlink" title="32.2 把二叉树打印成多行"></a>32.2 把二叉树打印成多行</h1><p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&tqId=11213&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>和上题几乎一样。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() != <span class="number">0</span>)</span><br><span class="line">            ret.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="32-3-按之字形顺序打印二叉树"><a href="#32-3-按之字形顺序打印二叉树" class="headerlink" title="32.3 按之字形顺序打印二叉树"></a>32.3 按之字形顺序打印二叉树</h1><p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&tqId=11212&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(pRoot);</span><br><span class="line">    <span class="keyword">boolean</span> reverse = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (reverse)</span><br><span class="line">            Collections.reverse(list);</span><br><span class="line">        reverse = !reverse;</span><br><span class="line">        <span class="keyword">if</span> (list.size() != <span class="number">0</span>)</span><br><span class="line">            ret.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33. 二叉搜索树的后序遍历序列"></a>33. 二叉搜索树的后序遍历序列</h1><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p>
<p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p>
<div align="center"> <img src="../pics/13454fa1-23a8-4578-9663-2b13a6af564a.jpg" width="150"> </div><br>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> rootVal = sequence[last];</span><br><span class="line">    <span class="keyword">int</span> cutIndex = first;</span><br><span class="line">    <span class="keyword">while</span> (cutIndex &lt; last &amp;&amp; sequence[cutIndex] &lt;= rootVal)</span><br><span class="line">        cutIndex++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cutIndex; i &lt; last; i++)</span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &lt; rootVal)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> verify(sequence, first, cutIndex - <span class="number">1</span>) &amp;&amp; verify(sequence, cutIndex, last - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34. 二叉树中和为某一值的路径"></a>34. 二叉树中和为某一值的路径</h1><p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&tqId=11177&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p>
<div align="center"> <img src="../pics/ed77b0e6-38d9-4a34-844f-724f3ffa2c12.jpg" width="200"> </div><br>

<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    backtracking(root, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode node, <span class="keyword">int</span> target, ArrayList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    path.add(node.val);</span><br><span class="line">    target -= node.val;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span> &amp;&amp; node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        backtracking(node.left, target, path);</span><br><span class="line">        backtracking(node.right, target, path);</span><br><span class="line">    &#125;</span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h1><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> label;</span><br><span class="line">    RandomListNode next = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode random = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    RandomListNode(<span class="keyword">int</span> label) &#123;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="../pics/66a01953-5303-43b1-8646-0c77b825e980.png" width="300"> </div><br>

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步，在每个节点的后面插入复制的节点。</p>
<div align="center"> <img src="../pics/dfd5d3f8-673c-486b-8ecf-d2082107b67b.png" width="600"> </div><br>

<p>第二步，对复制节点的 random 链接进行赋值。</p>
<div align="center"> <img src="../pics/cafbfeb8-7dfe-4c0a-a3c9-750eeb824068.png" width="600"> </div><br>

<p>第三步，拆分。</p>
<div align="center"> <img src="../pics/e151b5df-5390-4365-b66e-b130cd253c12.png" width="600"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    RandomListNode cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = <span class="keyword">new</span> RandomListNode(cur.label);</span><br><span class="line">        clone.next = cur.next;</span><br><span class="line">        cur.next = clone;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立 random 链接</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode clone = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (cur.random != <span class="keyword">null</span>)</span><br><span class="line">            clone.random = cur.random.next;</span><br><span class="line">        cur = clone.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拆分</span></span><br><span class="line">    cur = pHead;</span><br><span class="line">    RandomListNode pCloneHead = pHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode next = cur.next;</span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pCloneHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h1><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<div align="center"> <img src="../pics/05a08f2e-9914-4a77-92ef-aebeaecf4f66.jpg" width="400"> </div><br>

<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    node.left = pre;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="keyword">null</span>)</span><br><span class="line">        pre.right = node;</span><br><span class="line">    pre = node;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        head = node;</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37. 序列化二叉树"></a>37. 序列化二叉树</h1><p><a href="https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&tqId=11214&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String deserializeStr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">return</span> root.val + <span class="string">" "</span> + Serialize(root.left) + <span class="string">" "</span> + Serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    deserializeStr = str;</span><br><span class="line">    <span class="keyword">return</span> Deserialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">Deserialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deserializeStr.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> index = deserializeStr.indexOf(<span class="string">" "</span>);</span><br><span class="line">    String node = index == -<span class="number">1</span> ? deserializeStr : deserializeStr.substring(<span class="number">0</span>, index);</span><br><span class="line">    deserializeStr = index == -<span class="number">1</span> ? <span class="string">""</span> : deserializeStr.substring(index + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.equals(<span class="string">"#"</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> val = Integer.valueOf(node);</span><br><span class="line">    TreeNode t = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    t.left = Deserialize();</span><br><span class="line">    t.right = Deserialize();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38. 字符串的排列"></a>38. 字符串的排列</h1><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&tqId=11180&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p>
<h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">    Arrays.sort(chars);</span><br><span class="line">    backtracking(chars, <span class="keyword">new</span> <span class="keyword">boolean</span>[chars.length], <span class="keyword">new</span> StringBuilder());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">boolean</span>[] hasUsed, StringBuilder s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == chars.length) &#123;</span><br><span class="line">        ret.add(s.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasUsed[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; chars[i] == chars[i - <span class="number">1</span>] &amp;&amp; !hasUsed[i - <span class="number">1</span>]) <span class="comment">/* 保证不重复 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        hasUsed[i] = <span class="keyword">true</span>;</span><br><span class="line">        s.append(chars[i]);</span><br><span class="line">        backtracking(chars, hasUsed, s);</span><br><span class="line">        s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">        hasUsed[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h1><p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&tqId=11181&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p>
<p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, cnt = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        cnt = nums[i] == majority ? cnt + <span class="number">1</span> : cnt - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            majority = nums[i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums)</span><br><span class="line">        <span class="keyword">if</span> (val == majority)</span><br><span class="line">            cnt++;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt; nums.length / <span class="number">2</span> ? majority : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 20~29</title>
    <url>/blog/post/931fadbb.html</url>
    <content><![CDATA[<ul>
<li><a href="#20-表示数值的字符串">20. 表示数值的字符串</a></li>
<li><a href="#21-调整数组顺序使奇数位于偶数前面">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="#22-链表中倒数第-k-个结点">22. 链表中倒数第 K 个结点</a></li>
<li><a href="#23-链表中环的入口结点">23. 链表中环的入口结点</a></li>
<li><a href="#24-反转链表">24. 反转链表</a></li>
<li><a href="#25-合并两个排序的链表">25. 合并两个排序的链表</a></li>
<li><a href="#26-树的子结构">26. 树的子结构</a></li>
<li><a href="#27-二叉树的镜像">27. 二叉树的镜像</a></li>
<li><a href="#28-对称的二叉树">28 对称的二叉树</a></li>
<li><a href="#29-顺时针打印矩阵">29. 顺时针打印矩阵</a><!-- GFM-TOC -->


</li>
</ul><h1 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20. 表示数值的字符串"></a>20. 表示数值的字符串</h1><p><a href="https://www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2?tpId=13&tqId=11206&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p><a id="more"></a><!-- GFM-TOC -->


<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line"></span><br><span class="line">&quot;+100&quot;</span><br><span class="line">&quot;5e2&quot;</span><br><span class="line">&quot;-123&quot;</span><br><span class="line">&quot;3.1416&quot;</span><br><span class="line">&quot;-1E-16&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">false</span><br><span class="line"></span><br><span class="line">&quot;12e&quot;</span><br><span class="line">&quot;1a3.14&quot;</span><br><span class="line">&quot;1.2.3&quot;</span><br><span class="line">&quot;+-5&quot;</span><br><span class="line">&quot;12e+4.3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用正则表达式进行匹配。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[]  ： 字符集合</span><br><span class="line">()  ： 分组</span><br><span class="line">?   ： 重复 0 ~ 1 次</span><br><span class="line">+   ： 重复 1 ~ n 次</span><br><span class="line">*   ： 重复 0 ~ n 次</span><br><span class="line">.   ： 任意字符</span><br><span class="line">\\. ： 转义后的 .</span><br><span class="line">\\d ： 数字</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(str).matches(<span class="string">"[+-]?\\d*(\\.\\d+)?([eE][+-]?\\d+)?"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h1><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。</p>
<div align="center"> <img src="../pics/d03a2efa-ef19-4c96-97e8-ff61df8061d3.png" width="200px"> </div><br>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数个数</span></span><br><span class="line">    <span class="keyword">int</span> oddCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums)</span><br><span class="line">        <span class="keyword">if</span> (!isEven(x))</span><br><span class="line">            oddCnt++;</span><br><span class="line">    <span class="keyword">int</span>[] copy = nums.clone();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = oddCnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : copy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[j++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：使用冒泡思想，每次都当前偶数上浮到当前最右边。时间复杂度 O(N<sup>2</sup>)，空间复杂度 O(1)，时间换空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEven(nums[j]) &amp;&amp; !isEven(nums[j + <span class="number">1</span>])) &#123;</span><br><span class="line">                swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEven</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-链表中倒数第-K-个结点"><a href="#22-链表中倒数第-K-个结点" class="headerlink" title="22. 链表中倒数第 K 个结点"></a>22. 链表中倒数第 K 个结点</h1><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p>
<div align="center"> <img src="../pics/6b504f1f-bf76-4aab-a146-a9c7a58c2029.png" width="500"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode P1 = head;</span><br><span class="line">    <span class="keyword">while</span> (P1 != <span class="keyword">null</span> &amp;&amp; k-- &gt; <span class="number">0</span>)</span><br><span class="line">        P1 = P1.next;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode P2 = head;</span><br><span class="line">    <span class="keyword">while</span> (P1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        P1 = P1.next;</span><br><span class="line">        P2 = P2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> P2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="23-链表中环的入口结点"><a href="#23-链表中环的入口结点" class="headerlink" title="23. 链表中环的入口结点"></a>23. 链表中环的入口结点</h1><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。</p>
<p>在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。</p>
<div align="center"> <img src="../pics/bb7fc182-98c2-4860-8ea3-630e27a5f29f.png" width="500"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode slow = pHead, fast = pHead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h1><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    ListNode newHead = ReverseList(next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>使用头插法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newList = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = newList.next;</span><br><span class="line">        newList.next = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newList.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a>25. 合并两个排序的链表</h1><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/c094d2bc-ec75-444b-af77-d369dfb6b3b4.png" width="400"> </div><br>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">        list1.next = Merge(list1.next, list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list2.next = Merge(list1, list2.next);</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1.val &lt;= list2.val) &#123;</span><br><span class="line">            cur.next = list1;</span><br><span class="line">            list1 = list1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = list2;</span><br><span class="line">            list2 = list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list1 != <span class="keyword">null</span>)</span><br><span class="line">        cur.next = list1;</span><br><span class="line">    <span class="keyword">if</span> (list2 != <span class="keyword">null</span>)</span><br><span class="line">        cur.next = list2;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a>26. 树的子结构</h1><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/84a5b15a-86c5-4d8e-9439-d9fd5a4699a1.jpg" width="450"> </div><br>

<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtreeWithRoot</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.val != root2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(root1.left, root2.left) &amp;&amp; isSubtreeWithRoot(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a>27. 二叉树的镜像</h1><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"> </div><br>

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    swap(root);</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    TreeNode t = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h1><p><a href="https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&tqId=11211&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/0c12221f-729e-4c22-b0ba-0dfc909f8adf.jpg" width="300"> </div><br>

<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val != t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1.left, t2.right) &amp;&amp; isSymmetrical(t1.right, t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h1><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p>
<div align="center"> <img src="../pics/48517227-324c-4664-bd26-a2d2cffe2bfe.png" width="200px"> </div><br>

<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> r1 = <span class="number">0</span>, r2 = matrix.length - <span class="number">1</span>, c1 = <span class="number">0</span>, c2 = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = c1; i &lt;= c2; i++)</span><br><span class="line">            ret.add(matrix[r1][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r1 + <span class="number">1</span>; i &lt;= r2; i++)</span><br><span class="line">            ret.add(matrix[i][c2]);</span><br><span class="line">        <span class="keyword">if</span> (r1 != r2)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = c2 - <span class="number">1</span>; i &gt;= c1; i--)</span><br><span class="line">                ret.add(matrix[r2][i]);</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r2 - <span class="number">1</span>; i &gt; r1; i--)</span><br><span class="line">                ret.add(matrix[i][c1]);</span><br><span class="line">        r1++; r2--; c1++; c2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 10~19</title>
    <url>/blog/post/ff9284a8.html</url>
    <content><![CDATA[<ul>
<li><a href="#101-斐波那契数列">10.1 斐波那契数列</a></li>
<li><a href="#102-矩形覆盖">10.2 矩形覆盖</a></li>
<li><a href="#103-跳台阶">10.3 跳台阶</a></li>
<li><a href="#104-变态跳台阶">10.4 变态跳台阶</a></li>
<li><a href="#11-旋转数组的最小数字">11. 旋转数组的最小数字</a></li>
<li><a href="#12-矩阵中的路径">12. 矩阵中的路径</a></li>
<li><a href="#13-机器人的运动范围">13. 机器人的运动范围</a></li>
<li><a href="#14-剪绳子">14. 剪绳子</a></li>
<li><a href="#15-二进制中-1-的个数">15. 二进制中 1 的个数</a></li>
<li><a href="#16-数值的整数次方">16. 数值的整数次方</a></li>
<li><a href="#17-打印从-1-到最大的-n-位数">17. 打印从 1 到最大的 n 位数</a></li>
<li><a href="#181-在-o1-时间内删除链表节点">18.1 在 O(1) 时间内删除链表节点</a></li>
<li><a href="#182-删除链表中重复的结点">18.2 删除链表中重复的结点</a></li>
<li><a href="#19-正则表达式匹配">19. 正则表达式匹配</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1 斐波那契数列"></a>10.1 斐波那契数列</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求斐波那契数列的第 n 项，n &lt;= 39。</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}0&&{n=0}\\1&&{n=1}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right." class="mathjax-pic"/></div> <br> -->

<div align="center"> <img src="../pics/45be9587-6069-4ab7-b9ac-840db1a53744.jpg" width="300px"> </div><br>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。</p>
<div align="center"> <img src="../pics/c13e2a3d-b01c-4a08-a69b-db2c4e821e09.png" width="350px"> </div><br>

<p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> fib[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> fib = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fib = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = fib;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于待求解的 n 小于 40，因此可以将前 40 项的结果先进行计算，之后就能以 O(1) 时间复杂度得到第 n 项的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] fib = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; fib.length; i++)</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-2-矩形覆盖"><a href="#10-2-矩形覆盖" class="headerlink" title="10.2 矩形覆盖"></a>10.2 矩形覆盖</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p>
<div align="center"> <img src="../pics/b903fda8-07d0-46a7-91a7-e803892895cf.gif" width="100px"> </div><br>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n 为 1 时，只有一种覆盖方法：</p>
<div align="center"> <img src="../pics/f6e146f1-57ad-411b-beb3-770a142164ef.png" width="100px"> </div><br>

<p>当 n 为 2 时，有两种覆盖方法：</p>
<div align="center"> <img src="../pics/fb3b8f7a-4293-4a38-aae1-62284db979a3.png" width="200px"> </div><br>

<p>要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：</p>
<!-- <div align="center"><img src="https://latex.codecogs.com/gif.latex?f(n)=\left\{\begin{array}{rcl}1&&{n=1}\\2&&{n=2}\\f(n-1)+f(n-2)&&{n>1}\end{array}\right." class="mathjax-pic"/></div> <br> -->

<div align="center"> <img src="../pics/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-3-跳台阶"><a href="#10-3-跳台阶" class="headerlink" title="10.3 跳台阶"></a>10.3 跳台阶</h1><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<div align="center"> <img src="../pics/9dae7475-934f-42e5-b3b3-12724337170a.png" width="380px"> </div><br>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>当 n = 1 时，只有一种跳法：</p>
<div align="center"> <img src="../pics/72aac98a-d5df-4bfa-a71a-4bb16a87474c.png" width="250px"> </div><br>

<p>当 n = 2 时，有两种跳法：</p>
<div align="center"> <img src="../pics/1b80288d-1b35-4cd3-aa17-7e27ab9a2389.png" width="300px"> </div><br>

<p>跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p>
<div align="center"> <img src="../pics/508c6e52-9f93-44ed-b6b9-e69050e14807.jpg" width="350px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result = pre2 + pre1;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-4-变态跳台阶"><a href="#10-4-变态跳台阶" class="headerlink" title="10.4 变态跳台阶"></a>10.4 变态跳台阶</h1><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<div align="center"> <img src="../pics/cd411a94-3786-4c94-9e08-f28320e010d5.png" width="380px"> </div><br>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] += dp[j];</span><br><span class="line">    <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h3><p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n-1) = f(n-2) + f(n-3) + ... + f(0)</span><br></pre></td></tr></table></figure>

<p>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) = f(n-1) + f(n-2) + ... + f(0)</span><br></pre></td></tr></table></figure>

<p>综上可得</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) - f(n-1) = f(n-1)</span><br></pre></td></tr></table></figure>

<p>即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(n) = 2*f(n-1)</span><br></pre></td></tr></table></figure>

<p>所以 f(n) 是一个等比数列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int JumpFloorII(int target) &#123;</span><br><span class="line">    return (int) Math.pow(2, target - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p>
<div align="center"> <img src="../pics/0038204c-4b8a-42a5-921d-080f6674f989.png" width="210px"> </div><br>

<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)（为了方便，这里将 log<sub>2</sub>N 写为 logN）。</p>
<div align="center"> <img src="../pics/424f34ab-a9fd-49a6-9969-d76b42251365.png" width="300px"> </div><br>

<p>此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p>
<p>通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：</p>
<ul>
<li>当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；</li>
<li>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[m] &amp;&amp; nums[m] == nums[h])</span><br><span class="line">            <span class="keyword">return</span> minNumber(nums, l, h);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt;= nums[h])</span><br><span class="line">            h = m;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; h; i++)</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12. 矩阵中的路径"></a>12. 矩阵中的路径</h1><p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p>
<p>例如下面的矩阵包含了一条 bfce 路径。</p>
<div align="center"> <img src="../pics/1db1c7ea-0443-478b-8df9-7e33b1336cc4.png" width="200px"> </div><br>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。</p>
<div align="center"> <img src="../pics/dc964b86-7a08-4bde-a3d9-e6ddceb29f98.png" width="200px"> </div><br>

<p>本题的输入是数组而不是矩阵（二维数组），因此需要先将数组转换成矩阵。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] array, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rows == <span class="number">0</span> || cols == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = buildMatrix(array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">            <span class="keyword">if</span> (backtracking(matrix, str, marked, <span class="number">0</span>, i, j))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">char</span>[] str,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> pathLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pathLen == str.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols</span><br><span class="line">            || matrix[r][c] != str[pathLen] || marked[r][c]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        <span class="keyword">if</span> (backtracking(matrix, str, marked, pathLen + <span class="number">1</span>, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] buildMatrix(<span class="keyword">char</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">char</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, idx = <span class="number">0</span>; r &lt; rows; r++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; cols; c++)</span><br><span class="line">            matrix[r][c] = array[idx++];</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13. 机器人的运动范围"></a>13. 机器人的运动范围</h1><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p>
<p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] next = &#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cols;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] digitSum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    <span class="keyword">this</span>.cols = cols;</span><br><span class="line">    <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">    initDigitSum();</span><br><span class="line">    <span class="keyword">boolean</span>[][] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">    dfs(marked, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[][] marked, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows || c &lt; <span class="number">0</span> || c &gt;= cols || marked[r][c])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    marked[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.digitSum[r][c] &gt; <span class="keyword">this</span>.threshold)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] n : next)</span><br><span class="line">        dfs(marked, r + n[<span class="number">0</span>], c + n[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDigitSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] digitSumOne = <span class="keyword">new</span> <span class="keyword">int</span>[Math.max(rows, cols)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digitSumOne.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            digitSumOne[i] += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.digitSum = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.rows; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.cols; j++)</span><br><span class="line">            <span class="keyword">this</span>.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14. 剪绳子"></a>14. 剪绳子</h1><p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode</a></p>
<h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">n = 2</span><br><span class="line">return 1 (2 = 1 + 1)</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">return 36 (10 = 3 + 3 + 4)</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p>
<p>证明：当 n &gt;= 5 时，3(n - 3) - n = 2n - 9 &gt; 0，且 2(n - 2) - n = n - 4 &gt; 0。因此在 n &gt;= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 &gt;= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf3 = n / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">        timesOf3--;</span><br><span class="line">    <span class="keyword">int</span> timesOf2 = (n - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3)) * (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-二进制中-1-的个数"><a href="#15-二进制中-1-的个数" class="headerlink" title="15. 二进制中 1 的个数"></a>15. 二进制中 1 的个数</h1><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数，输出该数二进制表示中 1 的个数。</p>
<h3 id="n-amp-n-1"><a href="#n-amp-n-1" class="headerlink" title="n&amp;(n-1)"></a>n&amp;(n-1)</h3><p>该位运算去除 n 的位级表示中最低的那一位。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n       : 10110100</span><br><span class="line">n-1     : 10110011</span><br><span class="line">n&amp;(n-1) : 10110000</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Integer-bitCount"><a href="#Integer-bitCount" class="headerlink" title="Integer.bitCount()"></a>Integer.bitCount()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16. 数值的整数次方"></a>16. 数值的整数次方</h1><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p>
<h2 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h2><p>下面的讨论中 x 代表 base，n 代表 exponent。</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?x^n=\left\{\begin{array}{rcl}(x*x)^{n/2}&&{n\%2=0}\\x*(x*x)^{n/2}&&{n\%2=1}\end{array}\right." class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="../pics/48b1d459-8832-4e92-938a-728aae730739.jpg" width="330px"> </div><br>


<p>因为 (x*x)<sup>n/2</sup> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        exponent = -exponent;</span><br><span class="line">        isNegative = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pow = Power(base * base, exponent / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (exponent % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        pow = pow * base;</span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="number">1</span> / pow : pow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-打印从-1-到最大的-n-位数"><a href="#17-打印从-1-到最大的-n-位数" class="headerlink" title="17. 打印从 1 到最大的 n 位数"></a>17. 打印从 1 到最大的 n 位数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p>
<h2 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p>
<p>使用回溯法得到所有的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[] number = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">    print1ToMaxOfNDigits(number, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigits</span><span class="params">(<span class="keyword">char</span>[] number, <span class="keyword">int</span> digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digit == number.length) &#123;</span><br><span class="line">        printNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        number[digit] = (<span class="keyword">char</span>) (i + <span class="string">'0'</span>);</span><br><span class="line">        print1ToMaxOfNDigits(number, digit + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(<span class="keyword">char</span>[] number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; number.length &amp;&amp; number[index] == <span class="string">'0'</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; number.length)</span><br><span class="line">        System.out.print(number[index++]);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-1-在-O-1-时间内删除链表节点"><a href="#18-1-在-O-1-时间内删除链表节点" class="headerlink" title="18.1 在 O(1) 时间内删除链表节点"></a>18.1 在 O(1) 时间内删除链表节点</h1><h2 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h2><p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p>
<div align="center"> <img src="../pics/1176f9e1-3442-4808-a47a-76fbaea1b806.png" width="600"> </div><br>

<p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p>
<div align="center"> <img src="../pics/4bf8d0ba-36f0-459e-83a0-f15278a5a157.png" width="600"> </div><br>

<p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点不是尾节点</span></span><br><span class="line">        ListNode next = tobeDelete.next;</span><br><span class="line">        tobeDelete.val = next.val;</span><br><span class="line">        tobeDelete.next = next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tobeDelete)</span><br><span class="line">             <span class="comment">// 只有一个节点</span></span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != tobeDelete)</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            cur.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-2-删除链表中重复的结点"><a href="#18-2-删除链表中重复的结点" class="headerlink" title="18.2 删除链表中重复的结点"></a>18.2 删除链表中重复的结点</h1><p><a href="https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&tqId=11209&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><div align="center"> <img src="../pics/17e301df-52e8-4886-b593-841a16d13e44.png" width="450"> </div><br>

<h2 id="解题描述"><a href="#解题描述" class="headerlink" title="解题描述"></a>解题描述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    ListNode next = pHead.next;</span><br><span class="line">    <span class="keyword">if</span> (pHead.val == next.val) &#123;</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="keyword">null</span> &amp;&amp; pHead.val == next.val)</span><br><span class="line">            next = next.next;</span><br><span class="line">        <span class="keyword">return</span> deleteDuplication(next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pHead.next = deleteDuplication(pHead.next);</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19. 正则表达式匹配"></a>19. 正则表达式匹配</h1><p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&tqId=11205&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括 &#39;.&#39; 和 &#39;*&#39; 的正则表达式。模式中的字符 &#39;.&#39; 表示任意一个字符，而 &#39;*&#39; 表示它前面的字符可以出现任意次（包含 0 次）。</p>
<p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 &quot;aaa&quot; 与模式 &quot;a.a&quot; 和 &quot;ab*ac*a&quot; 匹配，但是与 &quot;aa.a&quot; 和 &quot;ab*a&quot; 均不匹配。</p>
<h2 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h2><p>应该注意到，&#39;.&#39; 是用来当做一个任意字符，而 &#39;*&#39; 是用来重复前面的字符。这两个的作用不同，不能把 &#39;.&#39; 的作用和 &#39;*&#39; 进行类比，从而把它当成重复前面字符一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = str.length, n = pattern.length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (pattern[i - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (str[i - <span class="number">1</span>] == pattern[j - <span class="number">1</span>] || pattern[j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pattern[j - <span class="number">1</span>] == <span class="string">'*'</span>)</span><br><span class="line">                <span class="keyword">if</span> (pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>] || pattern[j - <span class="number">2</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    dp[i][j] |= dp[i][j - <span class="number">1</span>]; <span class="comment">// a* counts as single a</span></span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j]; <span class="comment">// a* counts as multiple a</span></span><br><span class="line">                    dp[i][j] |= dp[i][j - <span class="number">2</span>]; <span class="comment">// a* counts as empty</span></span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];   <span class="comment">// a* only counts as empty</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 题解 - 3~9</title>
    <url>/blog/post/dc8a4f0d.html</url>
    <content><![CDATA[<ul>
<li><a href="#3-数组中重复的数字">3. 数组中重复的数字</a></li>
<li><a href="#4-二维数组中的查找">4. 二维数组中的查找</a></li>
<li><a href="#5-替换空格">5. 替换空格</a></li>
<li><a href="#6-从尾到头打印链表">6. 从尾到头打印链表</a></li>
<li><a href="#7-重建二叉树">7. 重建二叉树</a></li>
<li><a href="#8-二叉树的下一个结点">8. 二叉树的下一个结点</a></li>
<li><a href="#9-用两个栈实现队列">9. 用两个栈实现队列</a><!-- GFM-TOC -->


</li>
</ul><h1 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&tqId=11203&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><a id="more"></a><!-- GFM-TOC -->



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;2, 3, 1, 0, 2, 5&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p>
<p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p>
<p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p>
<div align="center"> <img src="../pics/49d2adc1-b28a-44bf-babb-d44993f4a2e3.gif" width="250px"> </div><br>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4. 二维数组中的查找"></a>4. 二维数组中的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&tqId=11154&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Consider the following matrix:</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given target = 5, return true.</span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p>
<p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p>
<div align="center"> <img src="../pics/0ad9f7ba-f408-4999-a77a-9b73562c9088.gif" width="200px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = cols - <span class="number">1</span>; <span class="comment">// 从右上角开始</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt;= rows - <span class="number">1</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[r][c])</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5. 替换空格"></a>5. 替换空格</h1><p><a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&tqId=11155&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串中的空格替换成 &quot;%20&quot;。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p>
<p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p>
<p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p>
<div align="center"> <img src="../pics/6980aef0-debe-4b4b-8da5-8b1befbc1408.gif" width="230px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> P1 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= P1; i++)</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">            str.append(<span class="string">"  "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> P2 = str.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (P1 &gt;= <span class="number">0</span> &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(P1--);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'0'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'2'</span>);</span><br><span class="line">            str.setCharAt(P2--, <span class="string">'%'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. 从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>从尾到头反过来打印出每个结点的值。</p>
<div align="center"> <img src="../pics/f5792051-d9b2-4ca4-a234-a4a2de3d5a57.png" width="280px"> </div><br>

<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h3><p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">        ret.add(listNode.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用头插法"><a href="#使用头插法" class="headerlink" title="使用头插法"></a>使用头插法</h3><p>使用头插法可以得到一个逆序的链表。</p>
<p>头结点和第一个节点的区别：</p>
<ul>
<li>头结点是在头插法中使用的一个额外节点，这个节点不存储值；</li>
<li>第一个节点就是链表的第一个真正存储值的节点。</li>
</ul>
<div align="center"> <img src="../pics/0dae7e93-cfd1-4bd3-97e8-325b032b716f.gif" width="370px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头插法构建逆序链表</span></span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode memo = listNode.next;</span><br><span class="line">        listNode.next = head.next;</span><br><span class="line">        head.next = listNode;</span><br><span class="line">        listNode = memo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建 ArrayList</span></span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    head = head.next;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ret.add(head.val);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p>
<div align="center"> <img src="../pics/9d1deeba-4ae1-41dc-98f4-47d85b9831bc.gif" width="300px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (listNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">        ret.add(stack.pop());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7. 重建二叉树"></a>7. 重建二叉树</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&tqId=11157&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<div align="center"> <img src="../pics/31d9adce-2af8-4754-8386-0aabb4e500b0.png" width="300"> </div><br>

<h2 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。</p>
<div align="center"> <img src="../pics/c269e362-1128-4212-9cf3-d4c12b363b2f.gif" width="330px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存中序遍历数组每个值对应的索引</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexForInOrders = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++)</span><br><span class="line">        indexForInOrders.put(in[i], i);</span><br><span class="line">    <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preL &gt; preR)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">    <span class="keyword">int</span> inIndex = indexForInOrders.get(root.val);</span><br><span class="line">    <span class="keyword">int</span> leftTreeSize = inIndex - inL;</span><br><span class="line">    root.left = reConstructBinaryTree(pre, preL + <span class="number">1</span>, preL + leftTreeSize, inL);</span><br><span class="line">    root.right = reConstructBinaryTree(pre, preL + leftTreeSize + <span class="number">1</span>, preR, inL + leftTreeSize + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-二叉树的下一个结点"><a href="#8-二叉树的下一个结点" class="headerlink" title="8. 二叉树的下一个结点"></a>8. 二叉树的下一个结点</h1><p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&tqId=11210&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h2><p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p>
<div align="center"> <img src="../pics/b0611f89-1e5f-4494-a795-3544bf65042a.gif" width="220px"> </div><br>

<p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p>
<div align="center"> <img src="../pics/95080fae-de40-463d-a76e-783a0c677fec.gif" width="200px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeLinkNode node = pNode.right;</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode parent = pNode.next;</span><br><span class="line">            <span class="keyword">if</span> (parent.left == pNode)</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9. 用两个栈实现队列"></a>9. 用两个栈实现队列</h1><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&tqId=11158&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p>
<h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p>
<h2 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h2><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p>
<div align="center"> <img src="../pics/3ea280b5-be7d-471b-ac76-ff020384357c.gif" width="350"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    in.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">        <span class="keyword">while</span> (!in.isEmpty())</span><br><span class="line">            out.push(in.pop());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (out.isEmpty())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指 Offer</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - Database</title>
    <url>/blog/post/5d4aa9da.html</url>
    <content><![CDATA[<ul>
<li><a href="#595-Big-Countries">595. Big Countries</a></li>
<li><a href="#627-Swap-Salary">627. Swap Salary</a></li>
<li><a href="#620-Not-Boring-Movies">620. Not Boring Movies</a></li>
<li><a href="#596-Classes-More-Than-5-Students">596. Classes More Than 5 Students</a></li>
<li><a href="#182-Duplicate-Emails">182. Duplicate Emails</a></li>
<li><a href="#196-Delete-Duplicate-Emails">196. Delete Duplicate Emails</a></li>
<li><a href="#175-Combine-Two-Tables">175. Combine Two Tables</a></li>
<li><a href="#181-Employees-Earning-More-Than-Their-Managers">181. Employees Earning More Than Their Managers</a></li>
<li><a href="#183-Customers-Who-Never-Order">183. Customers Who Never Order</a></li>
<li><a href="#184-Department-Highest-Salary">184. Department Highest Salary</a></li>
<li><a href="#176-Second-Highest-Salary">176. Second Highest Salary</a></li>
<li><a href="#177-Nth-Highest-Salary">177. Nth Highest Salary</a></li>
<li><a href="#178-Rank-Scores">178. Rank Scores</a></li>
<li><a href="#180-Consecutive-Numbers">180. Consecutive Numbers</a></li>
<li><a href="#626-Exchange-Seats">626. Exchange Seats</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="595-Big-Countries"><a href="#595-Big-Countries" class="headerlink" title="595. Big Countries"></a>595. Big Countries</h1><p>https://leetcode.com/problems/big-countries/description/</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure>

<p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema"><a href="#SQL-Schema" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><p>SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境解答。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> World;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> World ( <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), continent <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), area <span class="built_in">INT</span>, population <span class="built_in">INT</span>, gdp <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> World ( <span class="keyword">NAME</span>, continent, area, population, gdp )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">'Afghanistan'</span>, <span class="string">'Asia'</span>, <span class="string">'652230'</span>, <span class="string">'25500100'</span>, <span class="string">'203430000'</span> ),</span><br><span class="line">    ( <span class="string">'Albania'</span>, <span class="string">'Europe'</span>, <span class="string">'28748'</span>, <span class="string">'2831741'</span>, <span class="string">'129600000'</span> ),</span><br><span class="line">    ( <span class="string">'Algeria'</span>, <span class="string">'Africa'</span>, <span class="string">'2381741'</span>, <span class="string">'37100000'</span>, <span class="string">'1886810000'</span> ),</span><br><span class="line">    ( <span class="string">'Andorra'</span>, <span class="string">'Europe'</span>, <span class="string">'468'</span>, <span class="string">'78115'</span>, <span class="string">'37120000'</span> ),</span><br><span class="line">    ( <span class="string">'Angola'</span>, <span class="string">'Africa'</span>, <span class="string">'1246700'</span>, <span class="string">'20609294'</span>, <span class="string">'1009900000'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,</span><br><span class="line">    population,</span><br><span class="line">    area</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    World</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    area &gt; <span class="number">3000000</span></span><br><span class="line">    <span class="keyword">OR</span> population &gt; <span class="number">25000000</span>;</span><br></pre></td></tr></table></figure>

<h1 id="627-Swap-Salary"><a href="#627-Swap-Salary" class="headerlink" title="627. Swap Salary"></a>627. Swap Salary</h1><p>https://leetcode.com/problems/swap-salary/description/</p>
<h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure>

<p>只用一个 SQL 查询，将 sex 字段反转。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-1"><a href="#SQL-Schema-1" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> salary;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salary ( <span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">100</span> ), sex <span class="built_in">CHAR</span> ( <span class="number">1</span> ), salary <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salary ( <span class="keyword">id</span>, <span class="keyword">NAME</span>, sex, salary )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">'1'</span>, <span class="string">'A'</span>, <span class="string">'m'</span>, <span class="string">'2500'</span> ),</span><br><span class="line">    ( <span class="string">'2'</span>, <span class="string">'B'</span>, <span class="string">'f'</span>, <span class="string">'1500'</span> ),</span><br><span class="line">    ( <span class="string">'3'</span>, <span class="string">'C'</span>, <span class="string">'m'</span>, <span class="string">'5500'</span> ),</span><br><span class="line">    ( <span class="string">'4'</span>, <span class="string">'D'</span>, <span class="string">'f'</span>, <span class="string">'500'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>使用异或操作，两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;f&apos; ^ &apos;m&apos; ^ &apos;f&apos; = &apos;m&apos;</span><br><span class="line">&apos;m&apos; ^ &apos;m&apos; ^ &apos;f&apos; = &apos;f&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> salary</span><br><span class="line"><span class="keyword">SET</span> sex = <span class="built_in">CHAR</span> ( <span class="keyword">ASCII</span>(sex) ^ <span class="keyword">ASCII</span>( <span class="string">'m'</span> ) ^ <span class="keyword">ASCII</span>( <span class="string">'f'</span> ) );</span><br></pre></td></tr></table></figure>

<h1 id="620-Not-Boring-Movies"><a href="#620-Not-Boring-Movies" class="headerlink" title="620. Not Boring Movies"></a>620. Not Boring Movies</h1><p>https://leetcode.com/problems/not-boring-movies/description/</p>
<h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>

<p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-2"><a href="#SQL-Schema-2" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> cinema;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cinema ( <span class="keyword">id</span> <span class="built_in">INT</span>, movie <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), description <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), rating <span class="built_in">FLOAT</span> ( <span class="number">2</span>, <span class="number">1</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cinema ( <span class="keyword">id</span>, movie, description, rating )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'War'</span>, <span class="string">'great 3D'</span>, <span class="number">8.9</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'Science'</span>, <span class="string">'fiction'</span>, <span class="number">8.5</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">'irish'</span>, <span class="string">'boring'</span>, <span class="number">6.2</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">'Ice song'</span>, <span class="string">'Fantacy'</span>, <span class="number">8.6</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="string">'House card'</span>, <span class="string">'Interesting'</span>, <span class="number">9.1</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    cinema</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">id</span> % <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> description != <span class="string">'boring'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    rating <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h1 id="596-Classes-More-Than-5-Students"><a href="#596-Classes-More-Than-5-Students" class="headerlink" title="596. Classes More Than 5 Students"></a>596. Classes More Than 5 Students</h1><p>https://leetcode.com/problems/classes-more-than-5-students/description/</p>
<h2 id="Description-3"><a href="#Description-3" class="headerlink" title="Description"></a>Description</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure>

<p>查找有五名及以上 student 的 class。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-3"><a href="#SQL-Schema-3" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> courses;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> courses ( student <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), <span class="keyword">class</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> courses ( student, <span class="keyword">class</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">'A'</span>, <span class="string">'Math'</span> ),</span><br><span class="line">    ( <span class="string">'B'</span>, <span class="string">'English'</span> ),</span><br><span class="line">    ( <span class="string">'C'</span>, <span class="string">'Math'</span> ),</span><br><span class="line">    ( <span class="string">'D'</span>, <span class="string">'Biology'</span> ),</span><br><span class="line">    ( <span class="string">'E'</span>, <span class="string">'Math'</span> ),</span><br><span class="line">    ( <span class="string">'F'</span>, <span class="string">'Computer'</span> ),</span><br><span class="line">    ( <span class="string">'G'</span>, <span class="string">'Math'</span> ),</span><br><span class="line">    ( <span class="string">'H'</span>, <span class="string">'Math'</span> ),</span><br><span class="line">    ( <span class="string">'I'</span>, <span class="string">'Math'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h2><p>对 class 列进行分组之后，再使用 count 汇总函数统计数量，统计之后使用 having 进行过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">class</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    courses</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="keyword">class</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="keyword">count</span>( <span class="keyword">DISTINCT</span> student ) &gt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h1 id="182-Duplicate-Emails"><a href="#182-Duplicate-Emails" class="headerlink" title="182. Duplicate Emails"></a>182. Duplicate Emails</h1><p>https://leetcode.com/problems/duplicate-emails/description/</p>
<h2 id="Description-4"><a href="#Description-4" class="headerlink" title="Description"></a>Description</h2><p>邮件地址表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>

<p>查找重复的邮件地址：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-4"><a href="#SQL-Schema-4" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Person;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Person ( <span class="keyword">Id</span> <span class="built_in">INT</span>, Email <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Person ( <span class="keyword">Id</span>, Email )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'a@b.com'</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'c@d.com'</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">'a@b.com'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h2><p>对 Email 进行分组，如果相同 Email 的数量大于等于 2，则表示该 Email 重复。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    Email</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    <span class="keyword">COUNT</span>( * ) &gt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="196-Delete-Duplicate-Emails"><a href="#196-Delete-Duplicate-Emails" class="headerlink" title="196. Delete Duplicate Emails"></a>196. Delete Duplicate Emails</h1><p>https://leetcode.com/problems/delete-duplicate-emails/description/</p>
<h2 id="Description-5"><a href="#Description-5" class="headerlink" title="Description"></a>Description</h2><p>邮件地址表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>

<p>删除重复的邮件地址：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-5"><a href="#SQL-Schema-5" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><p>与 182 相同。</p>
<h2 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h2><p>只保留相同 Email 中 Id 最小的那一个，然后删除其它的。</p>
<p>连接：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> p1</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person p1,</span><br><span class="line">    Person p2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p1.Email = p2.Email</span><br><span class="line">    <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>

<p>子查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> <span class="keyword">min</span>( <span class="keyword">id</span> ) <span class="keyword">AS</span> <span class="keyword">id</span> <span class="keyword">FROM</span> Person <span class="keyword">GROUP</span> <span class="keyword">BY</span> email ) <span class="keyword">AS</span> m );</span><br></pre></td></tr></table></figure>

<p>应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can&#39;t specify target table &#39;Person&#39; for update in FROM clause。以下演示了这种错误解法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">min</span>( <span class="keyword">id</span> ) <span class="keyword">AS</span> <span class="keyword">id</span> <span class="keyword">FROM</span> Person <span class="keyword">GROUP</span> <span class="keyword">BY</span> email );</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause" target="_blank" rel="noopener">pMySQL Error 1093 - Can&#39;t specify target table for update in FROM clause</a></p>
<h1 id="175-Combine-Two-Tables"><a href="#175-Combine-Two-Tables" class="headerlink" title="175. Combine Two Tables"></a>175. Combine Two Tables</h1><p>https://leetcode.com/problems/combine-two-tables/description/</p>
<h2 id="Description-6"><a href="#Description-6" class="headerlink" title="Description"></a>Description</h2><p>Person 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId is the primary key column for this table.</span><br></pre></td></tr></table></figure>

<p>Address 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId is the primary key column for this table.</span><br></pre></td></tr></table></figure>

<p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p>
<h2 id="SQL-Schema-6"><a href="#SQL-Schema-6" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Person;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Person ( PersonId <span class="built_in">INT</span>, FirstName <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), LastName <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Address;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Address ( AddressId <span class="built_in">INT</span>, PersonId <span class="built_in">INT</span>, City <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), State <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Person ( PersonId, LastName, FirstName )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'Wang'</span>, <span class="string">'Allen'</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Address ( AddressId, PersonId, City, State )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">2</span>, <span class="string">'New York City'</span>, <span class="string">'New York'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h2><p>涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    FirstName,</span><br><span class="line">    LastName,</span><br><span class="line">    City,</span><br><span class="line">    State</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Person P</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Address A</span><br><span class="line">    <span class="keyword">ON</span> P.PersonId = A.PersonId;</span><br></pre></td></tr></table></figure>

<h1 id="181-Employees-Earning-More-Than-Their-Managers"><a href="#181-Employees-Earning-More-Than-Their-Managers" class="headerlink" title="181. Employees Earning More Than Their Managers"></a>181. Employees Earning More Than Their Managers</h1><p>https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</p>
<h2 id="Description-7"><a href="#Description-7" class="headerlink" title="Description"></a>Description</h2><p>Employee 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>

<p>查找薪资大于其经理薪资的员工信息。</p>
<h2 id="SQL-Schema-7"><a href="#SQL-Schema-7" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( <span class="keyword">Id</span> <span class="built_in">INT</span>, <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), Salary <span class="built_in">INT</span>, ManagerId <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( <span class="keyword">Id</span>, <span class="keyword">NAME</span>, Salary, ManagerId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'Joe'</span>, <span class="number">70000</span>, <span class="number">3</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'Henry'</span>, <span class="number">80000</span>, <span class="number">4</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">'Sam'</span>, <span class="number">60000</span>, <span class="literal">NULL</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">'Max'</span>, <span class="number">90000</span>, <span class="literal">NULL</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    E1.NAME <span class="keyword">AS</span> Employee</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee E1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Employee E2</span><br><span class="line">    <span class="keyword">ON</span> E1.ManagerId = E2.Id</span><br><span class="line">    <span class="keyword">AND</span> E1.Salary &gt; E2.Salary;</span><br></pre></td></tr></table></figure>

<h1 id="183-Customers-Who-Never-Order"><a href="#183-Customers-Who-Never-Order" class="headerlink" title="183. Customers Who Never Order"></a>183. Customers Who Never Order</h1><p>https://leetcode.com/problems/customers-who-never-order/description/</p>
<h2 id="Description-8"><a href="#Description-8" class="headerlink" title="Description"></a>Description</h2><p>Customers 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<p>Orders 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>

<p>查找没有订单的顾客信息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-8"><a href="#SQL-Schema-8" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Customers;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Customers ( <span class="keyword">Id</span> <span class="built_in">INT</span>, <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Orders;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders ( <span class="keyword">Id</span> <span class="built_in">INT</span>, CustomerId <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Customers ( <span class="keyword">Id</span>, <span class="keyword">NAME</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'Joe'</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'Henry'</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">'Sam'</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">'Max'</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Orders ( <span class="keyword">Id</span>, CustomerId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">3</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">1</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h2><p>左外链接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    C.Name <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Customers C</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders O</span><br><span class="line">    <span class="keyword">ON</span> C.Id = O.CustomerId</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    O.CustomerId <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">Name</span> <span class="keyword">AS</span> Customers</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Customers</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">Id</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> CustomerId <span class="keyword">FROM</span> Orders );</span><br></pre></td></tr></table></figure>

<h1 id="184-Department-Highest-Salary"><a href="#184-Department-Highest-Salary" class="headerlink" title="184. Department Highest Salary"></a>184. Department Highest Salary</h1><p>https://leetcode.com/problems/department-highest-salary/description/</p>
<h2 id="Description-9"><a href="#Description-9" class="headerlink" title="Description"></a>Description</h2><p>Employee 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>

<p>Department 表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>

<p>查找一个 Department 中收入最高者的信息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-9"><a href="#SQL-Schema-9" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( <span class="keyword">Id</span> <span class="built_in">INT</span>, <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ), Salary <span class="built_in">INT</span>, DepartmentId <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> Department;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department ( <span class="keyword">Id</span> <span class="built_in">INT</span>, <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( <span class="keyword">Id</span>, <span class="keyword">NAME</span>, Salary, DepartmentId )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'Joe'</span>, <span class="number">70000</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'Henry'</span>, <span class="number">80000</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="string">'Sam'</span>, <span class="number">60000</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="string">'Max'</span>, <span class="number">90000</span>, <span class="number">1</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Department ( <span class="keyword">Id</span>, <span class="keyword">NAME</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="string">'IT'</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="string">'Sales'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h2><p>创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。</p>
<p>之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    D.NAME Department,</span><br><span class="line">    E.NAME Employee,</span><br><span class="line">    E.Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee E,</span><br><span class="line">    Department D,</span><br><span class="line">    ( <span class="keyword">SELECT</span> DepartmentId, <span class="keyword">MAX</span>( Salary ) Salary <span class="keyword">FROM</span> Employee <span class="keyword">GROUP</span> <span class="keyword">BY</span> DepartmentId ) M</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    E.DepartmentId = D.Id</span><br><span class="line">    <span class="keyword">AND</span> E.DepartmentId = M.DepartmentId</span><br><span class="line">    <span class="keyword">AND</span> E.Salary = M.Salary;</span><br></pre></td></tr></table></figure>

<h1 id="176-Second-Highest-Salary"><a href="#176-Second-Highest-Salary" class="headerlink" title="176. Second Highest Salary"></a>176. Second Highest Salary</h1><p>https://leetcode.com/problems/second-highest-salary/description/</p>
<h2 id="Description-10"><a href="#Description-10" class="headerlink" title="Description"></a>Description</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>

<p>查找工资第二高的员工。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<p>没有找到返回 null 而不是不返回数据。</p>
<h2 id="SQL-Schema-10"><a href="#SQL-Schema-10" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Employee;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employee ( <span class="keyword">Id</span> <span class="built_in">INT</span>, Salary <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Employee ( <span class="keyword">Id</span>, Salary )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">100</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">200</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">300</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h2><p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    ( <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>, <span class="number">1</span> ) SecondHighestSalary;</span><br></pre></td></tr></table></figure>

<h1 id="177-Nth-Highest-Salary"><a href="#177-Nth-Highest-Salary" class="headerlink" title="177. Nth Highest Salary"></a>177. Nth Highest Salary</h1><h2 id="Description-11"><a href="#Description-11" class="headerlink" title="Description"></a>Description</h2><p>查找工资第 N 高的员工。</p>
<h2 id="SQL-Schema-11"><a href="#SQL-Schema-11" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><p>同 176。</p>
<h2 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary ( N <span class="built_in">INT</span> ) <span class="keyword">RETURNS</span> <span class="built_in">INT</span> <span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> N = N - <span class="number">1</span>;</span><br><span class="line">RETURN ( <span class="keyword">SELECT</span> ( <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary <span class="keyword">FROM</span> Employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> N, <span class="number">1</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<h1 id="178-Rank-Scores"><a href="#178-Rank-Scores" class="headerlink" title="178. Rank Scores"></a>178. Rank Scores</h1><p>https://leetcode.com/problems/rank-scores/description/</p>
<h2 id="Description-12"><a href="#Description-12" class="headerlink" title="Description"></a>Description</h2><p>得分表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>

<p>将得分排序，并统计排名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-12"><a href="#SQL-Schema-12" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> Scores;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Scores ( <span class="keyword">Id</span> <span class="built_in">INT</span>, Score <span class="built_in">DECIMAL</span> ( <span class="number">3</span>, <span class="number">2</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Scores ( <span class="keyword">Id</span>, Score )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">3.5</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">3.65</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">4.0</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="number">3.85</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="number">4.0</span> ),</span><br><span class="line">    ( <span class="number">6</span>, <span class="number">3.65</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-12"><a href="#Solution-12" class="headerlink" title="Solution"></a>Solution</h2><p>要统计某个 score 的排名，只要统计大于该 score 的 score 数量，然后加 1。</p>
<table>
<thead>
<tr>
<th align="center">score</th>
<th align="center">大于该 score 的 score 数量</th>
<th align="center">排名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4.1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4.2</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4.3</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>但是在本题中，相同的 score 只算一个排名：</p>
<table>
<thead>
<tr>
<th align="center">score</th>
<th align="center">排名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4.1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4.1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4.2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4.2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4.3</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">4.3</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>可以按 score 进行分组，将同一个分组中的 score 只当成一个。</p>
<p>但是如果分组字段只有 score 的话，那么相同的 score 最后的结果只会有一个，例如上面的 6 个记录最后只取出 3 个。</p>
<table>
<thead>
<tr>
<th align="center">score</th>
<th align="center">排名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4.1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4.2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">4.3</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>所以在分组中需要加入 Id，每个记录显示一个结果。综上，需要使用 score 和 id 两个分组字段。</p>
<p>在下面的实现中，首先将 Scores 表根据 score 字段进行自连接，得到一个新表，然后在新表上对 id 和 score 进行分组。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    S1.score <span class="string">'Score'</span>,</span><br><span class="line">    <span class="keyword">COUNT</span>( <span class="keyword">DISTINCT</span> S2.score ) <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Scores S1</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Scores S2</span><br><span class="line">    <span class="keyword">ON</span> S1.score &lt;= S2.score</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    S1.id, S1.score</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    S1.score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<h1 id="180-Consecutive-Numbers"><a href="#180-Consecutive-Numbers" class="headerlink" title="180. Consecutive Numbers"></a>180. Consecutive Numbers</h1><p>https://leetcode.com/problems/consecutive-numbers/description/</p>
<h2 id="Description-13"><a href="#Description-13" class="headerlink" title="Description"></a>Description</h2><p>数字表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+----+-----+</span><br><span class="line">| Id | Num |</span><br><span class="line">+----+-----+</span><br><span class="line">| 1  |  1  |</span><br><span class="line">| 2  |  1  |</span><br><span class="line">| 3  |  1  |</span><br><span class="line">| 4  |  2  |</span><br><span class="line">| 5  |  1  |</span><br><span class="line">| 6  |  2  |</span><br><span class="line">| 7  |  2  |</span><br><span class="line">+----+-----+</span><br></pre></td></tr></table></figure>

<p>查找连续出现三次的数字。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+-----------------+</span><br><span class="line">| ConsecutiveNums |</span><br><span class="line">+-----------------+</span><br><span class="line">| 1               |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-13"><a href="#SQL-Schema-13" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> <span class="keyword">LOGS</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">LOGS</span> ( <span class="keyword">Id</span> <span class="built_in">INT</span>, <span class="keyword">Num</span> <span class="built_in">INT</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">LOGS</span> ( <span class="keyword">Id</span>, <span class="keyword">Num</span> )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">1</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">2</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">3</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">4</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">5</span>, <span class="number">1</span> ),</span><br><span class="line">    ( <span class="number">6</span>, <span class="number">2</span> ),</span><br><span class="line">    ( <span class="number">7</span>, <span class="number">2</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-13"><a href="#Solution-13" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">DISTINCT</span> L1.num ConsecutiveNums</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">Logs</span> L1,</span><br><span class="line">    <span class="keyword">Logs</span> L2,</span><br><span class="line">    <span class="keyword">Logs</span> L3</span><br><span class="line"><span class="keyword">WHERE</span> L1.id = l2.id - <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> L2.id = L3.id - <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> L1.num = L2.num</span><br><span class="line">    <span class="keyword">AND</span> l2.num = l3.num;</span><br></pre></td></tr></table></figure>

<h1 id="626-Exchange-Seats"><a href="#626-Exchange-Seats" class="headerlink" title="626. Exchange Seats"></a>626. Exchange Seats</h1><p>https://leetcode.com/problems/exchange-seats/description/</p>
<h2 id="Description-14"><a href="#Description-14" class="headerlink" title="Description"></a>Description</h2><p>seat 表存储着座位对应的学生。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure>

<p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure>

<h2 id="SQL-Schema-14"><a href="#SQL-Schema-14" class="headerlink" title="SQL Schema"></a>SQL Schema</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">IF</span></span><br><span class="line">    <span class="keyword">EXISTS</span> seat;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seat ( <span class="keyword">id</span> <span class="built_in">INT</span>, student <span class="built_in">VARCHAR</span> ( <span class="number">255</span> ) );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> seat ( <span class="keyword">id</span>, student )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="string">'1'</span>, <span class="string">'Abbot'</span> ),</span><br><span class="line">    ( <span class="string">'2'</span>, <span class="string">'Doris'</span> ),</span><br><span class="line">    ( <span class="string">'3'</span>, <span class="string">'Emerson'</span> ),</span><br><span class="line">    ( <span class="string">'4'</span>, <span class="string">'Green'</span> ),</span><br><span class="line">    ( <span class="string">'5'</span>, <span class="string">'Jeames'</span> );</span><br></pre></td></tr></table></figure>

<h2 id="Solution-14"><a href="#Solution-14" class="headerlink" title="Solution"></a>Solution</h2><p>使用多个 union。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理偶数 id，让 id 减 1</span></span><br><span class="line"><span class="comment"># 例如 2,4,6,... 变成 1,3,5,...</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s1.id - <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">id</span>,</span><br><span class="line">    s1.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s1.id <span class="keyword">MOD</span> <span class="number">2</span> = <span class="number">0</span> <span class="keyword">UNION</span></span><br><span class="line"><span class="comment"># 处理奇数 id，让 id 加 1。但是如果最大的 id 为奇数，则不做处理</span></span><br><span class="line"><span class="comment"># 例如 1,3,5,... 变成 2,4,6,...</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s2.id + <span class="number">1</span> <span class="keyword">AS</span> <span class="keyword">id</span>,</span><br><span class="line">    s2.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s2.id <span class="keyword">MOD</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> s2.id != ( <span class="keyword">SELECT</span> <span class="keyword">max</span>( s3.id ) <span class="keyword">FROM</span> seat s3 ) <span class="keyword">UNION</span></span><br><span class="line"><span class="comment"># 如果最大的 id 为奇数，单独取出这个数</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    s4.id <span class="keyword">AS</span> <span class="keyword">id</span>,</span><br><span class="line">    s4.student</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    seat s4</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    s4.id <span class="keyword">MOD</span> <span class="number">2</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">AND</span> s4.id = ( <span class="keyword">SELECT</span> <span class="keyword">max</span>( s5.id ) <span class="keyword">FROM</span> seat s5 )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    <span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>sql</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 位运算</title>
    <url>/blog/post/3ad6972f.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-统计两个数的二进制表示有多少位不同">1. 统计两个数的二进制表示有多少位不同</a></li>
<li><a href="#2-数组中唯一一个不重复的元素">2. 数组中唯一一个不重复的元素</a></li>
<li><a href="#3-找出数组中缺失的那个数">3. 找出数组中缺失的那个数</a></li>
<li><a href="#4-数组中不重复的两个元素">4. 数组中不重复的两个元素</a></li>
<li><a href="#5-翻转一个数的比特位">5. 翻转一个数的比特位</a></li>
<li><a href="#6-不用额外变量交换两个整数">6. 不用额外变量交换两个整数</a></li>
<li><a href="#7-判断一个数是不是-2-的-n-次方">7. 判断一个数是不是 2 的 n 次方</a></li>
<li><a href="#8--判断一个数是不是-4-的-n-次方">8.  判断一个数是不是 4 的 n 次方</a></li>
<li><a href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1">9. 判断一个数的位级表示是否不会出现连续的 0 和 1</a></li>
<li><a href="#10-求一个数的补码">10. 求一个数的补码</a></li>
<li><a href="#11-实现整数的加法">11. 实现整数的加法</a></li>
<li><a href="#12-字符串数组最大乘积">12. 字符串数组最大乘积</a></li>
<li><a href="#13-统计从-0-~-n-每个数的二进制表示中-1-的个数">13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<p><strong>基本原理</strong> </p>
<p>0s 表示一串 0，1s 表示一串 1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class="line">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class="line">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>

<ul>
<li>利用 x ^ 1s = ~x 的特点，可以将位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</li>
<li>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</li>
<li>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</li>
</ul>
<p>位与运算技巧：</p>
<ul>
<li>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。</li>
<li>n&amp;(-n) 得到 n 的位级表示中最低的那一位。-n 得到 n 的反码加 1，对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</li>
<li>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</li>
</ul>
<p>移位运算：</p>
<ul>
<li>&gt;&gt; n 为算术右移，相当于除以 2<sup>n</sup>；</li>
<li>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。</li>
<li>&lt;&lt; n 为算术左移，相当于乘以 2<sup>n</sup>。</li>
</ul>
<p>** mask 计算** </p>
<p>要获取 111111111，将 0 取反即可，~0。</p>
<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>
<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>
<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>
<p><strong>Java 中的位操作</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">static int Integer.bitCount();           // 统计 1 的数量</span><br><span class="line">static int Integer.highestOneBit();      // 获得最高位</span><br><span class="line">static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>

<h1 id="1-统计两个数的二进制表示有多少位不同"><a href="#1-统计两个数的二进制表示有多少位不同" class="headerlink" title="1. 统计两个数的二进制表示有多少位不同"></a>1. 统计两个数的二进制表示有多少位不同</h1><ol start="461">
<li>Hamming Distance (Easy)</li>
</ol>
<p><a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure>

<p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(z != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">1</span>) cnt++;</span><br><span class="line">        z = z &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (z != <span class="number">0</span>) &#123;</span><br><span class="line">        z &amp;= (z - <span class="number">1</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用 Integer.bitcount() 来统计 1 个的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.bitCount(x ^ y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-数组中唯一一个不重复的元素"><a href="#2-数组中唯一一个不重复的元素" class="headerlink" title="2. 数组中唯一一个不重复的元素"></a>2. 数组中唯一一个不重复的元素</h1><p>136. Single Number (Easy)</p>
<p><a href="https://leetcode.com/problems/single-number/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/single-number/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) ret = ret ^ n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-找出数组中缺失的那个数"><a href="#3-找出数组中缺失的那个数" class="headerlink" title="3. 找出数组中缺失的那个数"></a>3. 找出数组中缺失的那个数</h1><p>268. Missing Number (Easy)</p>
<p><a href="https://leetcode.com/problems/missing-number/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/missing-number/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [3,0,1]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>题目描述：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        ret = ret ^ i ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret ^ nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-数组中不重复的两个元素"><a href="#4-数组中不重复的两个元素" class="headerlink" title="4. 数组中不重复的两个元素"></a>4. 数组中不重复的两个元素</h1><p>260. Single Number III (Medium)</p>
<p><a href="https://leetcode.com/problems/single-number-iii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/single-number-iii/description/" target="_blank" rel="noopener">力扣</a></p>
<p>两个不相等的元素在位级表示上必定会有一位存在不同。</p>
<p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p>
<p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) diff ^= num;</span><br><span class="line">    diff &amp;= -diff;  <span class="comment">// 得到最右一位</span></span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>) ret[<span class="number">0</span>] ^= num;</span><br><span class="line">        <span class="keyword">else</span> ret[<span class="number">1</span>] ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-翻转一个数的比特位"><a href="#5-翻转一个数的比特位" class="headerlink" title="5. 翻转一个数的比特位"></a>5. 翻转一个数的比特位</h1><p>190. Reverse Bits (Easy)</p>
<p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-bits/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ret |= (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该函数需要被调用很多次，可以将 int 拆成 4 个 byte，然后缓存 byte 对应的比特位翻转，最后再拼接起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, Integer&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">        ret |= reverseByte((<span class="keyword">byte</span>) (n &amp; <span class="number">0b11111111</span>));</span><br><span class="line">        n &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">reverseByte</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(b)) <span class="keyword">return</span> cache.get(b);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span> t = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        ret &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        ret |= t &amp; <span class="number">1</span>;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cache.put(b, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-不用额外变量交换两个整数"><a href="#6-不用额外变量交换两个整数" class="headerlink" title="6. 不用额外变量交换两个整数"></a>6. 不用额外变量交换两个整数</h1><p><a href="#">程序员代码面试指南 ：P317</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>

<h1 id="7-判断一个数是不是-2-的-n-次方"><a href="#7-判断一个数是不是-2-的-n-次方" class="headerlink" title="7. 判断一个数是不是 2 的 n 次方"></a>7. 判断一个数是不是 2 的 n 次方</h1><p>231. Power of Two (Easy)</p>
<p><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/power-of-two/description/" target="_blank" rel="noopener">力扣</a></p>
<p>二进制表示只有一个 1 存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; Integer.bitCount(n) == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-判断一个数是不是-4-的-n-次方"><a href="#8-判断一个数是不是-4-的-n-次方" class="headerlink" title="8.  判断一个数是不是 4 的 n 次方"></a>8.  判断一个数是不是 4 的 n 次方</h1><p>342. Power of Four (Easy)</p>
<p><a href="https://leetcode.com/problems/power-of-four/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">力扣</a></p>
<p>这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; (num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (num &amp; <span class="number">0b01010101010101010101010101010101</span>) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以使用正则表达式进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(num, <span class="number">4</span>).matches(<span class="string">"10*"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-判断一个数的位级表示是否不会出现连续的-0-和-1"><a href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1" class="headerlink" title="9. 判断一个数的位级表示是否不会出现连续的 0 和 1"></a>9. 判断一个数的位级表示是否不会出现连续的 0 和 1</h1><p>693. Binary Number with Alternating Bits (Easy)</p>
<p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/binary-number-with-alternating-bits/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: True</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 10 is: 1010.</span><br><span class="line"></span><br><span class="line">Input: 11</span><br><span class="line">Output: False</span><br><span class="line">Explanation:</span><br><span class="line">The binary representation of 11 is: 1011.</span><br></pre></td></tr></table></figure>

<p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = (n ^ (n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-求一个数的补码"><a href="#10-求一个数的补码" class="headerlink" title="10. 求一个数的补码"></a>10. 求一个数的补码</h1><p>476. Number Complement (Easy)</p>
<p><a href="https://leetcode.com/problems/number-complement/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/number-complement/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</span><br></pre></td></tr></table></figure>

<p>题目描述：不考虑二进制表示中的首 0 部分。</p>
<p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span> ((num &amp; mask) == <span class="number">0</span>) mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    mask = (mask &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = Integer.highestOneBit(num);</span><br><span class="line">    mask = (mask &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> num ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">mask |= mask &gt;&gt; 1    11000000</span><br><span class="line">mask |= mask &gt;&gt; 2    11110000</span><br><span class="line">mask |= mask &gt;&gt; 4    11111111</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = num;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (mask ^ num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-实现整数的加法"><a href="#11-实现整数的加法" class="headerlink" title="11. 实现整数的加法"></a>11. 实现整数的加法</h1><p>371. Sum of Two Integers (Easy)</p>
<p><a href="https://leetcode.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-two-integers/description/" target="_blank" rel="noopener">力扣</a></p>
<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-字符串数组最大乘积"><a href="#12-字符串数组最大乘积" class="headerlink" title="12. 字符串数组最大乘积"></a>12. 字符串数组最大乘积</h1><p>318. Maximum Product of Word Lengths (Medium)</p>
<p><a href="https://leetcode.com/problems/maximum-product-of-word-lengths/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given ["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]</span><br><span class="line">Return 16</span><br><span class="line">The two words can be "abcw", "xtfn".</span><br></pre></td></tr></table></figure>

<p>题目描述：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。</p>
<p>本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line">    <span class="keyword">int</span>[] val = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">            val[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((val[i] &amp; val[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                ret = Math.max(ret, words[i].length() * words[j].length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-统计从-0-n-每个数的二进制表示中-1-的个数"><a href="#13-统计从-0-n-每个数的二进制表示中-1-的个数" class="headerlink" title="13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数"></a>13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</h1><p>338. Counting Bits (Medium)</p>
<p><a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/counting-bits/description/" target="_blank" rel="noopener">力扣</a></p>
<p>对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++)&#123;</span><br><span class="line">        ret[i] = ret[i&amp;(i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 图</title>
    <url>/blog/post/83cef5af.html</url>
    <content><![CDATA[<ul>
<li><a href="#二分图">二分图</a><ul>
<li><a href="#1-判断是否为二分图">1. 判断是否为二分图</a></li>
</ul>
</li>
<li><a href="#拓扑排序">拓扑排序</a><ul>
<li><a href="#1-课程安排的合法性">1. 课程安排的合法性</a></li>
<li><a href="#2-课程安排的顺序">2. 课程安排的顺序</a></li>
</ul>
</li>
<li><a href="#并查集">并查集</a><ul>
<li><a href="#1-冗余连接">1. 冗余连接</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p><h2 id="1-判断是否为二分图"><a href="#1-判断是否为二分图" class="headerlink" title="1. 判断是否为二分图"></a>1. 判断是否为二分图</h2><p>785. Is Graph Bipartite? (Medium)</p><a id="more"></a><!-- GFM-TOC -->



<p><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.length; i++) &#123;  <span class="comment">// 处理图不是连通的情况</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !isBipartite(i, <span class="number">0</span>, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span> curNode, <span class="keyword">int</span> curColor, <span class="keyword">int</span>[] colors, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (colors[curNode] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[curNode] == curColor;</span><br><span class="line">    &#125;</span><br><span class="line">    colors[curNode] = curColor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isBipartite(nextNode, <span class="number">1</span> - curColor, colors, graph)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>常用于在具有先序关系的任务规划中。</p>
<h2 id="1-课程安排的合法性"><a href="#1-课程安排的合法性" class="headerlink" title="1. 课程安排的合法性"></a>1. 课程安排的合法性</h2><p>207. Course Schedule (Medium)</p>
<p><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/course-schedule/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2, [[1,0]]</span><br><span class="line">return true</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">2, [[1,0],[0,1]]</span><br><span class="line">return false</span><br></pre></td></tr></table></figure>

<p>题目描述：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p>
<p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt;[] graphic = <span class="keyword">new</span> List[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graphic[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">        graphic[pre[<span class="number">0</span>]].add(pre[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] globalMarked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] localMarked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle(globalMarked, localMarked, graphic, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">boolean</span>[] globalMarked, <span class="keyword">boolean</span>[] localMarked,</span></span></span><br><span class="line"><span class="function"><span class="params">                         List&lt;Integer&gt;[] graphic, <span class="keyword">int</span> curNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localMarked[curNode]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (globalMarked[curNode]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    globalMarked[curNode] = <span class="keyword">true</span>;</span><br><span class="line">    localMarked[curNode] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graphic[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle(globalMarked, localMarked, graphic, nextNode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    localMarked[curNode] = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-课程安排的顺序"><a href="#2-课程安排的顺序" class="headerlink" title="2. 课程安排的顺序"></a>2. 课程安排的顺序</h2><p>210. Course Schedule II (Medium)</p>
<p><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</span><br></pre></td></tr></table></figure>

<p>使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑排序结果。</p>
<p>证明：对于任何先序关系：v-&gt;w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    List&lt;Integer&gt;[] graphic = <span class="keyword">new</span> List[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        graphic[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">        graphic[pre[<span class="number">0</span>]].add(pre[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Integer&gt; postOrder = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] globalMarked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] localMarked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle(globalMarked, localMarked, graphic, i, postOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] orders = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numCourses - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        orders[i] = postOrder.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">boolean</span>[] globalMarked, <span class="keyword">boolean</span>[] localMarked, List&lt;Integer&gt;[] graphic,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> curNode, Stack&lt;Integer&gt; postOrder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localMarked[curNode]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (globalMarked[curNode]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    globalMarked[curNode] = <span class="keyword">true</span>;</span><br><span class="line">    localMarked[curNode] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graphic[curNode]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasCycle(globalMarked, localMarked, graphic, nextNode, postOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    localMarked[curNode] = <span class="keyword">false</span>;</span><br><span class="line">    postOrder.push(curNode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p>
<h2 id="1-冗余连接"><a href="#1-冗余连接" class="headerlink" title="1. 冗余连接"></a>1. 冗余连接</h2><p>684. Redundant Connection (Medium)</p>
<p><a href="https://leetcode.com/problems/redundant-connection/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/redundant-connection/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [[1,2], [1,3], [2,3]]</span><br><span class="line">Output: [2,3]</span><br><span class="line">Explanation: The given undirected graph will be like this:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>

<p>题目描述：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = edges.length;</span><br><span class="line">    UF uf = <span class="keyword">new</span> UF(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (uf.connect(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        uf.union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    UF(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            id[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> uID = find(u);</span><br><span class="line">        <span class="keyword">int</span> vID = find(v);</span><br><span class="line">        <span class="keyword">if</span> (uID == vID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == uID) &#123;</span><br><span class="line">                id[i] = vID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(u) == find(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 数组与矩阵</title>
    <url>/blog/post/49f04032.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-把数组中的-0-移到末尾">1. 把数组中的 0 移到末尾</a></li>
<li><a href="#2-改变矩阵维度">2. 改变矩阵维度</a></li>
<li><a href="#3-找出数组中最长的连续-1">3. 找出数组中最长的连续 1</a></li>
<li><a href="#4-有序矩阵查找">4. 有序矩阵查找</a></li>
<li><a href="#5-有序矩阵的-kth-element">5. 有序矩阵的 Kth Element</a></li>
<li><a href="#6-一个数组元素在-[1,-n]-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数">6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</a></li>
<li><a href="#7-找出数组中重复的数，数组值在-[1,-n]-之间">7. 找出数组中重复的数，数组值在 [1, n] 之间</a></li>
<li><a href="#8-数组相邻差值的个数">8. 数组相邻差值的个数</a></li>
<li><a href="#9-数组的度">9. 数组的度</a></li>
<li><a href="#10-对角元素相等的矩阵">10. 对角元素相等的矩阵</a></li>
<li><a href="#11-嵌套数组">11. 嵌套数组</a></li>
<li><a href="#12-分隔数组">12. 分隔数组</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="1-把数组中的-0-移到末尾"><a href="#1-把数组中的-0-移到末尾" class="headerlink" title="1. 把数组中的 0 移到末尾"></a>1. 把数组中的 0 移到末尾</h1><p>283. Move Zeroes (Easy)</p>
<p><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/move-zeroes/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (idx &lt; nums.length) &#123;</span><br><span class="line">        nums[idx++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-改变矩阵维度"><a href="#2-改变矩阵维度" class="headerlink" title="2. 改变矩阵维度"></a>2. 改变矩阵维度</h1><p>566. Reshape the Matrix (Easy)</p>
<p><a href="https://leetcode.com/problems/reshape-the-matrix/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reshape-the-matrix/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums =</span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[1,2,3,4]]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] nums, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">    <span class="keyword">int</span> m = nums.length, n = nums[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m * n != r * c) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] reshapedNums = <span class="keyword">new</span> <span class="keyword">int</span>[r][c];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span><br><span class="line">            reshapedNums[i][j] = nums[index / n][index % n];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reshapedNums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-找出数组中最长的连续-1"><a href="#3-找出数组中最长的连续-1" class="headerlink" title="3. 找出数组中最长的连续 1"></a>3. 找出数组中最长的连续 1</h1><p>485. Max Consecutive Ones (Easy)</p>
<p><a href="https://leetcode.com/problems/max-consecutive-ones/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/max-consecutive-ones/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x : nums) &#123;</span><br><span class="line">        cur = x == <span class="number">0</span> ? <span class="number">0</span> : cur + <span class="number">1</span>;</span><br><span class="line">        max = Math.max(max, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-有序矩阵查找"><a href="#4-有序矩阵查找" class="headerlink" title="4. 有序矩阵查找"></a>4. 有序矩阵查找</h1><p>240. Search a 2D Matrix II (Medium)</p>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; m &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == matrix[row][col]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; matrix[row][col]) col--;</span><br><span class="line">        <span class="keyword">else</span> row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-有序矩阵的-Kth-Element"><a href="#5-有序矩阵的-Kth-Element" class="headerlink" title="5. 有序矩阵的 Kth Element"></a>5. 有序矩阵的 Kth Element</h1><p>378. Kth Smallest Element in a Sorted Matrix ((Medium))</p>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">  [ 1,  5,  9],</span><br><span class="line">  [10, 11, 13],</span><br><span class="line">  [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">return 13.</span><br></pre></td></tr></table></figure>

<p>��题参考：[Share my thoughts and Clean Java Code</p>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173" target="_blank" rel="noopener">力扣</a></p>
<p>二分查找解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; k) lo = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>堆解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    PriorityQueue&lt;Tuple&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;Tuple&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) pq.offer(<span class="keyword">new</span> Tuple(<span class="number">0</span>, j, matrix[<span class="number">0</span>][j]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123; <span class="comment">// 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数</span></span><br><span class="line">        Tuple t = pq.poll();</span><br><span class="line">        <span class="keyword">if</span>(t.x == m - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        pq.offer(<span class="keyword">new</span> Tuple(t.x + <span class="number">1</span>, t.y, matrix[t.x + <span class="number">1</span>][t.y]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.poll().val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuple</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Tuple</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tuple</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x; <span class="keyword">this</span>.y = y; <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Tuple that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val - that.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"><a href="#6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数" class="headerlink" title="6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"></a>6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h1><p>645. Set Mismatch (Easy)</p>
<p><a href="https://leetcode.com/problems/set-mismatch/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/set-mismatch/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,2,4]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: nums = [1,2,2,4]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure>

<p>最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。</p>
<p>主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i + <span class="number">1</span> &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i]) &#123;</span><br><span class="line">            swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似题目：</p>
<p> [448. Find All Numbers Disappeared in an Array (Easy)</p>
<p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/description/" target="_blank" rel="noopener">Leetcode</a>，寻找所有丢失的元�) / <a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/description/" target="_blank" rel="noopener">力扣</a>，寻找所有丢失的元�)<br> [442. Find All Duplicates in an Array (Medium)</p>
<p><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/description/" target="_blank" rel="noopener">Leetcode</a>，寻找所有重复的元素�) / <a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/description/" target="_blank" rel="noopener">力扣</a>，寻找所有重复的元素�)</p>
<h1 id="7-找出数组中重复的数，数组值在-1-n-之间"><a href="#7-找出数组中重复的数，数组值在-1-n-之间" class="headerlink" title="7. 找出数组中重复的数，数组值在 [1, n] 之间"></a>7. 找出数组中重复的数，数组值在 [1, n] 之间</h1><p>287. Find the Duplicate Number (Medium)</p>
<p><a href="https://leetcode.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/description/" target="_blank" rel="noopener">力扣</a></p>
<p>要求不能修改数组，也不能使用额外的空间。</p>
<p>二分查找解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> l = <span class="number">1</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (nums[i] &lt;= mid) cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (cnt &gt; mid) h = mid - <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针解法，类似于有环链表中找出环的入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-数组相邻差值的个数"><a href="#8-数组相邻差值的个数" class="headerlink" title="8. 数组相邻差值的个数"></a>8. 数组相邻差值的个数</h1><p>667. Beautiful Arrangement II (Medium)</p>
<p><a href="https://leetcode.com/problems/beautiful-arrangement-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: n = 3, k = 2</span><br><span class="line">Output: [1, 3, 2]</span><br><span class="line">Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.</span><br></pre></td></tr></table></figure>

<p>题目描述：数组元素为 1~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。</p>
<p>让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 ... k/2 k/2+1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    ret[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, interval = k; i &lt;= k; i++, interval--) &#123;</span><br><span class="line">        ret[i] = i % <span class="number">2</span> == <span class="number">1</span> ? ret[i - <span class="number">1</span>] + interval : ret[i - <span class="number">1</span>] - interval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ret[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-数组的度"><a href="#9-数组的度" class="headerlink" title="9. 数组的度"></a>9. 数组的度</h1><p>697. Degree of an Array (Easy)</p>
<p><a href="https://leetcode.com/problems/degree-of-an-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/degree-of-an-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1,2,2,3,1,4,2]</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure>

<p>题目描述：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numsCnt = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; numsLastIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; numsFirstIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        numsCnt.put(num, numsCnt.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        numsLastIndex.put(num, i);</span><br><span class="line">        <span class="keyword">if</span> (!numsFirstIndex.containsKey(num)) &#123;</span><br><span class="line">            numsFirstIndex.put(num, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        maxCnt = Math.max(maxCnt, numsCnt.get(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i];</span><br><span class="line">        <span class="keyword">int</span> cnt = numsCnt.get(num);</span><br><span class="line">        <span class="keyword">if</span> (cnt != maxCnt) <span class="keyword">continue</span>;</span><br><span class="line">        ret = Math.min(ret, numsLastIndex.get(num) - numsFirstIndex.get(num) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-对角元素相等的矩阵"><a href="#10-对角元素相等的矩阵" class="headerlink" title="10. 对角元素相等的矩阵"></a>10. 对角元素相等的矩阵</h1><p>766. Toeplitz Matrix (Easy)</p>
<p><a href="https://leetcode.com/problems/toeplitz-matrix/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/toeplitz-matrix/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1234</span><br><span class="line">5123</span><br><span class="line">9512</span><br><span class="line"></span><br><span class="line">In the above grid, the diagonals are "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]", and in each diagonal all elements are the same, so the answer is True.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check(matrix, matrix[<span class="number">0</span>][i], <span class="number">0</span>, i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!check(matrix, matrix[i][<span class="number">0</span>], i, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> expectValue, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row &gt;= matrix.length || col &gt;= matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (matrix[row][col] != expectValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(matrix, expectValue, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-嵌套数组"><a href="#11-嵌套数组" class="headerlink" title="11. 嵌套数组"></a>11. 嵌套数组</h1><p>565. Array Nesting (Medium)</p>
<p><a href="https://leetcode.com/problems/array-nesting/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/array-nesting/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: A = [5,4,0,3,1,6,2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</span><br><span class="line"></span><br><span class="line">One of the longest S[K]:</span><br><span class="line">S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure>

<p>题目描述：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; nums[j] != -<span class="number">1</span>; ) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> t = nums[j];</span><br><span class="line">            nums[j] = -<span class="number">1</span>; <span class="comment">// 标记该位置已经被访问</span></span><br><span class="line">            j = t;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-分隔数组"><a href="#12-分隔数组" class="headerlink" title="12. 分隔数组"></a>12. 分隔数组</h1><p>769. Max Chunks To Make Sorted (Medium)</p>
<p><a href="https://leetcode.com/problems/max-chunks-to-make-sorted/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: arr = [1,0,2,3,4]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">We can split into two chunks, such as [1, 0], [2, 3, 4].</span><br><span class="line">However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</span><br></pre></td></tr></table></figure>

<p>题目描述：分隔数组，使得对每部分排序后数组就为有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        right = Math.max(right, arr[i]);</span><br><span class="line">        <span class="keyword">if</span> (right == i) ret++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数组与矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 字符串</title>
    <url>/blog/post/c43456f4.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-字符串循环移位包含">1. 字符串循环移位包含</a></li>
<li><a href="#2-字符串循环移位">2. 字符串循环移位</a></li>
<li><a href="#3-字符串中单词的翻转">3. 字符串中单词的翻转</a></li>
<li><a href="#4-两个字符串包含的字符是否完全相同">4. 两个字符串包含的字符是否完全相同</a></li>
<li><a href="#5-计算一组字符集合可以组成的回文字符串的最大长度">5. 计算一组字符集合可以组成的回文字符串的最大长度</a></li>
<li><a href="#6-字符串同构">6. 字符串同构</a></li>
<li><a href="#7-回文子字符串个数">7. 回文子字符串个数</a></li>
<li><a href="#8-判断一个整数是否是回文数">8. 判断一个整数是否是回文数</a></li>
<li><a href="#9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数">9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</a><!-- GFM-TOC -->


</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="1-字符串循环移位包含"><a href="#1-字符串循环移位包含" class="headerlink" title="1. 字符串循环移位包含"></a>1. 字符串循环移位包含</h1><p><a href="#">编程之美 3.1</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s1 = AABCD, s2 = CDAA</span><br><span class="line">Return : true</span><br></pre></td></tr></table></figure>

<p>给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。</p>
<p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。</p>
<h1 id="2-字符串循环移位"><a href="#2-字符串循环移位" class="headerlink" title="2. 字符串循环移位"></a>2. 字符串循环移位</h1><p><a href="#">编程之美 2.17</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s = "abcd123" k = 3</span><br><span class="line">Return "123abcd"</span><br></pre></td></tr></table></figure>

<p>将字符串向右循环移动 k 位。</p>
<p>将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。</p>
<h1 id="3-字符串中单词的翻转"><a href="#3-字符串中单词的翻转" class="headerlink" title="3. 字符串中单词的翻转"></a>3. 字符串中单词的翻转</h1><p><a href="#">程序员代码面试指南</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s = "I am a student"</span><br><span class="line">Return "student a am I"</span><br></pre></td></tr></table></figure>

<p>将每个单词翻转，然后将整个字符串翻转。</p>
<h1 id="4-两个字符串包含的字符是否完全相同"><a href="#4-两个字符串包含的字符是否完全相同" class="headerlink" title="4. 两个字符串包含的字符是否完全相同"></a>4. 两个字符串包含的字符是否完全相同</h1><p>242. Valid Anagram (Easy)</p>
<p><a href="https://leetcode.com/problems/valid-anagram/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-anagram/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s = "anagram", t = "nagaram", return true.</span><br><span class="line">s = "rat", t = "car", return false.</span><br></pre></td></tr></table></figure>

<p>可以用 HashMap 来映射字符与出现次数，然后比较两个字符串出现的字符数量是否相同。</p>
<p>由于本题的字符串只包含 26 个小写字符，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，不再使用 HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        cnts[c - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt : cnts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-计算一组字符集合可以组成的回文字符串的最大长度"><a href="#5-计算一组字符集合可以组成的回文字符串的最大长度" class="headerlink" title="5. 计算一组字符集合可以组成的回文字符串的最大长度"></a>5. 计算一组字符集合可以组成的回文字符串的最大长度</h1><p>409. Longest Palindrome (Easy)</p>
<p><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input : "abccccdd"</span><br><span class="line">Output : 7</span><br><span class="line">Explanation : One longest palindrome that can be built is "dccaccd", whose length is 7.</span><br></pre></td></tr></table></figure>

<p>使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。</p>
<p>因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] cnts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        cnts[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> palindrome = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt : cnts) &#123;</span><br><span class="line">        palindrome += (cnt / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (palindrome &lt; s.length()) &#123;</span><br><span class="line">        palindrome++;   <span class="comment">// 这个条件下 s 中一定有单个未使用的字符存在，可以把这个字符放到回文的最中间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> palindrome;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-字符串同构"><a href="#6-字符串同构" class="headerlink" title="6. 字符串同构"></a>6. 字符串同构</h1><p>205. Isomorphic Strings (Easy)</p>
<p><a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given "egg", "add", return true.</span><br><span class="line">Given "foo", "bar", return false.</span><br><span class="line">Given "paper", "title", return true.</span><br></pre></td></tr></table></figure>

<p>记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preIndexOfS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span>[] preIndexOfT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> sc = s.charAt(i), tc = t.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (preIndexOfS[sc] != preIndexOfT[tc]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preIndexOfS[sc] = i + <span class="number">1</span>;</span><br><span class="line">        preIndexOfT[tc] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-回文子字符串个数"><a href="#7-回文子字符串个数" class="headerlink" title="7. 回文子字符串个数"></a>7. 回文子字符串个数</h1><p>647. Palindromic Substrings (Medium)</p>
<p><a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "aaa"</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".</span><br></pre></td></tr></table></figure>

<p>从字符串的某一位开始，尝试着去扩展子字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        extendSubstrings(s, i, i);     <span class="comment">// 奇数长度</span></span><br><span class="line">        extendSubstrings(s, i, i + <span class="number">1</span>); <span class="comment">// 偶数长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendSubstrings</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">        start--;</span><br><span class="line">        end++;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-判断一个整数是否是回文数"><a href="#8-判断一个整数是否是回文数" class="headerlink" title="8. 判断一个整数是否是回文数"></a>8. 判断一个整数是否是回文数</h1><p>9. Palindrome Number (Easy)</p>
<p><a href="https://leetcode.com/problems/palindrome-number/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/palindrome-number/description/" target="_blank" rel="noopener">力扣</a></p>
<p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断。</p>
<p>将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; right) &#123;</span><br><span class="line">        right = right * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x == right || x == right / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><a href="#9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数" class="headerlink" title="9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数"></a>9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h1><p>696. Count Binary Substrings (Easy)</p>
<p><a href="https://leetcode.com/problems/count-binary-substrings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/count-binary-substrings/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "00110011"</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> preLen = <span class="number">0</span>, curLen = <span class="number">1</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(i - <span class="number">1</span>)) &#123;</span><br><span class="line">            curLen++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            preLen = curLen;</span><br><span class="line">            curLen = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLen &gt;= curLen) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 哈希表</title>
    <url>/blog/post/bdba8d89.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-数组中两个数的和为给定值">1. 数组中两个数的和为给定值</a></li>
<li><a href="#2-判断数组是否含有重复元素">2. 判断数组是否含有重复元素</a></li>
<li><a href="#3-最长和谐序列">3. 最长和谐序列</a></li>
<li><a href="#4-最长连续序列">4. 最长连续序列</a><!-- GFM-TOC -->


</li>
</ul><p>哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。</p><ul>
<li><p>Java 中的  <strong>HashSet</strong>  用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。</p>
<p>Java 中的  <strong>HashMap</strong>  主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 [Leetcdoe : 535. Encode and Decode TinyURL (Medium)</p>
</li>
</ul><a id="more"></a><!-- GFM-TOC -->



<p><a href="https://leetcode.com/problems/encode-and-decode-tinyurl/description/" target="_blank" rel="noopener">Leetcode</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�) / <a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/description/" target="_blank" rel="noopener">力扣</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�)</p>
<h1 id="1-数组中两个数的和为给定值"><a href="#1-数组中两个数的和为给定值" class="headerlink" title="1. 数组中两个数的和为给定值"></a>1. 数组中两个数的和为给定值</h1><p>1. Two Sum (Easy)</p>
<p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。</p>
<p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; indexForNum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indexForNum.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;indexForNum.get(target - nums[i]), i&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            indexForNum.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-判断数组是否含有重复元素"><a href="#2-判断数组是否含有重复元素" class="headerlink" title="2. 判断数组是否含有重复元素"></a>2. 判断数组是否含有重复元素</h1><p>217. Contains Duplicate (Easy)</p>
<p><a href="https://leetcode.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size() &lt; nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-最长和谐序列"><a href="#3-最长和谐序列" class="headerlink" title="3. 最长和谐序列"></a>3. 最长和谐序列</h1><p>594. Longest Harmonious Subsequence (Easy)</p>
<p><a href="https://leetcode.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1,3,2,2,5,2,3,7]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest harmonious subsequence is [3,2,2,2,3].</span><br></pre></td></tr></table></figure>

<p>和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; countForNum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        countForNum.put(num, countForNum.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : countForNum.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countForNum.containsKey(num + <span class="number">1</span>)) &#123;</span><br><span class="line">            longest = Math.max(longest, countForNum.get(num + <span class="number">1</span>) + countForNum.get(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-最长连续序列"><a href="#4-最长连续序列" class="headerlink" title="4. 最长连续序列"></a>4. 最长连续序列</h1><p>128. Longest Consecutive Sequence (Hard)</p>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given [100, 4, 200, 1, 3, 2],</span><br><span class="line">The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</span><br></pre></td></tr></table></figure>

<p>要求以 O(N) 的时间复杂度求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; countForNum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        countForNum.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        forward(countForNum, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount(countForNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">forward</span><span class="params">(Map&lt;Integer, Integer&gt; countForNum, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!countForNum.containsKey(num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = countForNum.get(num);</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = forward(countForNum, num + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    countForNum.put(num, cnt);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxCount</span><span class="params">(Map&lt;Integer, Integer&gt; countForNum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : countForNum.keySet()) &#123;</span><br><span class="line">        max = Math.max(max, countForNum.get(num));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 栈和队列</title>
    <url>/blog/post/22150be2.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-用栈实现队列">1. 用栈实现队列</a></li>
<li><a href="#2-用队列实现栈">2. 用队列实现栈</a></li>
<li><a href="#3-最小值栈">3. 最小值栈</a></li>
<li><a href="#4-用栈实现括号匹配">4. 用栈实现括号匹配</a></li>
<li><a href="#5-数组中元素与下一个比它大的元素之间的距离">5. 数组中元素与下一个比它大的元素之间的距离</a></li>
<li><a href="#6-循环数组中比当前元素大的下一个元素">6. 循环数组中比当前元素大的下一个元素</a><!-- GFM-TOC -->


</li>
</ul><h1 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h1><p>232. Implement Queue using Stacks (Easy)</p><p><a href="https://leetcode.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">力扣</a></p><a id="more"></a><!-- GFM-TOC -->



<p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; in = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; out = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">in2out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (out.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!in.isEmpty()) &#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h1><p>225. Implement Stack using Queues (Easy)</p>
<p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">力扣</a></p>
<p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-最小值栈"><a href="#3-最小值栈" class="headerlink" title="3. 最小值栈"></a>3. 最小值栈</h1><p>155. Min Stack (Easy)</p>
<p><a href="https://leetcode.com/problems/min-stack/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/min-stack/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.add(x);</span><br><span class="line">        min = Math.min(min, x);</span><br><span class="line">        minStack.add(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。</p>
<h1 id="4-用栈实现括号匹配"><a href="#4-用栈实现括号匹配" class="headerlink" title="4. 用栈实现括号匹配"></a>4. 用栈实现括号匹配</h1><p>20. Valid Parentheses (Easy)</p>
<p><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">"()[]&#123;&#125;"</span><br><span class="line"></span><br><span class="line">Output : true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'&#123;'</span> || c == <span class="string">'['</span>) &#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> cStack = stack.pop();</span><br><span class="line">            <span class="keyword">boolean</span> b1 = c == <span class="string">')'</span> &amp;&amp; cStack != <span class="string">'('</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b2 = c == <span class="string">']'</span> &amp;&amp; cStack != <span class="string">'['</span>;</span><br><span class="line">            <span class="keyword">boolean</span> b3 = c == <span class="string">'&#125;'</span> &amp;&amp; cStack != <span class="string">'&#123;'</span>;</span><br><span class="line">            <span class="keyword">if</span> (b1 || b2 || b3) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-数组中元素与下一个比它大的元素之间的距离"><a href="#5-数组中元素与下一个比它大的元素之间的距离" class="headerlink" title="5. 数组中元素与下一个比它大的元素之间的距离"></a>5. 数组中元素与下一个比它大的元素之间的距离</h1><p>739. Daily Temperatures (Medium)</p>
<p><a href="https://leetcode.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/daily-temperatures/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [73, 74, 75, 71, 69, 72, 76, 73]</span><br><span class="line">Output: [1, 1, 4, 2, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure>

<p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = temperatures.length;</span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Stack&lt;Integer&gt; indexs = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curIndex = <span class="number">0</span>; curIndex &lt; n; curIndex++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!indexs.isEmpty() &amp;&amp; temperatures[curIndex] &gt; temperatures[indexs.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> preIndex = indexs.pop();</span><br><span class="line">            dist[preIndex] = curIndex - preIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        indexs.add(curIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-循环数组中比当前元素大的下一个元素"><a href="#6-循环数组中比当前元素大的下一个元素" class="headerlink" title="6. 循环数组中比当前元素大的下一个元素"></a>6. 循环数组中比当前元素大的下一个元素</h1><p>503. Next Greater Element II (Medium)</p>
<p><a href="https://leetcode.com/problems/next-greater-element-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/next-greater-element-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: [2,-1,2]</span><br><span class="line">Explanation: The first 1&apos;s next greater number is 2;</span><br><span class="line">The number 2 can&apos;t find next greater number;</span><br><span class="line">The second 1&apos;s next greater number needs to search circularly, which is also 2.</span><br></pre></td></tr></table></figure>

<p>与 739. Daily Temperatures (Medium) 不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(next, -<span class="number">1</span>);</span><br><span class="line">    Stack&lt;Integer&gt; pre = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[i % n];</span><br><span class="line">        <span class="keyword">while</span> (!pre.isEmpty() &amp;&amp; nums[pre.peek()] &lt; num) &#123;</span><br><span class="line">            next[pre.pop()] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n)&#123;</span><br><span class="line">            pre.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 树</title>
    <url>/blog/post/16eb9997.html</url>
    <content><![CDATA[<ul>
<li><a href="#递归">递归</a><ul>
<li><a href="#1-树的高度">1. 树的高度</a></li>
<li><a href="#2-平衡树">2. 平衡树</a></li>
<li><a href="#3-两节点的最长路径">3. 两节点的最长路径</a></li>
<li><a href="#4-翻转树">4. 翻转树</a></li>
<li><a href="#5-归并两棵树">5. 归并两棵树</a></li>
<li><a href="#6-判断路径和是否等于一个数">6. 判断路径和是否等于一个数</a></li>
<li><a href="#7-统计路径和等于一个数的路径数量">7. 统计路径和等于一个数的路径数量</a></li>
<li><a href="#8-子树">8. 子树</a></li>
<li><a href="#9-树的对称">9. 树的对称</a></li>
<li><a href="#10-最小路径">10. 最小路径</a></li>
<li><a href="#11-统计左叶子节点的和">11. 统计左叶子节点的和</a></li>
<li><a href="#12-相同节点值的最大路径长度">12. 相同节点值的最大路径长度</a></li>
<li><a href="#13-间隔遍历">13. 间隔遍历</a></li>
<li><a href="#14-找出二叉树中第二小的节点">14. 找出二叉树中第二小的节点</a></li>
</ul>
</li>
<li><a href="#层次遍历">层次遍历</a><ul>
<li><a href="#1-一棵树每层节点的平均数">1. 一棵树每层节点的平均数</a></li>
<li><a href="#2-得到左下角的节点">2. 得到左下角的节点</a></li>
</ul>
</li>
<li><a href="#前中后序遍历">前中后序遍历</a><ul>
<li><a href="#1-非递归实现二叉树的前序遍历">1. 非递归实现二叉树的前序遍历</a></li>
<li><a href="#2-非递归实现二叉树的后序遍历">2. 非递归实现二叉树的后序遍历</a></li>
<li><a href="#3-非递归实现二叉树的中序遍历">3. 非递归实现二叉树的中序遍历</a></li>
</ul>
</li>
<li><a href="#bst">BST</a><ul>
<li><a href="#1-修剪二叉查找树">1. 修剪二叉查找树</a></li>
<li><a href="#2-寻找二叉查找树的第-k-个元素">2. 寻找二叉查找树的第 k 个元素</a></li>
<li><a href="#3-把二叉查找树每个节点的值都加上比它大的节点的值">3. 把二叉查找树每个节点的值都加上比它大的节点的值</a></li>
<li><a href="#4-二叉查找树的最近公共祖先">4. 二叉查找树的最近公共祖先</a></li>
<li><a href="#5-二叉树的最近公共祖先">5. 二叉树的最近公共祖先</a></li>
<li><a href="#6-从有序数组中构造二叉查找树">6. 从有序数组中构造二叉查找树</a></li>
<li><a href="#7-根据有序链表构造平衡的二叉查找树">7. 根据有序链表构造平衡的二叉查找树</a></li>
<li><a href="#8-在二叉查找树中寻找两个节点，使它们的和为一个给定值">8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</a></li>
<li><a href="#9-在二叉查找树中查找两个节点之差的最小绝对值">9. 在二叉查找树中查找两个节点之差的最小绝对值</a></li>
<li><a href="#10-寻找二叉查找树中出现次数最多的值">10. 寻找二叉查找树中出现次数最多的值</a></li>
</ul>
</li>
<li><a href="#trie">Trie</a><ul>
<li><a href="#1-实现一个-trie">1. 实现一个 Trie</a></li>
<li><a href="#2-实现一个-trie，用来求前缀和">2. 实现一个 Trie，用来求前缀和</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。</p>
<h2 id="1-树的高度"><a href="#1-树的高度" class="headerlink" title="1. 树的高度"></a>1. 树的高度</h2><p>104. Maximum Depth of Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-平衡树"><a href="#2-平衡树" class="headerlink" title="2. 平衡树"></a>2. 平衡树</h2><p>110. Balanced Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>平衡树左右子树高度差都小于等于 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    maxDepth(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> r = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(l - r) &gt; <span class="number">1</span>) result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-两节点的最长路径"><a href="#3-两节点的最长路径" class="headerlink" title="3. 两节点的最长路径"></a>3. 两节点的最长路径</h2><p>543. Diameter of Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">         1</span><br><span class="line">        / \</span><br><span class="line">       2  3</span><br><span class="line">      / \</span><br><span class="line">     4   5</span><br><span class="line"></span><br><span class="line">Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    depth(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftDepth = depth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = depth(root.right);</span><br><span class="line">    max = Math.max(max, leftDepth + rightDepth);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-翻转树"><a href="#4-翻转树" class="headerlink" title="4. 翻转树"></a>4. 翻转树</h2><p>226. Invert Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    TreeNode left = root.left;  <span class="comment">// 后面的操作会改变 left 指针，因此先保存下来</span></span><br><span class="line">    root.left = invertTree(root.right);</span><br><span class="line">    root.right = invertTree(left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-归并两棵树"><a href="#5-归并两棵树" class="headerlink" title="5. 归并两棵树"></a>5. 归并两棵树</h2><p>617. Merge Two Binary Trees (Easy)</p>
<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">       Tree 1                     Tree 2</span><br><span class="line">          1                         2</span><br><span class="line">         / \                       / \</span><br><span class="line">        3   2                     1   3</span><br><span class="line">       /                           \   \</span><br><span class="line">      5                             4   7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">         3</span><br><span class="line">        / \</span><br><span class="line">       4   5</span><br><span class="line">      / \   \</span><br><span class="line">     5   4   7</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span> (t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">    root.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">    root.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-判断路径和是否等于一个数"><a href="#6-判断路径和是否等于一个数" class="headerlink" title="6. 判断路径和是否等于一个数"></a>6. 判断路径和是否等于一个数</h2><p>Leetcdoe : 112. Path Sum (Easy)</p>
<p><a href="https://leetcode.com/problems/path-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/path-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">             / \</span><br><span class="line">            4   8</span><br><span class="line">           /   / \</span><br><span class="line">          11  13  4</span><br><span class="line">         /  \      \</span><br><span class="line">        7    2      1</span><br><span class="line"></span><br><span class="line">return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</span><br></pre></td></tr></table></figure>

<p>路径和定义为从 root 到 leaf 的所有节点的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-统计路径和等于一个数的路径数量"><a href="#7-统计路径和等于一个数的路径数量" class="headerlink" title="7. 统计路径和等于一个数的路径数量"></a>7. 统计路径和等于一个数的路径数量</h2><p>437. Path Sum III (Easy)</p>
<p><a href="https://leetcode.com/problems/path-sum-iii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/path-sum-iii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure>

<p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pathSumStartWithRoot</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val == sum) ret++;</span><br><span class="line">    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-子树"><a href="#8-子树" class="headerlink" title="8. 子树"></a>8. 子树</h2><p>572. Subtree of Another Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/subtree-of-another-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given tree s:</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">Given tree t:</span><br><span class="line">   4</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">Return true, because t has the same structure and node values with a subtree of s.</span><br><span class="line"></span><br><span class="line">Given tree s:</span><br><span class="line"></span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line">    /</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line">Given tree t:</span><br><span class="line">   4</span><br><span class="line">  / \</span><br><span class="line"> 1   2</span><br><span class="line"></span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubtreeWithRoot</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span> &amp;&amp; s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.val != s.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtreeWithRoot(s.left, t.left) &amp;&amp; isSubtreeWithRoot(s.right, t.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-树的对称"><a href="#9-树的对称" class="headerlink" title="9. 树的对称"></a>9. 树的对称</h2><p>101. Symmetric Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(root.left, root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetric(t1.left, t2.right) &amp;&amp; isSymmetric(t1.right, t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-最小路径"><a href="#10-最小路径" class="headerlink" title="10. 最小路径"></a>10. 最小路径</h2><p>111. Minimum Depth of Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<p>树的根节点到叶子节点的最小路径长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = minDepth(root.right);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-统计左叶子节点的和"><a href="#11-统计左叶子节点的和" class="headerlink" title="11. 统计左叶子节点的和"></a>11. 统计左叶子节点的和</h2><p>404. Sum of Left Leaves (Easy)</p>
<p><a href="https://leetcode.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"></span><br><span class="line">There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(root.left)) <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class="line">    <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-相同节点值的最大路径长度"><a href="#12-相同节点值的最大路径长度" class="headerlink" title="12. 相同节点值的最大路径长度"></a>12. 相同节点值的最大路径长度</h2><p>687. Longest Univalue Path (Easy)</p>
<p><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-univalue-path/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">             1</span><br><span class="line">            / \</span><br><span class="line">           4   5</span><br><span class="line">          / \   \</span><br><span class="line">         4   4   5</span><br><span class="line"></span><br><span class="line">Output : 2</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">    <span class="keyword">int</span> leftPath = root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val ? left + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightPath = root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val ? right + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    path = Math.max(path, leftPath + rightPath);</span><br><span class="line">    <span class="keyword">return</span> Math.max(leftPath, rightPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-间隔遍历"><a href="#13-间隔遍历" class="headerlink" title="13. 间隔遍历"></a>13. 间隔遍历</h2><p>337. House Robber III (Medium)</p>
<p><a href="https://leetcode.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/house-robber-iii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \</span><br><span class="line">     3   1</span><br><span class="line">Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> val1 = root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) val1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) val1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">    <span class="keyword">int</span> val2 = rob(root.left) + rob(root.right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(val1, val2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-找出二叉树中第二小的节点"><a href="#14-找出二叉树中第二小的节点" class="headerlink" title="14. 找出二叉树中第二小的节点"></a>14. 找出二叉树中第二小的节点</h2><p>671. Second Minimum Node In a Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">   2</span><br><span class="line">  / \</span><br><span class="line"> 2   5</span><br><span class="line">    / \</span><br><span class="line">    5  7</span><br><span class="line"></span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftVal = root.left.val;</span><br><span class="line">    <span class="keyword">int</span> rightVal = root.right.val;</span><br><span class="line">    <span class="keyword">if</span> (leftVal == root.val) leftVal = findSecondMinimumValue(root.left);</span><br><span class="line">    <span class="keyword">if</span> (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);</span><br><span class="line">    <span class="keyword">if</span> (leftVal != -<span class="number">1</span> &amp;&amp; rightVal != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(leftVal, rightVal);</span><br><span class="line">    <span class="keyword">if</span> (leftVal != -<span class="number">1</span>) <span class="keyword">return</span> leftVal;</span><br><span class="line">    <span class="keyword">return</span> rightVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>使用 BFS 进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>
<h2 id="1-一棵树每层节点的平均数"><a href="#1-一棵树每层节点的平均数" class="headerlink" title="1. 一棵树每层节点的平均数"></a>1. 一棵树每层节点的平均数</h2><p>637. Average of Levels in Binary Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Double&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = queue.size();</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            sum += node.val;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        ret.add(sum / cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-得到左下角的节点"><a href="#2-得到左下角的节点" class="headerlink" title="2. 得到左下角的节点"></a>2. 得到左下角的节点</h2><p>513. Find Bottom Left Tree Value (Easy)</p>
<p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">        1</span><br><span class="line">       / \</span><br><span class="line">      2   3</span><br><span class="line">     /   / \</span><br><span class="line">    4   5   6</span><br><span class="line">       /</span><br><span class="line">      7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        root = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) queue.add(root.right);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) queue.add(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \   \</span><br><span class="line">4   5   6</span><br></pre></td></tr></table></figure>

<ul>
<li>层次遍历顺序：[1 2 3 4 5 6]</li>
<li>前序遍历顺序：[1 2 4 5 3 6]</li>
<li>中序遍历顺序：[4 2 5 1 3 6]</li>
<li>后序遍历顺序：[4 5 2 6 3 1]</li>
</ul>
<p>层次遍历使用 BFS 实现，利用的就是 BFS 一层一层遍历的特性；而前序、中序、后序遍历利用了 DFS 实现。</p>
<p>前序、中序、后序遍只是在对节点访问的顺序有一点不同，其它都相同。</p>
<p>① 前序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    visit(root);</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 中序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    visit(root);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 后序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">    visit(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-非递归实现二叉树的前序遍历"><a href="#1-非递归实现二叉树的前序遍历" class="headerlink" title="1. 非递归实现二叉树的前序遍历"></a>1. 非递归实现二叉树的前序遍历</h2><p>144. Binary Tree Preorder Traversal (Medium)</p>
<p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        stack.push(node.right);  <span class="comment">// 先右后左，保证左子树先遍历</span></span><br><span class="line">        stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-非递归实现二叉树的后序遍历"><a href="#2-非递归实现二叉树的后序遍历" class="headerlink" title="2. 非递归实现二叉树的后序遍历"></a>2. 非递归实现二叉树的后序遍历</h2><p>145. Binary Tree Postorder Traversal (Medium)</p>
<p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">力扣</a></p>
<p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        stack.push(node.left);</span><br><span class="line">        stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-非递归实现二叉树的中序遍历"><a href="#3-非递归实现二叉树的中序遍历" class="headerlink" title="3. 非递归实现二叉树的中序遍历"></a>3. 非递归实现二叉树的中序遍历</h2><p>94. Binary Tree Inorder Traversal (Medium)</p>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        ret.add(node.val);</span><br><span class="line">        cur = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>
<p>二叉查找树中序遍历有序。</p>
<h2 id="1-修剪二叉查找树"><a href="#1-修剪二叉查找树" class="headerlink" title="1. 修剪二叉查找树"></a>1. 修剪二叉查找树</h2><p>669. Trim a Binary Search Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  0   4</span><br><span class="line">   \</span><br><span class="line">    2</span><br><span class="line">   /</span><br><span class="line">  1</span><br><span class="line"></span><br><span class="line">  L = 1</span><br><span class="line">  R = 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">      3</span><br><span class="line">     /</span><br><span class="line">   2</span><br><span class="line">  /</span><br><span class="line"> 1</span><br></pre></td></tr></table></figure>

<p>题目描述：只保留值在 L ~ R 之间的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">trimBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; R) <span class="keyword">return</span> trimBST(root.left, L, R);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; L) <span class="keyword">return</span> trimBST(root.right, L, R);</span><br><span class="line">    root.left = trimBST(root.left, L, R);</span><br><span class="line">    root.right = trimBST(root.right, L, R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-寻找二叉查找树的第-k-个元素"><a href="#2-寻找二叉查找树的第-k-个元素" class="headerlink" title="2. 寻找二叉查找树的第 k 个元素"></a>2. 寻找二叉查找树的第 k 个元素</h2><p>230. Kth Smallest Element in a BST (Medium)</p>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">力扣</a></p>
<p>中序遍历解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    inOrder(root, k);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left, k);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">        val = node.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(node.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftCnt = count(root.left);</span><br><span class="line">    <span class="keyword">if</span> (leftCnt == k - <span class="number">1</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">    <span class="keyword">if</span> (leftCnt &gt; k - <span class="number">1</span>) <span class="keyword">return</span> kthSmallest(root.left, k);</span><br><span class="line">    <span class="keyword">return</span> kthSmallest(root.right, k - leftCnt - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + count(node.left) + count(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-把二叉查找树每个节点的值都加上比它大的节点的值"><a href="#3-把二叉查找树每个节点的值都加上比它大的节点的值" class="headerlink" title="3. 把二叉查找树每个节点的值都加上比它大的节点的值"></a>3. 把二叉查找树每个节点的值都加上比它大的节点的值</h2><p>Convert BST to Greater Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: The root of a Binary Search Tree like this:</span><br><span class="line"></span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">Output: The root of a Greater Tree like this:</span><br><span class="line"></span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>

<p>先遍历右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    traver(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traver</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    traver(node.right);</span><br><span class="line">    sum += node.val;</span><br><span class="line">    node.val = sum;</span><br><span class="line">    traver(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二叉查找树的最近公共祖先"><a href="#4-二叉查找树的最近公共祖先" class="headerlink" title="4. 二叉查找树的最近公共祖先"></a>4. 二叉查找树的最近公共祖先</h2><p>235. Lowest Common Ancestor of a Binary Search Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">        _______6______</span><br><span class="line">      /                \</span><br><span class="line">  ___2__             ___8__</span><br><span class="line"> /      \           /      \</span><br><span class="line">0        4         7        9</span><br><span class="line">        /  \</span><br><span class="line">       3   5</span><br><span class="line"></span><br><span class="line">For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-二叉树的最近公共祖先"><a href="#5-二叉树的最近公共祖先" class="headerlink" title="5. 二叉树的最近公共祖先"></a>5. 二叉树的最近公共祖先</h2><p>236. Lowest Common Ancestor of a Binary Tree (Medium) </p>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">       _______3______</span><br><span class="line">      /              \</span><br><span class="line">  ___5__           ___1__</span><br><span class="line"> /      \         /      \</span><br><span class="line">6        2       0        8</span><br><span class="line">        /  \</span><br><span class="line">       7    4</span><br><span class="line"></span><br><span class="line">For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-从有序数组中构造二叉查找树"><a href="#6-从有序数组中构造二叉查找树" class="headerlink" title="6. 从有序数组中构造二叉查找树"></a>6. 从有序数组中构造二叉查找树</h2><p>108. Convert Sorted Array to Binary Search Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">toBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> sIdx, <span class="keyword">int</span> eIdx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sIdx &gt; eIdx) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mIdx = (sIdx + eIdx) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mIdx]);</span><br><span class="line">    root.left =  toBST(nums, sIdx, mIdx - <span class="number">1</span>);</span><br><span class="line">    root.right = toBST(nums, mIdx + <span class="number">1</span>, eIdx);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-根据有序链表构造平衡的二叉查找树"><a href="#7-根据有序链表构造平衡的二叉查找树" class="headerlink" title="7. 根据有序链表构造平衡的二叉查找树"></a>7. 根据有序链表构造平衡的二叉查找树</h2><p>109. Convert Sorted List to Binary Search Tree (Medium)</p>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">    ListNode preMid = preMid(head);</span><br><span class="line">    ListNode mid = preMid.next;</span><br><span class="line">    preMid.next = <span class="keyword">null</span>;  <span class="comment">// 断开链表</span></span><br><span class="line">    TreeNode t = <span class="keyword">new</span> TreeNode(mid.val);</span><br><span class="line">    t.left = sortedListToBST(head);</span><br><span class="line">    t.right = sortedListToBST(mid.next);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">preMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode slow = head, fast = head.next;</span><br><span class="line">    ListNode pre = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pre = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-在二叉查找树中寻找两个节点，使它们的和为一个给定值"><a href="#8-在二叉查找树中寻找两个节点，使它们的和为一个给定值" class="headerlink" title="8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值"></a>8. 在二叉查找树中寻找两个节点，使它们的和为一个给定值</h2><p>653. Two Sum IV - Input is a BST (Easy)</p>
<p><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。</p>
<p>应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findTarget</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inOrder(root, nums);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = nums.get(i) + nums.get(j);</span><br><span class="line">        <span class="keyword">if</span> (sum == k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; k) i++;</span><br><span class="line">        <span class="keyword">else</span> j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left, nums);</span><br><span class="line">    nums.add(root.val);</span><br><span class="line">    inOrder(root.right, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-在二叉查找树中查找两个节点之差的最小绝对值"><a href="#9-在二叉查找树中查找两个节点之差的最小绝对值" class="headerlink" title="9. 在二叉查找树中查找两个节点之差的最小绝对值"></a>9. 在二叉查找树中查找两个节点之差的最小绝对值</h2><p>530. Minimum Absolute Difference in BST (Easy)</p>
<p><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">private</span> TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    inOrder(root);</span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) minDiff = Math.min(minDiff, node.val - preNode.val);</span><br><span class="line">    preNode = node;</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-寻找二叉查找树中出现次数最多的值"><a href="#10-寻找二叉查找树中出现次数最多的值" class="headerlink" title="10. 寻找二叉查找树中出现次数最多的值"></a>10. 寻找二叉查找树中出现次数最多的值</h2><p>501. Find Mode in Binary Search Tree (Easy)</p>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   2</span><br><span class="line"></span><br><span class="line">return [2].</span><br></pre></td></tr></table></figure>

<p>答案可能不止一个，也就是有多个值出现的次数一样多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> curCnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxCnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> TreeNode preNode = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">    List&lt;Integer&gt; maxCntNums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    inOrder(root, maxCntNums);</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[maxCntNums.size()];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : maxCntNums) &#123;</span><br><span class="line">        ret[idx++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node, List&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(node.left, nums);</span><br><span class="line">    <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (preNode.val == node.val) curCnt++;</span><br><span class="line">        <span class="keyword">else</span> curCnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curCnt &gt; maxCnt) &#123;</span><br><span class="line">        maxCnt = curCnt;</span><br><span class="line">        nums.clear();</span><br><span class="line">        nums.add(node.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curCnt == maxCnt) &#123;</span><br><span class="line">        nums.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">    preNode = node;</span><br><span class="line">    inOrder(node.right, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><div align="center"> <img src="pics/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"> </div><br>

<p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>
<h2 id="1-实现一个-Trie"><a href="#1-实现一个-Trie" class="headerlink" title="1. 实现一个 Trie"></a>1. 实现一个 Trie</h2><p>208. Implement Trie (Prefix Tree) (Medium)</p>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node[] childs = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        insert(word, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            node.isLeaf = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = indexForChar(word.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (node.childs[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.childs[index] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        insert(word.substring(<span class="number">1</span>), node.childs[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(word, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">return</span> node.isLeaf;</span><br><span class="line">        <span class="keyword">int</span> index = indexForChar(word.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> search(word.substring(<span class="number">1</span>), node.childs[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startWith(prefix, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String prefix, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> index = indexForChar(prefix.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> startWith(prefix.substring(<span class="number">1</span>), node.childs[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexForChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-实现一个-Trie，用来求前缀和"><a href="#2-实现一个-Trie，用来求前缀和" class="headerlink" title="2. 实现一个 Trie，用来求前缀和"></a>2. 实现一个 Trie，用来求前缀和</h2><p>677. Map Sum Pairs (Medium)</p>
<p><a href="https://leetcode.com/problems/map-sum-pairs/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/map-sum-pairs/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: insert("apple", 3), Output: Null</span><br><span class="line">Input: sum("ap"), Output: 3</span><br><span class="line">Input: insert("app", 2), Output: Null</span><br><span class="line">Input: sum("ap"), Output: 5</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node[] child = <span class="keyword">new</span> Node[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        insert(key, root, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key, Node node, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (key.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            node.value = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = indexForChar(key.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (node.child[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.child[index] = <span class="keyword">new</span> Node();</span><br><span class="line">        &#125;</span><br><span class="line">        insert(key.substring(<span class="number">1</span>), node.child[index], val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum(prefix, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(String prefix, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = indexForChar(prefix.charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> sum(prefix.substring(<span class="number">1</span>), node.child[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = node.value;</span><br><span class="line">        <span class="keyword">for</span> (Node child : node.child) &#123;</span><br><span class="line">            sum += sum(prefix, child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">indexForChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 链表</title>
    <url>/blog/post/b7209553.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-找出两个链表的交点">1. 找出两个链表的交点</a></li>
<li><a href="#2-链表反转">2. 链表反转</a></li>
<li><a href="#3-归并两个有序的链表">3. 归并两个有序的链表</a></li>
<li><a href="#4-从有序链表中删除重复节点">4. 从有序链表中删除重复节点</a></li>
<li><a href="#5-删除链表的倒数第-n-个节点">5. 删除链表的倒数第 n 个节点</a></li>
<li><a href="#6-交换链表中的相邻结点">6. 交换链表中的相邻结点</a></li>
<li><a href="#7-链表求和">7. 链表求和</a></li>
<li><a href="#8-回文链表">8. 回文链表</a></li>
<li><a href="#9-分隔链表">9. 分隔链表</a></li>
<li><a href="#10-链表元素按奇偶聚集">10. 链表元素按奇偶聚集</a><!-- GFM-TOC -->


</li>
</ul><p>链表是空节点，或者有一个值和一个指向下一个链表的指针，因此很多链表问题可以用递归来处理。</p><a id="more"></a><!-- GFM-TOC -->


<h1 id="1-找出两个链表的交点"><a href="#1-找出两个链表的交点" class="headerlink" title="1. 找出两个链表的交点"></a>1. 找出两个链表的交点</h1><p>160. Intersection of Two Linked Lists (Easy)</p>
<p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">力扣</a></p>
<p>例如以下示例中 A 和 B 两个链表相交于 c1：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                    ↘</span><br><span class="line">                      c1 → c2 → c3</span><br><span class="line">                    ↗</span><br><span class="line">B:    b1 → b2 → b3</span><br></pre></td></tr></table></figure>

<p>但是不会出现以下相交的情况，因为每个节点只有一个 next 指针，也就只能有一个后继节点，而以下示例中节点 c 有两个后继节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">A:          a1 → a2       d1 → d2</span><br><span class="line">                    ↘  ↗</span><br><span class="line">                      c</span><br><span class="line">                    ↗  ↘</span><br><span class="line">B:    b1 → b2 → b3        e1 → e2</span><br></pre></td></tr></table></figure>

<p>要求时间复杂度为 O(N)，空间复杂度为 O(1)。如果不存在交点则返回 null。</p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p>
<p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode l1 = headA, l2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (l1 != l2) &#123;</span><br><span class="line">        l1 = (l1 == <span class="keyword">null</span>) ? headB : l1.next;</span><br><span class="line">        l2 = (l2 == <span class="keyword">null</span>) ? headA : l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只是判断是否存在交点，那么就是另一个问题，即 <a href>编程之美 3.6</a> 的问题。有两种解法：</p>
<ul>
<li>把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；</li>
<li>或者直接比较两个链表的最后一个节点是否相同。</li>
</ul>
<h1 id="2-链表反转"><a href="#2-链表反转" class="headerlink" title="2. 链表反转"></a>2. 链表反转</h1><p>206. Reverse Linked List (Easy)</p>
<p><a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">力扣</a></p>
<p>递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next = head.next;</span><br><span class="line">    ListNode newHead = reverseList(next);</span><br><span class="line">    next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头插法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = newHead.next;</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-归并两个有序的链表"><a href="#3-归并两个有序的链表" class="headerlink" title="3. 归并两个有序的链表"></a>3. 归并两个有序的链表</h1><p>21. Merge Two Sorted Lists (Easy)</p>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-从有序链表中删除重复节点"><a href="#4-从有序链表中删除重复节点" class="headerlink" title="4. 从有序链表中删除重复节点"></a>4. 从有序链表中删除重复节点</h1><p>83. Remove Duplicates from Sorted List (Easy)</p>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;1-&gt;2, return 1-&gt;2.</span><br><span class="line">Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    head.next = deleteDuplicates(head.next);</span><br><span class="line">    <span class="keyword">return</span> head.val == head.next.val ? head.next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-删除链表的倒数第-n-个节点"><a href="#5-删除链表的倒数第-n-个节点" class="headerlink" title="5. 删除链表的倒数第 n 个节点"></a>5. 删除链表的倒数第 n 个节点</h1><p>19. Remove Nth Node From End of List (Medium)</p>
<p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-交换链表中的相邻结点"><a href="#6-交换链表中的相邻结点" class="headerlink" title="6. 交换链表中的相邻结点"></a>6. 交换链表中的相邻结点</h1><p>24. Swap Nodes in Pairs (Medium)</p>
<p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<p>题目要求：不能修改结点的 val 值，O(1) 空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    node.next = head;</span><br><span class="line">    ListNode pre = node;</span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode l1 = pre.next, l2 = pre.next.next;</span><br><span class="line">        ListNode next = l2.next;</span><br><span class="line">        l1.next = next;</span><br><span class="line">        l2.next = l1;</span><br><span class="line">        pre.next = l2;</span><br><span class="line"></span><br><span class="line">        pre = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-链表求和"><a href="#7-链表求和" class="headerlink" title="7. 链表求和"></a>7. 链表求和</h1><p>445. Add Two Numbers II (Medium)</p>
<p><a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<p>题目要求：不能修改原始链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; l1Stack = buildStack(l1);</span><br><span class="line">    Stack&lt;Integer&gt; l2Stack = buildStack(l2);</span><br><span class="line">    ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!l1Stack.isEmpty() || !l2Stack.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = l1Stack.isEmpty() ? <span class="number">0</span> : l1Stack.pop();</span><br><span class="line">        <span class="keyword">int</span> y = l2Stack.isEmpty() ? <span class="number">0</span> : l2Stack.pop();</span><br><span class="line">        <span class="keyword">int</span> sum = x + y + carry;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stack&lt;Integer&gt; <span class="title">buildStack</span><span class="params">(ListNode l)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(l.val);</span><br><span class="line">        l = l.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-回文链表"><a href="#8-回文链表" class="headerlink" title="8. 回文链表"></a>8. 回文链表</h1><p>234. Palindrome Linked List (Easy)</p>
<p><a href="https://leetcode.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目要求：以 O(1) 的空间复杂度来求解。</p>
<p>切成两半，把后半段反转，然后比较两半是否相等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    ListNode slow = head, fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) slow = slow.next;  <span class="comment">// 偶数节点，让 slow 指向下一个节点</span></span><br><span class="line">    cut(head, slow);                     <span class="comment">// 切成两个链表</span></span><br><span class="line">    <span class="keyword">return</span> isEqual(head, reverse(slow));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(ListNode head, ListNode cutNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head.next != cutNode) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode nextNode = head.next;</span><br><span class="line">        head.next = newHead;</span><br><span class="line">        newHead = head;</span><br><span class="line">        head = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val != l2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-分隔链表"><a href="#9-分隔链表" class="headerlink" title="9. 分隔链表"></a>9. 分隔链表</h1><p>725. Split Linked List in Parts(Medium)</p>
<p><a href="https://leetcode.com/problems/split-linked-list-in-parts/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">Explanation:</span><br><span class="line">The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</span><br></pre></td></tr></table></figure>

<p>题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    ListNode cur = root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        N++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mod = N % k;</span><br><span class="line">    <span class="keyword">int</span> size = N / k;</span><br><span class="line">    ListNode[] ret = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">    cur = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; cur != <span class="keyword">null</span> &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">        ret[i] = cur;</span><br><span class="line">        <span class="keyword">int</span> curSize = size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-链表元素按奇偶聚集"><a href="#10-链表元素按奇偶聚集" class="headerlink" title="10. 链表元素按奇偶聚集"></a>10. 链表元素按奇偶聚集</h1><p>328. Odd Even Linked List (Medium)</p>
<p><a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,</span><br><span class="line">return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode odd = head, even = head.next, evenHead = even;</span><br><span class="line">    <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        odd.next = odd.next.next;</span><br><span class="line">        odd = odd.next;</span><br><span class="line">        even.next = even.next.next;</span><br><span class="line">        even = even.next;</span><br><span class="line">    &#125;</span><br><span class="line">    odd.next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 数学</title>
    <url>/blog/post/6a3c544d.html</url>
    <content><![CDATA[<ul>
<li><a href="#素数分解">素数分解</a></li>
<li><a href="#整除">整除</a></li>
<li><a href="#最大公约数最小公倍数">最大公约数最小公倍数</a><ul>
<li><a href="#1-生成素数序列">1. 生成素数序列</a></li>
<li><a href="#2-最大公约数">2. 最大公约数</a></li>
<li><a href="#3-使用位操作和减法求解最大公约数">3. 使用位操作和减法求解最大公约数</a></li>
</ul>
</li>
<li><a href="#进制转换">进制转换</a><ul>
<li><a href="#1-7-进制">1. 7 进制</a></li>
<li><a href="#2-16-进制">2. 16 进制</a></li>
<li><a href="#3-26-进制">3. 26 进制</a></li>
</ul>
</li>
<li><a href="#阶乘">阶乘</a><ul>
<li><a href="#1-统计阶乘尾部有多少个-0">1. 统计阶乘尾部有多少个 0</a></li>
</ul>
</li>
<li><a href="#字符串加法减法">字符串加法减法</a><ul>
<li><a href="#1-二进制加法">1. 二进制加法</a></li>
<li><a href="#2-字符串加法">2. 字符串加法</a></li>
</ul>
</li>
<li><a href="#相遇问题">相遇问题</a><ul>
<li><a href="#1-改变数组元素使所有的数组元素都相等">1. 改变数组元素使所有的数组元素都相等</a></li>
</ul>
</li>
<li><a href="#多数投票问题">多数投票问题</a><ul>
<li><a href="#1-数组中出现次数多于-n--2-的元素">1. 数组中出现次数多于 n / 2 的元素</a></li>
</ul>
</li>
<li><a href="#其它">其它</a><ul>
<li><a href="#1-平方数">1. 平方数</a></li>
<li><a href="#2-3-的-n-次方">2. 3 的 n 次方</a></li>
<li><a href="#3-乘积数组">3. 乘积数组</a></li>
<li><a href="#4-找出数组中的乘积最大的三个数">4. 找出数组中的乘积最大的三个数</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<h1 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h1><p>每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup> * 3<sup>1</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup> * 13<sup>0</sup> * 17<sup>0</sup> * …</p>
<h1 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h1><p>令 x = 2<sup>m0</sup> * 3<sup>m1</sup> * 5<sup>m2</sup> * 7<sup>m3</sup> * 11<sup>m4</sup> * …</p>
<p>令 y = 2<sup>n0</sup> * 3<sup>n1</sup> * 5<sup>n2</sup> * 7<sup>n3</sup> * 11<sup>n4</sup> * …</p>
<p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p>
<h1 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h1><p>x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> * 3<sup>min(m1,n1)</sup> * 5<sup>min(m2,n2)</sup> * ...</p>
<p>x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> * 3<sup>max(m1,n1)</sup> * 5<sup>max(m2,n2)</sup> * ...</p>
<h2 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h2><p>204. Count Primes (Easy)</p>
<p><a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/count-primes/description/" target="_blank" rel="noopener">力扣</a></p>
<p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] notPrimes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notPrimes[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> j = (<span class="keyword">long</span>) (i) * i; j &lt; n; j += i) &#123;</span><br><span class="line">            notPrimes[(<span class="keyword">int</span>) j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最小公倍数为两数的乘积除以最大公约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h2><p><a href="#">编程之美：2.7</a></p>
<p>对于 a 和 b 的最大公约数 f(a, b)，有：</p>
<ul>
<li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li>
<li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li>
<li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li>
<li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li>
</ul>
<p>乘 2 和除 2 都可以转换为移位操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAEven = isEven(a), isBEven = isEven(b);</span><br><span class="line">    <span class="keyword">if</span> (isAEven &amp;&amp; isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * gcd(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAEven &amp;&amp; !isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAEven &amp;&amp; isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a - b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h2><p>504. Base 7 (Easy)</p>
<p><a href="https://leetcode.com/problems/base-7/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/base-7/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = num &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(num % <span class="number">7</span>);</span><br><span class="line">        num /= <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = sb.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="string">"-"</span> + ret : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(num, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h2><p>405. Convert a Number to Hexadecimal (Easy)</p>
<p><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"1a"</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"ffffffff"</span><br></pre></td></tr></table></figure>

<p>负数要用它的补码形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(map[num &amp; <span class="number">0b1111</span>]);</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">4</span>; <span class="comment">// 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h2><p>168. Excel Sheet Column Title (Easy)</p>
<p><a href="https://leetcode.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB</span><br></pre></td></tr></table></figure>

<p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">return</span> convertToTitle(n / <span class="number">26</span>) + (<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h2><p>172. Factorial Trailing Zeroes (Easy)</p>
<p><a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener">力扣</a></p>
<p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/5<sup>2</sup> + N/5<sup>3</sup> + ...，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5<sup>2</sup> 表示不大于 N 的数中 5<sup>2</sup> 的倍数再贡献一个 5 ...。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="#">编程之美：2.2</a> 。和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup> + N/2<sup>3</sup> + ...</p>
<h1 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h1><h2 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h2><p>67. Add Binary (Easy)</p>
<p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/add-binary/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a = "11"</span><br><span class="line">b = "1"</span><br><span class="line">Return "100".</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            carry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            carry++;</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(carry % <span class="number">2</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h2><p>415. Add Strings (Easy)</p>
<p><a href="https://leetcode.com/problems/add-strings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/add-strings/description/" target="_blank" rel="noopener">力扣</a></p>
<p>字符串的值为非负整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i--) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">        str.append((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">        carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h1><h2 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h2><p>462. Minimum Moves to Equal Array Elements II (Medium)</p>
<p><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line"></span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure>

<p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p>
<p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p>
<p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p>
<p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p>
<p><strong>解法 1</strong> </p>
<p>先排序，时间复杂度：O(NlogN)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        move += nums[h] - nums[l];</span><br><span class="line">        l++;</span><br><span class="line">        h--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> move;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解法 2</strong> </p>
<p>使用快速选择找到中位数，时间复杂度 O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> median = findKthSmallest(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        move += Math.abs(num - median);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> move;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; nums[l] &amp;&amp; i &lt; h) ;</span><br><span class="line">        <span class="keyword">while</span> (nums[--j] &gt; nums[l] &amp;&amp; j &gt; l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h1><h2 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h2><p>169. Majority Element (Easy)</p>
<p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">力扣</a></p>
<p>先对数组排序，最中间那个数出现次数一定多于 n / 2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        majority = (cnt == <span class="number">0</span>) ? num : majority;</span><br><span class="line">        cnt = (majority == num) ? cnt + <span class="number">1</span> : cnt - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h2><p>367. Valid Perfect Square (Easy)</p>
<p><a href="https://leetcode.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Returns: True</span><br></pre></td></tr></table></figure>

<p>平方序列：1,4,9,16,..</p>
<p>间隔：3,5,7,...</p>
<p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num -= subNum;</span><br><span class="line">        subNum += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h2><p>326. Power of Three (Easy)</p>
<p><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/power-of-three/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h2><p>238. Product of Array Except Self (Medium)</p>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given [1,2,3,4], return [24,12,8,6].</span><br></pre></td></tr></table></figure>

<p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p>
<p>要求时间复杂度为 O(N)，并且不能使用除法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] products = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(products, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        left *= nums[i - <span class="number">1</span>];</span><br><span class="line">        products[i] *= left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right *= nums[i + <span class="number">1</span>];</span><br><span class="line">        products[i] *= right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h2><p>628. Maximum Product of Three Numbers (Easy)</p>
<p><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: 24</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; max1) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; max2) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; max3) &#123;</span><br><span class="line">            max3 = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; min1) &#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; min2) &#123;</span><br><span class="line">            min2 = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max1*max2*max3, max1*min1*min2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 动态规划</title>
    <url>/blog/post/77ebe21.html</url>
    <content><![CDATA[<ul>
<li><a href="#斐波那契数列">斐波那契数列</a><ul>
<li><a href="#1-爬楼梯">1. 爬楼梯</a></li>
<li><a href="#2-强盗抢劫">2. 强盗抢劫</a></li>
<li><a href="#3-强盗在环形街区抢劫">3. 强盗在环形街区抢劫</a></li>
<li><a href="#4-信件错排">4. 信件错排</a></li>
<li><a href="#5-母牛生产">5. 母牛生产</a></li>
</ul>
</li>
<li><a href="#矩阵路径">矩阵路径</a><ul>
<li><a href="#1-矩阵的最小路径和">1. 矩阵的最小路径和</a></li>
<li><a href="#2-矩阵的总路径数">2. 矩阵的总路径数</a></li>
</ul>
</li>
<li><a href="#数组区间">数组区间</a><ul>
<li><a href="#1-数组区间和">1. 数组区间和</a></li>
<li><a href="#2-数组中等差递增子区间的个数">2. 数组中等差递增子区间的个数</a></li>
</ul>
</li>
<li><a href="#分割整数">分割整数</a><ul>
<li><a href="#1-分割整数的最大乘积">1. 分割整数的最大乘积</a></li>
<li><a href="#2-按平方数来分割整数">2. 按平方数来分割整数</a></li>
<li><a href="#3-分割整数构成字母字符串">3. 分割整数构成字母字符串</a></li>
</ul>
</li>
<li><a href="#最长递增子序列">最长递增子序列</a><ul>
<li><a href="#1-最长递增子序列">1. 最长递增子序列</a></li>
<li><a href="#2-一组整数对能够构成的最长链">2. 一组整数对能够构成的最长链</a></li>
<li><a href="#3-最长摆动子序列">3. 最长摆动子序列</a></li>
</ul>
</li>
<li><a href="#最长公共子序列">最长公共子序列</a></li>
<li><a href="#0-1-背包">0-1 背包</a><ul>
<li><a href="#1-划分数组为和相等的两部分">1. 划分数组为和相等的两部分</a></li>
<li><a href="#2-改变一组数的正负号使得它们的和为一给定数">2. 改变一组数的正负号使得它们的和为一给定数</a></li>
<li><a href="#3-01-字符构成最多的字符串">3. 01 字符构成最多的字符串</a></li>
<li><a href="#4-找零钱的最少硬币数">4. 找零钱的最少硬币数</a></li>
<li><a href="#5-找零钱的硬币数组合">5. 找零钱的硬币数组合</a></li>
<li><a href="#6-字符串按单词列表分割">6. 字符串按单词列表分割</a></li>
<li><a href="#7-组合总和">7. 组合总和</a></li>
</ul>
</li>
<li><a href="#股票交易">股票交易</a><ul>
<li><a href="#1-需要冷却期的股票交易">1. 需要冷却期的股票交易</a></li>
<li><a href="#2-需要交易费用的股票交易">2. 需要交易费用的股票交易</a></li>
<li><a href="#3-只能进行两次的股票交易">3. 只能进行两次的股票交易</a></li>
<li><a href="#4-只能进行-k-次的股票交易">4. 只能进行 k 次的股票交易</a></li>
</ul>
</li>
<li><a href="#字符串编辑">字符串编辑</a><ul>
<li><a href="#1-删除两个字符串的字符使它们相等">1. 删除两个字符串的字符使它们相等</a></li>
<li><a href="#2-编辑距离">2. 编辑距离</a></li>
<li><a href="#3-复制粘贴字符">3. 复制粘贴字符</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<p>递归和动态规划都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划保存了子问题的解，避免重复计算。</p>
<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><h2 id="1-爬楼梯"><a href="#1-爬楼梯" class="headerlink" title="1. 爬楼梯"></a>1. 爬楼梯</h2><p>70. Climbing Stairs (Easy)</p>
<p><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p>
<p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p>
<p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-2]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/14fe1e71-8518-458f-a220-116003061a83.png" width="200px"> </div><br>

<p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">1</span>, pre1 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = pre1 + pre2;</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-强盗抢劫"><a href="#2-强盗抢劫" class="headerlink" title="2. 强盗抢劫"></a>2. 强盗抢劫</h2><p>198. House Robber (Easy)</p>
<p><a href="https://leetcode.com/problems/house-robber/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/house-robber/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p>
<p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p>
<p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=max(dp[i-2]+nums[i],dp[i-1])" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/2de794ca-aa7b-48f3-a556-a0e2708cb976.jpg" width="350px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(pre2 + nums[i], pre1);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-强盗在环形街区抢劫"><a href="#3-强盗在环形街区抢劫" class="headerlink" title="3. 强盗在环形街区抢劫"></a>3. 强盗在环形街区抢劫</h2><p>213. House Robber II (Medium)</p>
<p><a href="https://leetcode.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/house-robber-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(pre1, pre2 + nums[i]);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-信件错排"><a href="#4-信件错排" class="headerlink" title="4. 信件错排"></a>4. 信件错排</h2><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p>
<p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p>
<ul>
<li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li>
<li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li>
</ul>
<p>综上所述，错误装信数量方式数量为：</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=(i-1)*dp[i-2]+(i-1)*dp[i-1]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/da1f96b9-fd4d-44ca-8925-fb14c5733388.png" width="350px"> </div><br>

<h2 id="5-母牛生产"><a href="#5-母牛生产" class="headerlink" title="5. 母牛生产"></a>5. 母牛生产</h2><p><a href="#">程序员代码面试指南-P181</a></p>
<p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p>
<p>第 i 年成熟的牛的数量为：</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i]=dp[i-1]+dp[i-3]" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/879814ee-48b5-4bcb-86f5-dcc400cb81ad.png" width="250px"> </div><br>

<h1 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h1><h2 id="1-矩阵的最小路径和"><a href="#1-矩阵的最小路径和" class="headerlink" title="1. 矩阵的最小路径和"></a>1. 矩阵的最小路径和</h2><p>64. Minimum Path Sum (Medium)</p>
<p><a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[[1,3,1],</span><br><span class="line"> [1,5,1],</span><br><span class="line"> [4,2,1]]</span><br><span class="line">Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</span><br></pre></td></tr></table></figure>

<p>题目描述：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j];        <span class="comment">// 只能从上侧走到该位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];    <span class="comment">// 只能从左侧走到该位置</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] += grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-矩阵的总路径数"><a href="#2-矩阵的总路径数" class="headerlink" title="2. 矩阵的总路径数"></a>2. 矩阵的总路径数</h2><p>62. Unique Paths (Medium)</p>
<p><a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/unique-paths/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p>
<div align="center"> <img src="pics/dc82f0f3-c1d4-4ac8-90ac-d5b32a9bd75a.jpg" width> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> S = m + n - <span class="number">2</span>;  <span class="comment">// 总共的移动次数</span></span><br><span class="line">    <span class="keyword">int</span> D = m - <span class="number">1</span>;      <span class="comment">// 向下的移动次数</span></span><br><span class="line">    <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= D; i++) &#123;</span><br><span class="line">        ret = ret * (S - D + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组区间"><a href="#数组区间" class="headerlink" title="数组区间"></a>数组区间</h1><h2 id="1-数组区间和"><a href="#1-数组区间和" class="headerlink" title="1. 数组区间和"></a>1. 数组区间和</h2><p>303. Range Sum Query - Immutable (Easy)</p>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br></pre></td></tr></table></figure>

<p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sums;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            sums[i] = sums[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-数组中等差递增子区间的个数"><a href="#2-数组中等差递增子区间的个数" class="headerlink" title="2. 数组中等差递增子区间的个数"></a>2. 数组中等差递增子区间的个数</h2><p>413. Arithmetic Slices (Medium)</p>
<p><a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">A = [0, 1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">return: 6, for 3 arithmetic slices in A:</span><br><span class="line"></span><br><span class="line">[0, 1, 2],</span><br><span class="line">[1, 2, 3],</span><br><span class="line">[0, 1, 2, 3],</span><br><span class="line">[0, 1, 2, 3, 4],</span><br><span class="line">[ 1, 2, 3, 4],</span><br><span class="line">[2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p>
<p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">dp[2] = 1</span><br><span class="line">    [0, 1, 2]</span><br><span class="line">dp[3] = dp[2] + 1 = 2</span><br><span class="line">    [0, 1, 2, 3], // [0, 1, 2] 之后加一个 3</span><br><span class="line">    [1, 2, 3]     // 新的递增子区间</span><br><span class="line">dp[4] = dp[3] + 1 = 3</span><br><span class="line">    [0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4</span><br><span class="line">    [1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4</span><br><span class="line">    [2, 3, 4]        // 新的递增子区间</span><br></pre></td></tr></table></figure>

<p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p>
<p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cnt : dp) &#123;</span><br><span class="line">        total += cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分割整数"><a href="#分割整数" class="headerlink" title="分割整数"></a>分割整数</h1><h2 id="1-分割整数的最大乘积"><a href="#1-分割整数的最大乘积" class="headerlink" title="1. 分割整数的最大乘积"></a>1. 分割整数的最大乘积</h2><p>343. Integer Break (Medim)</p>
<p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/integer-break/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-按平方数来分割整数"><a href="#2-按平方数来分割整数" class="headerlink" title="2. 按平方数来分割整数"></a>2. 按平方数来分割整数</h2><p>279. Perfect Squares(Medium)</p>
<p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/perfect-squares/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = generateSquareList(n);</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> square : squareList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (square &gt; i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            min = Math.min(min, dp[i - square] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">generateSquareList</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; squareList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> square = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (square &lt;= n) &#123;</span><br><span class="line">        squareList.add(square);</span><br><span class="line">        square += diff;</span><br><span class="line">        diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squareList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-分割整数构成字母字符串"><a href="#3-分割整数构成字母字符串" class="headerlink" title="3. 分割整数构成字母字符串"></a>3. 分割整数构成字母字符串</h2><p>91. Decode Ways (Medium)</p>
<p><a href="https://leetcode.com/problems/decode-ways/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/decode-ways/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：Given encoded message &quot;12&quot;, it could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> one = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (one != <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i - <span class="number">2</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> two = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">        <span class="keyword">if</span> (two &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p>已知一个序列 {S<sub>1</sub>, S<sub>2</sub>,...,S<sub>n</sub>}，取出若干数组成新的序列 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p>
<p>如果在子序列中，当下标 ix &gt; iy 时，S<sub>ix</sub> &gt; S<sub>iy</sub>，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p>
<p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 S<sub>n</sub> 结尾的序列的最长递增子序列长度。对于一个递增子序列 {S<sub>i1</sub>, S<sub>i2</sub>,...,S<sub>im</sub>}，如果 im &lt; n 并且 S<sub>im</sub> &lt; S<sub>n</sub>，此时 {S<sub>i1</sub>, S<sub>i2</sub>,..., S<sub>im</sub>, S<sub>n</sub>} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 S<sub>n</sub> 就构成了以 S<sub>n</sub> 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | S<sub>i</sub> &lt; S<sub>n</sub> &amp;&amp; i &lt; n} 。</p>
<p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[n]=max\{1,dp[i]+1|S_i<S_n\&\&i<n\}" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/ee994da4-0fc7-443d-ac56-c08caf00a204.jpg" width="350px"> </div><br>

<p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 S<sub>N</sub> 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p>
<h2 id="1-最长递增子序列"><a href="#1-最长递增子序列" class="headerlink" title="1. 最长递增子序列"></a>1. 最长递增子序列</h2><p>300. Longest Increasing Subsequence (Medium)</p>
<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Stream 求最大值会导致运行时间过长，可以改成以下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    ret = Math.max(ret, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>

<p>以上解法的时间复杂度为 O(N<sup>2</sup>)，可以使用二分查找将时间复杂度降低为 O(NlogN)。</p>
<p>定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素。对于一个元素 x，</p>
<ul>
<li>如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1；</li>
<li>如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x。</li>
</ul>
<p>例如对于数组 [4,3,6,5]，有：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">tails      len      num</span><br><span class="line">[]         0        4</span><br><span class="line">[4]        1        3</span><br><span class="line">[3]        1        6</span><br><span class="line">[3,6]      2        5</span><br><span class="line">[3,5]      2        null</span><br></pre></td></tr></table></figure>

<p>可以看出 tails 数组保持有序，因此在查找 S<sub>i</sub> 位于 tails 数组的位置时就可以使用二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(tails, len, num);</span><br><span class="line">        tails[index] = num;</span><br><span class="line">        <span class="keyword">if</span> (index == len) &#123;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] tails, <span class="keyword">int</span> len, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = len;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (tails[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tails[mid] &gt; key) &#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-一组整数对能够构成的最长链"><a href="#2-一组整数对能够构成的最长链" class="headerlink" title="2. 一组整数对能够构成的最长链"></a>2. 一组整数对能够构成的最长链</h2><p>646. Maximum Length of Pair Chain (Medium)</p>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [[1,2], [2,3], [3,4]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest chain is [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure>

<p>题目描述：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="keyword">int</span>[][] pairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pairs == <span class="keyword">null</span> || pairs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(pairs, (a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs[j][<span class="number">1</span>] &lt; pairs[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最长摆动子序列"><a href="#3-最长摆动子序列" class="headerlink" title="3. 最长摆动子序列"></a>3. 最长摆动子序列</h2><p>376. Wiggle Subsequence (Medium)</p>
<p><a href="https://leetcode.com/problems/wiggle-subsequence/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/wiggle-subsequence/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1,7,4,9,2,5]</span><br><span class="line">Output: 6</span><br><span class="line">The entire sequence is a wiggle sequence.</span><br><span class="line"></span><br><span class="line">Input: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">Output: 7</span><br><span class="line">There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>要求：使用 O(N) 时间复杂度求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            up = down + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            down = up + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>
<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1<sub>i</sub> 与 S2<sub>j</sub> 值是否相等，分为两种情况：</p>
<ul>
<li>当 S1<sub>i</sub>==S2<sub>j</sub> 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1<sub>i</sub> 这个值，最长公共子序列长度加 1，即 dp[i][j] = dp[i-1][j-1] + 1。</li>
<li>当 S1<sub>i</sub> != S2<sub>j</sub> 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li>
</ul>
<p>综上，最长公共子序列的状态转移方程为：</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]=\left\{\begin{array}{rcl}dp[i-1][j-1]&&{S1_i==S2_j}\\max(dp[i-1][j],dp[i][j-1])&&{S1_i<>S2_j}\end{array}\right." class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/ecd89a22-c075-4716-8423-e0ba89230e9a.jpg" width="450px"> </div><br>

<p>对于长度为 N 的序列 S<sub>1</sub> 和长度为 M 的序列 S<sub>2</sub>，dp[N][M] 就是序列 S<sub>1</sub> 和序列 S<sub>2</sub> 的最长公共子序列长度。</p>
<p>与最长递增子序列相比，最长公共子序列有以下不同点：</p>
<ul>
<li>针对的是两个序列，求它们的最长公共子序列。</li>
<li>在最长递增子序列中，dp[i] 表示以 S<sub>i</sub> 为结尾的最长递增子序列长度，子序列必须包含 S<sub>i</sub> ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1<sub>i</sub> 和 S2<sub>j</sub>。</li>
<li>在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 S<sub>N</sub> 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLCS</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = nums1.length, n2 = nums2.length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h1><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p>
<p>定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</p>
<ul>
<li>第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</li>
<li>第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</li>
</ul>
<p>第 i 件物品可添加也可以不添加，取决于哪种情况下最大价值更大。因此，0-1 背包的状态转移方程为：</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[i][j]=max(dp[i-1][j],dp[i-1][j-w]+v)" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/8cb2be66-3d47-41ba-b55b-319fc68940d4.png" width="400px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>空间优化</strong> </p>
<p>在程序实现时可以对 0-1 背包做优化。观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，</p>
<!--<div align="center"><img src="https://latex.codecogs.com/gif.latex?dp[j]=max(dp[j],dp[j-w]+v)" class="mathjax-pic"/></div> <br>-->

<div align="center"> <img src="pics/9ae89f16-7905-4a6f-88a2-874b4cac91f4.jpg" width="300px"> </div><br>

<p>因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, <span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>无法使用贪心算法的解释</strong> </p>
<p>0-1 背包问题无法使用贪心算法来求解，也就是说不能按照先添加性价比最高的物品来达到最优，这是因为这种方式可能造成背包空间的浪费，从而无法达到最优。考虑下面的物品和一个容量为 5 的背包，如果先添加物品 0 再添加物品 1，那么只能存放的价值为 16，浪费了大小为 2 的空间。最优的方式是存放物品 1 和物品 2，价值为 22.</p>
<table>
<thead>
<tr>
<th>id</th>
<th>w</th>
<th>v</th>
<th>v/w</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>6</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>12</td>
<td>4</td>
</tr>
</tbody></table>
<p><strong>变种</strong> </p>
<ul>
<li><p>完全背包：物品数量为无限个</p>
</li>
<li><p>多重背包：物品数量有限制</p>
</li>
<li><p>多维费用背包：物品不仅有重量，还有体积，同时考虑这两种限制</p>
</li>
<li><p>其它：物品之间相互约束或者依赖</p>
</li>
</ul>
<h2 id="1-划分数组为和相等的两部分"><a href="#1-划分数组为和相等的两部分" class="headerlink" title="1. 划分数组为和相等的两部分"></a>1. 划分数组为和相等的两部分</h2><p>416. Partition Equal Subset Sum (Medium)</p>
<p><a href="https://leetcode.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<p>可以看成一个背包大小为 sum/2 的 0-1 背包问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = computeArraySum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> W = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[W + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;                 <span class="comment">// 0-1 背包一个物品只能用一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = W; i &gt;= num; i--) &#123;   <span class="comment">// 从后往前，先计算 dp[i] 再计算 dp[i-num]</span></span><br><span class="line">            dp[i] = dp[i] || dp[i - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeArraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-改变一组数的正负号使得它们的和为一给定数"><a href="#2-改变一组数的正负号使得它们的和为一给定数" class="headerlink" title="2. 改变一组数的正负号使得它们的和为一给定数"></a>2. 改变一组数的正负号使得它们的和为一给定数</h2><p>494. Target Sum (Medium)</p>
<p><a href="https://leetcode.com/problems/target-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/target-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: nums is [1, 1, 1, 1, 1], S is 3.</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">There are 5 ways to assign symbols to make the sum of nums be target 3.</span><br></pre></td></tr></table></figure>

<p>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p>
<p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">                  sum(P) - sum(N) = target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) = target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) = target + sum(nums)</span><br></pre></td></tr></table></figure>

<p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = computeArraySum(nums);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; S || (sum + S) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> W = (sum + S) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = W; i &gt;= num; i--) &#123;</span><br><span class="line">            dp[i] = dp[i] + dp[i - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeArraySum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS 解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findTargetSumWays(nums, <span class="number">0</span>, S);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> S == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findTargetSumWays(nums, start + <span class="number">1</span>, S + nums[start])</span><br><span class="line">            + findTargetSumWays(nums, start + <span class="number">1</span>, S - nums[start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-01-字符构成最多的字符串"><a href="#3-01-字符构成最多的字符串" class="headerlink" title="3. 01 字符构成最多的字符串"></a>3. 01 字符构成最多的字符串</h2><p>474. Ones and Zeroes (Medium)</p>
<p><a href="https://leetcode.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: Array = &#123;"10", "0001", "111001", "1", "0"&#125;, m = 5, n = 3</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are "10","0001","1","0"</span><br></pre></td></tr></table></figure>

<p>这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (String s : strs) &#123;    <span class="comment">// 每个字符串只能用一次</span></span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, zeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">                zeros++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ones++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zeros; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= ones; j--) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-找零钱的最少硬币数"><a href="#4-找零钱的最少硬币数" class="headerlink" title="4. 找零钱的最少硬币数"></a>4. 找零钱的最少硬币数</h2><p>322. Coin Change (Medium)</p>
<p><a href="https://leetcode.com/problems/coin-change/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/coin-change/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">coins = [1, 2, 5], amount = 11</span><br><span class="line">return 3 (11 = 5 + 5 + 1)</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">coins = [2], amount = 3</span><br><span class="line">return -1.</span><br></pre></td></tr></table></figure>

<p>题目描述：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。</p>
<ul>
<li>物品：硬币</li>
<li>物品大小：面额</li>
<li>物品价值：数量</li>
</ul>
<p>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123; <span class="comment">//将逆序遍历改为正序遍历</span></span><br><span class="line">            <span class="keyword">if</span> (i == coin) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == <span class="number">0</span> &amp;&amp; dp[i - coin] != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[i - coin] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[i - coin] != <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-找零钱的硬币数组合"><a href="#5-找零钱的硬币数组合" class="headerlink" title="5. 找零钱的硬币数组合"></a>5. 找零钱的硬币数组合</h2><p>518. Coin Change 2 (Medium)</p>
<p><a href="https://leetcode.com/problems/coin-change-2/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/coin-change-2/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>

<p>完全背包问题，使用 dp 记录可达成目标的组合数目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">            dp[i] += dp[i - coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-字符串按单词列表分割"><a href="#6-字符串按单词列表分割" class="headerlink" title="6. 字符串按单词列表分割"></a>6. 字符串按单词列表分割</h2><p>139. Word Break (Medium)</p>
<p><a href="https://leetcode.com/problems/word-break/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/word-break/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s = "leetcode",</span><br><span class="line">dict = ["leet", "code"].</span><br><span class="line">Return true because "leetcode" can be segmented as "leet code".</span><br></pre></td></tr></table></figure>

<p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。</p>
<p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 &quot;leetcode&quot;：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">["lee", "tc", "cod"]</span><br></pre></td></tr></table></figure>

<p>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;   <span class="comment">// 对物品的迭代应该放在最里层</span></span><br><span class="line">            <span class="keyword">int</span> len = word.length();</span><br><span class="line">            <span class="keyword">if</span> (len &lt;= i &amp;&amp; word.equals(s.substring(i - len, i))) &#123;</span><br><span class="line">                dp[i] = dp[i] || dp[i - len];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-组合总和"><a href="#7-组合总和" class="headerlink" title="7. 组合总和"></a>7. 组合总和</h2><p>377. Combination Sum IV (Medium)</p>
<p><a href="https://leetcode.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/combination-sum-iv/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">nums = [1, 2, 3]</span><br><span class="line">target = 4</span><br><span class="line"></span><br><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">Note that different sequences are counted as different combinations.</span><br><span class="line"></span><br><span class="line">Therefore the output is 7.</span><br></pre></td></tr></table></figure>

<p>涉及顺序的完全背包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maximum = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    maximum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length &amp;&amp; nums[j] &lt;= i; j++) &#123;</span><br><span class="line">            maximum[i] += maximum[i - nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h1><h2 id="1-需要冷却期的股票交易"><a href="#1-需要冷却期的股票交易" class="headerlink" title="1. 需要冷却期的股票交易"></a>1. 需要冷却期的股票交易</h2><p>309. Best Time to Buy and Sell Stock with Cooldown(Medium)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：交易之后需要有一天的冷却时间。</p>
<div align="center"> <img src="pics/ffd96b99-8009-487c-8e98-11c9d44ef14f.png" width="300px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> N = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] s2 = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = s2[i - <span class="number">1</span>] - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-需要交易费用的股票交易"><a href="#2-需要交易费用的股票交易" class="headerlink" title="2. 需要交易费用的股票交易"></a>2. 需要交易费用的股票交易</h2><p>714. Best Time to Buy and Sell Stock with Transaction Fee (Medium)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The maximum profit can be achieved by:</span><br><span class="line">Buying at prices[0] = 1</span><br><span class="line">Selling at prices[3] = 8</span><br><span class="line">Buying at prices[4] = 4</span><br><span class="line">Selling at prices[5] = 9</span><br><span class="line">The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure>

<p>题目描述：每交易一次，都要支付一定的费用。</p>
<div align="center"> <img src="pics/1e2c588c-72b7-445e-aacb-d55dc8a88c29.png" width="300px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] s1 = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="keyword">int</span>[] s2 = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    s1[<span class="number">0</span>] = buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    sell[<span class="number">0</span>] = s2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        buy[i] = Math.max(sell[i - <span class="number">1</span>], s2[i - <span class="number">1</span>]) - prices[i];</span><br><span class="line">        s1[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]);</span><br><span class="line">        sell[i] = Math.max(buy[i - <span class="number">1</span>], s1[i - <span class="number">1</span>]) - fee + prices[i];</span><br><span class="line">        s2[i] = Math.max(s2[i - <span class="number">1</span>], sell[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sell[N - <span class="number">1</span>], s2[N - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-只能进行两次的股票交易"><a href="#3-只能进行两次的股票交易" class="headerlink" title="3. 只能进行两次的股票交易"></a>3. 只能进行两次的股票交易</h2><p>123. Best Time to Buy and Sell Stock III (Hard)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstBuy = Integer.MIN_VALUE, firstSell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> secondBuy = Integer.MIN_VALUE, secondSell = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> curPrice : prices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstBuy &lt; -curPrice) &#123;</span><br><span class="line">            firstBuy = -curPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (firstSell &lt; firstBuy + curPrice) &#123;</span><br><span class="line">            firstSell = firstBuy + curPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secondBuy &lt; firstSell - curPrice) &#123;</span><br><span class="line">            secondBuy = firstSell - curPrice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secondSell &lt; secondBuy + curPrice) &#123;</span><br><span class="line">            secondSell = secondBuy + curPrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> secondSell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-只能进行-k-次的股票交易"><a href="#4-只能进行-k-次的股票交易" class="headerlink" title="4. 只能进行 k 次的股票交易"></a>4. 只能进行 k 次的股票交易</h2><p>188. Best Time to Buy and Sell Stock IV (Hard)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>) &#123;   <span class="comment">// 这种情况下该问题退化为普通的股票交易问题</span></span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                maxProfit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] maxProfit = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> localMax = maxProfit[i - <span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            maxProfit[i][j] = Math.max(maxProfit[i][j - <span class="number">1</span>], prices[j] + localMax);</span><br><span class="line">            localMax = Math.max(localMax, maxProfit[i - <span class="number">1</span>][j] - prices[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit[k][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h1><h2 id="1-删除两个字符串的字符使它们相等"><a href="#1-删除两个字符串的字符使它们相等" class="headerlink" title="1. 删除两个字符串的字符使它们相等"></a>1. 删除两个字符串的字符使它们相等</h2><p>583. Delete Operation for Two Strings (Medium)</p>
<p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "sea", "eat"</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".</span><br></pre></td></tr></table></figure>

<p>可以转换为求两个字符串的最长公共子序列问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m + n - <span class="number">2</span> * dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-编辑距离"><a href="#2-编辑距离" class="headerlink" title="2. 编辑距离"></a>2. 编辑距离</h2><p>72. Edit Distance (Hard)</p>
<p><a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/edit-distance/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: word1 = "horse", word2 = "ros"</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">horse -&gt; rorse (replace 'h' with 'r')</span><br><span class="line">rorse -&gt; rose (remove 'r')</span><br><span class="line">rose -&gt; ros (remove 'e')</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: word1 = "intention", word2 = "execution"</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">intention -&gt; inention (remove 't')</span><br><span class="line">inention -&gt; enention (replace 'i' with 'e')</span><br><span class="line">enention -&gt; exention (replace 'n' with 'x')</span><br><span class="line">exention -&gt; exection (replace 'n' with 'c')</span><br><span class="line">exection -&gt; execution (insert 'u')</span><br></pre></td></tr></table></figure>

<p>题目描述：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-复制粘贴字符"><a href="#3-复制粘贴字符" class="headerlink" title="3. 复制粘贴字符"></a>3. 复制粘贴字符</h2><p>650. 2 Keys Keyboard (Medium)</p>
<p><a href="https://leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">Intitally, we have one character &apos;A&apos;.</span><br><span class="line">In step 1, we use Copy All operation.</span><br><span class="line">In step 2, we use Paste operation to get &apos;AA&apos;.</span><br><span class="line">In step 3, we use Paste operation to get &apos;AAA&apos;.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> i + minSteps(n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> h = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= h; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = dp[j] + dp[i / j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 搜索</title>
    <url>/blog/post/d7d172d4.html</url>
    <content><![CDATA[<ul>
<li><a href="#bfs">BFS</a><ul>
<li><a href="#1-计算在网格中从原点到特定点的最短路径长度">1. 计算在网格中从原点到特定点的最短路径长度</a></li>
<li><a href="#2-组成整数的最小平方数数量">2. 组成整数的最小平方数数量</a></li>
<li><a href="#3-最短单词路径">3. 最短单词路径</a></li>
</ul>
</li>
<li><a href="#dfs">DFS</a><ul>
<li><a href="#1-查找最大的连通面积">1. 查找最大的连通面积</a></li>
<li><a href="#2-矩阵中的连通分量数目">2. 矩阵中的连通分量数目</a></li>
<li><a href="#3-好友关系的连通分量数目">3. 好友关系的连通分量数目</a></li>
<li><a href="#4-填充封闭区域">4. 填充封闭区域</a></li>
<li><a href="#5-能到达的太平洋和大西洋的区域">5. 能到达的太平洋和大西洋的区域</a></li>
</ul>
</li>
<li><a href="#backtracking">Backtracking</a><ul>
<li><a href="#1-数字键盘组合">1. 数字键盘组合</a></li>
<li><a href="#2-ip-地址划分">2. IP 地址划分</a></li>
<li><a href="#3-在矩阵中寻找字符串">3. 在矩阵中寻找字符串</a></li>
<li><a href="#4-输出二叉树中所有从根到叶子的路径">4. 输出二叉树中所有从根到叶子的路径</a></li>
<li><a href="#5-排列">5. 排列</a></li>
<li><a href="#6-含有相同元素求排列">6. 含有相同元素求排列</a></li>
<li><a href="#7-组合">7. 组合</a></li>
<li><a href="#8-组合求和">8. 组合求和</a></li>
<li><a href="#9-含有相同元素的组合求和">9. 含有相同元素的组合求和</a></li>
<li><a href="#10-1-9-数字的组合求和">10. 1-9 数字的组合求和</a></li>
<li><a href="#11-子集">11. 子集</a></li>
<li><a href="#12-含有相同元素求子集">12. 含有相同元素求子集</a></li>
<li><a href="#13-分割字符串使得每个部分都是回文数">13. 分割字符串使得每个部分都是回文数</a></li>
<li><a href="#14-数独">14. 数独</a></li>
<li><a href="#15-n-皇后">15. N 皇后</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><a id="more"></a><!-- GFM-TOC -->

<p>深度优先搜索和广度优先搜索广泛运用于树和图中，但是它们的应用远远不止如此。</p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><div align="center"> <img src="pics/95903878-725b-4ed9-bded-bc4aae0792a9.jpg"> </div><br>

<p>广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。</p>
<p>第一层：</p>
<ul>
<li>0 -&gt; {6,2,1,5}</li>
</ul>
<p>第二层：</p>
<ul>
<li>6 -&gt; {4}</li>
<li>2 -&gt; {}</li>
<li>1 -&gt; {}</li>
<li>5 -&gt; {3}</li>
</ul>
<p>第三层：</p>
<ul>
<li>4 -&gt; {}</li>
<li>3 -&gt; {}</li>
</ul>
<p>每一层遍历的节点都与根节点距离相同。设 d<sub>i</sub> 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d<sub>i</sub> &lt;= d<sub>j</sub>。利用这个结论，可以求解最短路径等  <strong>最优解</strong>  问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。</p>
<p>在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
</ul>
<h2 id="1-计算在网格中从原点到特定点的最短路径长度"><a href="#1-计算在网格中从原点到特定点的最短路径长度" class="headerlink" title="1. 计算在网格中从原点到特定点的最短路径长度"></a>1. 计算在网格中从原点到特定点的最短路径长度</h2><p>1091. Shortest Path in Binary Matrix(Medium)</p>
<p><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[[1,1,0,1],</span><br><span class="line"> [1,0,1,0],</span><br><span class="line"> [1,1,1,1],</span><br><span class="line"> [1,0,1,1]]</span><br></pre></td></tr></table></figure>

<p>题目描述：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grids)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m = grids.length, n = grids[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;Pair&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> Pair&lt;&gt;(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        pathLength++;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Pair&lt;Integer, Integer&gt; cur = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> cr = cur.getKey(), cc = cur.getValue();</span><br><span class="line">            grids[cr][cc] = <span class="number">1</span>; <span class="comment">// 标记</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">                <span class="keyword">int</span> nr = cr + d[<span class="number">0</span>], nc = cc + d[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nr &gt;= m || nc &lt; <span class="number">0</span> || nc &gt;= n || grids[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nr == m - <span class="number">1</span> &amp;&amp; nc == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pathLength + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Pair&lt;&gt;(nr, nc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-组成整数的最小平方数数量"><a href="#2-组成整数的最小平方数数量" class="headerlink" title="2. 组成整数的最小平方数数量"></a>2. 组成整数的最小平方数数量</h2><p>279. Perfect Squares (Medium)</p>
<p><a href="https://leetcode.com/problems/perfect-squares/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/perfect-squares/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</span><br></pre></td></tr></table></figure>

<p>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。</p>
<p>要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。</p>
<p>本题也可以用动态规划求解，在之后动态规划部分中会再次出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; squares = generateSquares(n);</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    queue.add(n);</span><br><span class="line">    marked[n] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s : squares) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = cur - s;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (marked[next]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                marked[next] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成小于 n 的平方数序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 1,4,9,...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">generateSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; squares = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> square = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (square &lt;= n) &#123;</span><br><span class="line">        squares.add(square);</span><br><span class="line">        square += diff;</span><br><span class="line">        diff += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> squares;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最短单词路径"><a href="#3-最短单词路径" class="headerlink" title="3. 最短单词路径"></a>3. 最短单词路径</h2><p>127. Word Ladder (Medium)</p>
<p><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/word-ladder/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = "hit",</span><br><span class="line">endWord = "cog",</span><br><span class="line">wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",</span><br><span class="line">return its length 5.</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">beginWord = "hit"</span><br><span class="line">endWord = "cog"</span><br><span class="line">wordList = ["hot","dot","dog","lot","log"]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>

<p>题目描述：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    wordList.add(beginWord);</span><br><span class="line">    <span class="keyword">int</span> N = wordList.size();</span><br><span class="line">    <span class="keyword">int</span> start = N - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (end &lt; N &amp;&amp; !wordList.get(end).equals(endWord)) &#123;</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end == N) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] graphic = buildGraphic(wordList);</span><br><span class="line">    <span class="keyword">return</span> getShortestPath(graphic, start, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt;[] buildGraphic(List&lt;String&gt; wordList) &#123;</span><br><span class="line">    <span class="keyword">int</span> N = wordList.size();</span><br><span class="line">    List&lt;Integer&gt;[] graphic = <span class="keyword">new</span> List[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        graphic[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnect(wordList.get(i), wordList.get(j))) &#123;</span><br><span class="line">                graphic[i].add(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graphic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConnect</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diffCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length() &amp;&amp; diffCnt &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i)) &#123;</span><br><span class="line">            diffCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> diffCnt == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getShortestPath</span><span class="params">(List&lt;Integer&gt;[] graphic, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[graphic.length];</span><br><span class="line">    queue.add(start);</span><br><span class="line">    marked[start] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        path++;</span><br><span class="line">        <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> next : graphic[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (next == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> path;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (marked[next]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                marked[next] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><div align="center"> <img src="pics/74dc31eb-6baa-47ea-ab1c-d27a0ca35093.png"> </div><br>

<p>广度优先搜索一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。</p>
<p>而深度优先搜索在得到一个新节点时立即对新节点进行遍历：从节点 0 出发开始遍历，得到到新节点 6 时，立马对新节点 6 进行遍历，得到新节点 4；如此反复以这种方式遍历新节点，直到没有新节点了，此时返回。返回到根节点 0 的情况是，继续对根节点 0 进行遍历，得到新节点 2，然后继续以上步骤。</p>
<p>从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种  <strong>可达性</strong>  问题。</p>
<p>在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li>
<li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li>
</ul>
<h2 id="1-查找最大的连通面积"><a href="#1-查找最大的连通面积" class="headerlink" title="1. 查找最大的连通面积"></a>1. 查找最大的连通面积</h2><p>695. Max Area of Island (Medium)</p>
<p><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            maxArea = Math.max(maxArea, dfs(grid, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        area += dfs(grid, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-矩阵中的连通分量数目"><a href="#2-矩阵中的连通分量数目" class="headerlink" title="2. 矩阵中的连通分量数目"></a>2. 矩阵中的连通分量数目</h2><p>200. Number of Islands (Medium)</p>
<p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/number-of-islands/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<p>可以将矩阵表示看成一张有向图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m = grid.length;</span><br><span class="line">    n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> islandsNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                islandsNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> islandsNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[i][j] = <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        dfs(grid, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-好友关系的连通分量数目"><a href="#3-好友关系的连通分量数目" class="headerlink" title="3. 好友关系的连通分量数目"></a>3. 好友关系的连通分量数目</h2><p>547. Friend Circles (Medium)</p>
<p><a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/friend-circles/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.</span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure>

<p>题目描述：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    n = M.length;</span><br><span class="line">    <span class="keyword">int</span> circleNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasVisited[i]) &#123;</span><br><span class="line">            dfs(M, i, hasVisited);</span><br><span class="line">            circleNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> circleNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> i, <span class="keyword">boolean</span>[] hasVisited)</span> </span>&#123;</span><br><span class="line">    hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (M[i][k] == <span class="number">1</span> &amp;&amp; !hasVisited[k]) &#123;</span><br><span class="line">            dfs(M, k, hasVisited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-填充封闭区域"><a href="#4-填充封闭区域" class="headerlink" title="4. 填充封闭区域"></a>4. 填充封闭区域</h2><p>130. Surrounded Regions (Medium)</p>
<p><a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example,</span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line"></span><br><span class="line">After running your function, the board should be:</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br></pre></td></tr></table></figure>

<p>题目描述：使被 &#39;X&#39; 包围的 &#39;O&#39; 转换为 &#39;X&#39;。</p>
<p>先填充最外侧，剩下的就是里侧了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(board, i, <span class="number">0</span>);</span><br><span class="line">        dfs(board, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(board, <span class="number">0</span>, i);</span><br><span class="line">        dfs(board, m - <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">'O'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[r][c] = <span class="string">'T'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        dfs(board, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-能到达的太平洋和大西洋的区域"><a href="#5-能到达的太平洋和大西洋的区域" class="headerlink" title="5. 能到达的太平洋和大西洋的区域"></a>5. 能到达的太平洋和大西洋的区域</h2><p>417. Pacific Atlantic Water Flow (Medium)</p>
<p><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given the following 5x5 matrix:</span><br><span class="line"></span><br><span class="line">  Pacific ~   ~   ~   ~   ~</span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * Atlantic</span><br><span class="line"></span><br><span class="line">Return:</span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</span><br></pre></td></tr></table></figure>

<p>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = matrix.length;</span><br><span class="line">    n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="keyword">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">        dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">        dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canReachP[i][j] &amp;&amp; canReachA[i][j]) &#123;</span><br><span class="line">                ret.add(Arrays.asList(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] canReach)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canReach[r][c]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    canReach[r][c] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextR = d[<span class="number">0</span>] + r;</span><br><span class="line">        <span class="keyword">int</span> nextC = d[<span class="number">1</span>] + c;</span><br><span class="line">        <span class="keyword">if</span> (nextR &lt; <span class="number">0</span> || nextR &gt;= m || nextC &lt; <span class="number">0</span> || nextC &gt;= n</span><br><span class="line">                || matrix[r][c] &gt; matrix[nextR][nextC]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nextR, nextC, canReach);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h1><p>Backtracking（回溯）属于 DFS。</p>
<ul>
<li>普通 DFS 主要用在  <strong>可达性问题</strong> ，这种问题只需要执行到特点的位置然后返回即可。</li>
<li>而 Backtracking 主要用于求解  <strong>排列组合</strong>  问题，例如有 { &#39;a&#39;,&#39;b&#39;,&#39;c&#39; } 三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特定的位置返回之后还会继续执行求解过程。</li>
</ul>
<p>因为 Backtracking 不是立即返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题：</p>
<ul>
<li>在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素；</li>
<li>但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。</li>
</ul>
<h2 id="1-数字键盘组合"><a href="#1-数字键盘组合" class="headerlink" title="1. 数字键盘组合"></a>1. 数字键盘组合</h2><p>17. Letter Combinations of a Phone Number (Medium)</p>
<p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">力扣</a></p>
<div align="center"> <img src="pics/9823768c-212b-4b1a-b69a-b3f59e07b977.jpg"> </div><br>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:Digit string "23"</span><br><span class="line">Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] KEYS = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line">    doCombination(<span class="keyword">new</span> StringBuilder(), combinations, digits);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCombination</span><span class="params">(StringBuilder prefix, List&lt;String&gt; combinations, <span class="keyword">final</span> String digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prefix.length() == digits.length()) &#123;</span><br><span class="line">        combinations.add(prefix.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> curDigits = digits.charAt(prefix.length()) - <span class="string">'0'</span>;</span><br><span class="line">    String letters = KEYS[curDigits];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : letters.toCharArray()) &#123;</span><br><span class="line">        prefix.append(c);                         <span class="comment">// 添加</span></span><br><span class="line">        doCombination(prefix, combinations, digits);</span><br><span class="line">        prefix.deleteCharAt(prefix.length() - <span class="number">1</span>); <span class="comment">// 删除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-IP-地址划分"><a href="#2-IP-地址划分" class="headerlink" title="2. IP 地址划分"></a>2. IP 地址划分</h2><p>93. Restore IP Addresses(Medium)</p>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given "25525511135",</span><br><span class="line">return ["255.255.11.135", "255.255.111.35"].</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; addresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder tempAddress = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    doRestore(<span class="number">0</span>, tempAddress, addresses, s);</span><br><span class="line">    <span class="keyword">return</span> addresses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRestore</span><span class="params">(<span class="keyword">int</span> k, StringBuilder tempAddress, List&lt;String&gt; addresses, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">4</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            addresses.add(tempAddress.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String part = s.substring(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Integer.valueOf(part) &lt;= <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempAddress.length() != <span class="number">0</span>) &#123;</span><br><span class="line">                part = <span class="string">"."</span> + part;</span><br><span class="line">            &#125;</span><br><span class="line">            tempAddress.append(part);</span><br><span class="line">            doRestore(k + <span class="number">1</span>, tempAddress, addresses, s.substring(i + <span class="number">1</span>));</span><br><span class="line">            tempAddress.delete(tempAddress.length() - part.length(), tempAddress.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-在矩阵中寻找字符串"><a href="#3-在矩阵中寻找字符串" class="headerlink" title="3. 在矩阵中寻找字符串"></a>3. 在矩阵中寻找字符串</h2><p>79. Word Search (Medium)</p>
<p><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/word-search/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given board =</span><br><span class="line">[</span><br><span class="line">  ['A','B','C','E'],</span><br><span class="line">  ['S','F','C','S'],</span><br><span class="line">  ['A','D','E','E']</span><br><span class="line">]</span><br><span class="line">word = "ABCCED", -&gt; returns true,</span><br><span class="line">word = "SEE", -&gt; returns true,</span><br><span class="line">word = "ABCB", -&gt; returns false.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] direction = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m = board.length;</span><br><span class="line">    n = board[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">boolean</span>[][] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; n; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(<span class="number">0</span>, r, c, hasVisited, board, word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> curLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited, <span class="keyword">final</span> <span class="keyword">char</span>[][] board, <span class="keyword">final</span> String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (curLen == word.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n</span><br><span class="line">            || board[r][c] != word.charAt(curLen) || visited[r][c]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] d : direction) &#123;</span><br><span class="line">        <span class="keyword">if</span> (backtracking(curLen + <span class="number">1</span>, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>], visited, board, word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[r][c] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-输出二叉树中所有从根到叶子的路径"><a href="#4-输出二叉树中所有从根到叶子的路径" class="headerlink" title="4. 输出二叉树中所有从根到叶子的路径"></a>4. 输出二叉树中所有从根到叶子的路径</h2><p>257. Binary Tree Paths (Easy)</p>
<p><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> /  \</span><br><span class="line">2    3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">["1-&gt;2-&gt;5", "1-&gt;3"]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtracking(root, values, paths);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(TreeNode node, List&lt;Integer&gt; values, List&lt;String&gt; paths)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    values.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(node)) &#123;</span><br><span class="line">        paths.add(buildPath(values));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        backtracking(node.left, values, paths);</span><br><span class="line">        backtracking(node.right, values, paths);</span><br><span class="line">    &#125;</span><br><span class="line">    values.remove(values.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">buildPath</span><span class="params">(List&lt;Integer&gt; values)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.size(); i++) &#123;</span><br><span class="line">        str.append(values.get(i));</span><br><span class="line">        <span class="keyword">if</span> (i != values.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            str.append(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-排列"><a href="#5-排列" class="headerlink" title="5. 排列"></a>5. 排列</h2><p>46. Permutations (Medium)</p>
<p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/permutations/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1,2,3] have the following permutations:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; permuteList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtracking(permuteList, permutes, hasVisited, nums);</span><br><span class="line">    <span class="keyword">return</span> permutes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="keyword">boolean</span>[] visited, <span class="keyword">final</span> <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permuteList.size() == nums.length) &#123;</span><br><span class="line">        permutes.add(<span class="keyword">new</span> ArrayList&lt;&gt;(permuteList)); <span class="comment">// 重新构造一个 List</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        permuteList.add(nums[i]);</span><br><span class="line">        backtracking(permuteList, permutes, visited, nums);</span><br><span class="line">        permuteList.remove(permuteList.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-含有相同元素求排列"><a href="#6-含有相同元素求排列" class="headerlink" title="6. 含有相同元素求排列"></a>6. 含有相同元素求排列</h2><p>47. Permutations II (Medium)</p>
<p><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/permutations-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[1,1,2] have the following unique permutations:</span><br><span class="line">[[1,1,2], [1,2,1], [2,1,1]]</span><br></pre></td></tr></table></figure>

<p>数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。</p>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; permutes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; permuteList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);  <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    backtracking(permuteList, permutes, hasVisited, nums);</span><br><span class="line">    <span class="keyword">return</span> permutes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="keyword">boolean</span>[] visited, <span class="keyword">final</span> <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permuteList.size() == nums.length) &#123;</span><br><span class="line">        permutes.add(<span class="keyword">new</span> ArrayList&lt;&gt;(permuteList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 防止重复</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited[i])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="keyword">true</span>;</span><br><span class="line">        permuteList.add(nums[i]);</span><br><span class="line">        backtracking(permuteList, permutes, visited, nums);</span><br><span class="line">        permuteList.remove(permuteList.size() - <span class="number">1</span>);</span><br><span class="line">        visited[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-组合"><a href="#7-组合" class="headerlink" title="7. 组合"></a>7. 组合</h2><p>77. Combinations (Medium)</p>
<p><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/combinations/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If n = 4 and k = 2, a solution is:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; combineList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtracking(combineList, combinations, <span class="number">1</span>, k, n);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;Integer&gt; combineList, List&lt;List&lt;Integer&gt;&gt; combinations, <span class="keyword">int</span> start, <span class="keyword">int</span> k, <span class="keyword">final</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combineList));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n - k + <span class="number">1</span>; i++) &#123;  <span class="comment">// 剪枝</span></span><br><span class="line">        combineList.add(i);</span><br><span class="line">        backtracking(combineList, combinations, i + <span class="number">1</span>, k - <span class="number">1</span>, n);</span><br><span class="line">        combineList.remove(combineList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-组合求和"><a href="#8-组合求和" class="headerlink" title="8. 组合求和"></a>8. 组合求和</h2><p>39. Combination Sum (Medium)</p>
<p><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/combination-sum/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">given candidate set [2, 3, 6, 7] and target 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[[7],[2, 2, 3]]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtracking(<span class="keyword">new</span> ArrayList&lt;&gt;(), combinations, <span class="number">0</span>, target, candidates);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">final</span> <span class="keyword">int</span>[] candidates)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempCombination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &lt;= target) &#123;</span><br><span class="line">            tempCombination.add(candidates[i]);</span><br><span class="line">            backtracking(tempCombination, combinations, i, target - candidates[i], candidates);</span><br><span class="line">            tempCombination.remove(tempCombination.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-含有相同元素的组合求和"><a href="#9-含有相同元素的组合求和" class="headerlink" title="9. 含有相同元素的组合求和"></a>9. 含有相同元素的组合求和</h2><p>40. Combination Sum II (Medium)</p>
<p><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtracking(<span class="keyword">new</span> ArrayList&lt;&gt;(), combinations, <span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length], <span class="number">0</span>, target, candidates);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span>[] hasVisited, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">final</span> <span class="keyword">int</span>[] candidates)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempCombination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !hasVisited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidates[i] &lt;= target) &#123;</span><br><span class="line">            tempCombination.add(candidates[i]);</span><br><span class="line">            hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">            backtracking(tempCombination, combinations, hasVisited, i + <span class="number">1</span>, target - candidates[i], candidates);</span><br><span class="line">            hasVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">            tempCombination.remove(tempCombination.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-1-9-数字的组合求和"><a href="#10-1-9-数字的组合求和" class="headerlink" title="10. 1-9 数字的组合求和"></a>10. 1-9 数字的组合求和</h2><p>216. Combination Sum III (Medium)</p>
<p><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: k = 3, n = 9</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">[[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>

<p>从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    backtracking(k, n, <span class="number">1</span>, path, combinations);</span><br><span class="line">    <span class="keyword">return</span> combinations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                          List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) &#123;</span><br><span class="line">        combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempCombination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        tempCombination.add(i);</span><br><span class="line">        backtracking(k - <span class="number">1</span>, n - i, i + <span class="number">1</span>, tempCombination, combinations);</span><br><span class="line">        tempCombination.remove(tempCombination.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-子集"><a href="#11-子集" class="headerlink" title="11. 子集"></a>11. 子集</h2><p>78. Subsets (Medium)</p>
<p><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/subsets/description/" target="_blank" rel="noopener">力扣</a></p>
<p>找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">        backtracking(<span class="number">0</span>, tempSubset, subsets, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">        subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempSubset));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        tempSubset.add(nums[i]);</span><br><span class="line">        backtracking(i + <span class="number">1</span>, tempSubset, subsets, size, nums);</span><br><span class="line">        tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-含有相同元素求子集"><a href="#12-含有相同元素求子集" class="headerlink" title="12. 含有相同元素求子集"></a>12. 含有相同元素求子集</h2><p>90. Subsets II (Medium)</p>
<p><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/subsets-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example,</span><br><span class="line">If nums = [1,2,2], a solution is:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">        backtracking(<span class="number">0</span>, tempSubset, subsets, hasVisited, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="keyword">boolean</span>[] hasVisited,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">        subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempSubset));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !hasVisited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempSubset.add(nums[i]);</span><br><span class="line">        hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        backtracking(i + <span class="number">1</span>, tempSubset, subsets, hasVisited, size, nums);</span><br><span class="line">        hasVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">        tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-分割字符串使得每个部分都是回文数"><a href="#13-分割字符串使得每个部分都是回文数" class="headerlink" title="13. 分割字符串使得每个部分都是回文数"></a>13. 分割字符串使得每个部分都是回文数</h2><p>131. Palindrome Partitioning (Medium)</p>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given s = "aab",</span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  ["aa","b"],</span><br><span class="line">  ["a","a","b"]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; tempPartition = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    doPartition(s, partitions, tempPartition);</span><br><span class="line">    <span class="keyword">return</span> partitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPartition</span><span class="params">(String s, List&lt;List&lt;String&gt;&gt; partitions, List&lt;String&gt; tempPartition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        partitions.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempPartition));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(s, <span class="number">0</span>, i)) &#123;</span><br><span class="line">            tempPartition.add(s.substring(<span class="number">0</span>, i + <span class="number">1</span>));</span><br><span class="line">            doPartition(s.substring(i + <span class="number">1</span>), partitions, tempPartition);</span><br><span class="line">            tempPartition.remove(tempPartition.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(begin++) != s.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-数独"><a href="#14-数独" class="headerlink" title="14. 数独"></a>14. 数独</h2><p>37. Sudoku Solver (Hard)</p>
<p><a href="https://leetcode.com/problems/sudoku-solver/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sudoku-solver/description/" target="_blank" rel="noopener">力扣</a></p>
<div align="center"> <img src="pics/0e8fdc96-83c1-4798-9abe-45fc91d70b9d.png"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] rowsUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] colsUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] cubesUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] board;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.board = board;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">            rowsUsed[i][num] = <span class="keyword">true</span>;</span><br><span class="line">            colsUsed[j][num] = <span class="keyword">true</span>;</span><br><span class="line">            cubesUsed[cubeNum(i, j)][num] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (row &lt; <span class="number">9</span> &amp;&amp; board[row][col] != <span class="string">'.'</span>) &#123;</span><br><span class="line">        row = col == <span class="number">8</span> ? row + <span class="number">1</span> : row;</span><br><span class="line">        col = col == <span class="number">8</span> ? <span class="number">0</span> : col + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">9</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; num++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rowsUsed[row][num] || colsUsed[col][num] || cubesUsed[cubeNum(row, col)][num]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = <span class="keyword">true</span>;</span><br><span class="line">        board[row][col] = (<span class="keyword">char</span>) (num + <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">if</span> (backtracking(row, col)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">        rowsUsed[row][num] = colsUsed[col][num] = cubesUsed[cubeNum(row, col)][num] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cubeNum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = i / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> c = j / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> r * <span class="number">3</span> + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-N-皇后"><a href="#15-N-皇后" class="headerlink" title="15. N 皇后"></a>15. N 皇后</h2><p>51. N-Queens (Hard)</p>
<p><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/n-queens/description/" target="_blank" rel="noopener">力扣</a></p>
<div align="center"> <img src="pics/067b310c-6877-40fe-9dcf-10654e737485.jpg"> </div><br>

<p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。</p>
<p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p>
<p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。</p>
<div align="center"> <img src="pics/9c422923-1447-4a3b-a4e1-97e663738187.jpg" width="300px"> </div><br>


<p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。</p>
<div align="center"> <img src="pics/7a85e285-e152-4116-b6dc-3fab27ba9437.jpg" width="300px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; solutions;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[][] nQueens;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] colUsed;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals45Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] diagonals135Used;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    solutions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    nQueens = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Arrays.fill(nQueens[i], <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    colUsed = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    diagonals45Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    diagonals135Used = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    backtracking(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> solutions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span>[] chars : nQueens) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">        &#125;</span><br><span class="line">        solutions.add(list);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diagonals45Idx = row + col;</span><br><span class="line">        <span class="keyword">int</span> diagonals135Idx = n - <span class="number">1</span> - (row - col);</span><br><span class="line">        <span class="keyword">if</span> (colUsed[col] || diagonals45Used[diagonals45Idx] || diagonals135Used[diagonals135Idx]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nQueens[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">true</span>;</span><br><span class="line">        backtracking(row + <span class="number">1</span>);</span><br><span class="line">        colUsed[col] = diagonals45Used[diagonals45Idx] = diagonals135Used[diagonals135Idx] = <span class="keyword">false</span>;</span><br><span class="line">        nQueens[row][col] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 分治</title>
    <url>/blog/post/d820eb3.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-给表达式加括号">1. 给表达式加括号</a></li>
<li><a href="#2-不同的二叉搜索树">2. 不同的二叉搜索树</a><!-- GFM-TOC -->


</li>
</ul><h1 id="1-给表达式加括号"><a href="#1-给表达式加括号" class="headerlink" title="1. 给表达式加括号"></a>1. 给表达式加括号</h1><p>241. Different Ways to Add Parentheses (Medium)</p><p><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "2-1-1".</span><br><span class="line"></span><br><span class="line">((2-1)-1) = 0</span><br><span class="line">(2-(1-1)) = 2</span><br><span class="line"></span><br><span class="line">Output : [0, 2]</span><br></pre></td></tr></table></figure><a id="more"></a><!-- GFM-TOC -->





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; ways = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = input.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span> || c == <span class="string">'*'</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">            List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l : left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r : right) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                            ways.add(l + r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                            ways.add(l - r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                            ways.add(l * r);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ways.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        ways.add(Integer.valueOf(input));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ways;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-不同的二叉搜索树"><a href="#2-不同的二叉搜索树" class="headerlink" title="2. 不同的二叉搜索树"></a>2. 不同的二叉搜索树</h1><p>95. Unique Binary Search Trees II (Medium)</p>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<p>给定一个数字 n，要求生成所有值为 1...n 的二叉搜索树。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST's shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> generateSubtrees(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateSubtrees</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; res = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">        res.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= e; ++i) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; leftSubtrees = generateSubtrees(s, i - <span class="number">1</span>);</span><br><span class="line">        List&lt;TreeNode&gt; rightSubtrees = generateSubtrees(i + <span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">for</span> (TreeNode left : leftSubtrees) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode right : rightSubtrees) &#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = left;</span><br><span class="line">                root.right = right;</span><br><span class="line">                res.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 二分查找</title>
    <url>/blog/post/4798ba91.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-求开方">1. 求开方</a></li>
<li><a href="#2-大于给定元素的最小元素">2. 大于给定元素的最小元素</a></li>
<li><a href="#3-有序数组的-single-element">3. 有序数组的 Single Element</a></li>
<li><a href="#4-第一个错误的版本">4. 第一个错误的版本</a></li>
<li><a href="#5-旋转数组的最小数字">5. 旋转数组的最小数字</a></li>
<li><a href="#6-查找区间">6. 查找区间</a><!-- GFM-TOC -->


</li>
</ul><p><strong>正常实现</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input : [1,2,3,4,5]</span><br><span class="line">key : 3</span><br><span class="line">return the index : 2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; key) &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><!-- GFM-TOC -->






<p><strong>时间复杂度</strong> </p>
<p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p>
<p><strong>m 计算</strong> </p>
<p>有两种计算中值 m 的方式：</p>
<ul>
<li>m = (l + h) / 2</li>
<li>m = l + (h - l) / 2</li>
</ul>
<p>l + h 可能出现加法溢出，也就是说加法的结果大于整型能够表示的范围。但是 l 和 h 都为正数，因此 h - l 不会出现加法溢出问题。所以，最好使用第二种计算法方法。</p>
<p><strong>未成功查找的返回值</strong> </p>
<p>循环退出时如果仍然没有查找到 key，那么表示查找失败。可以有两种返回值：</p>
<ul>
<li>-1：以一个错误码表示没有查找到 key</li>
<li>l：将 key 插入到 nums 中的正确位置</li>
</ul>
<p><strong>变种</strong> </p>
<p>二分查找可以有很多变种，变种实现要注意边界值的判断。例如在一个有重复元素的数组中查找 key 的最左位置的实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= key) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该实现和正常实现有以下不同：</p>
<ul>
<li>h 的赋值表达式为 h = m</li>
<li>循环条件为 l &lt; h</li>
<li>最后返回 l 而不是 -1</li>
</ul>
<p>在 nums[m] &gt;= key 的情况下，可以推导出最左 key 位于 [l, m] 区间中，这是一个闭区间。h 的赋值表达式为 h = m，因为 m 位置也可能是解。</p>
<p>在 h 的赋值表达式为 h = m 的情况下，如果循环条件为 l &lt;= h，那么会出现循环无法退出的情况，因此循环条件只能是 l &lt; h。以下演示了循环条件为 l &lt;= h 时循环无法退出的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums = &#123;0, 1, 2&#125;, key = 1</span><br><span class="line">l   m   h</span><br><span class="line">0   1   2  nums[m] &gt;= key</span><br><span class="line">0   0   1  nums[m] &lt; key</span><br><span class="line">1   1   1  nums[m] &gt;= key</span><br><span class="line">1   1   1  nums[m] &gt;= key</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当循环体退出时，不表示没有查找到 key，因此最后返回的结果不应该为 -1。为了验证有没有查找到，需要在调用端判断一下返回位置上的值和 key 是否相等。</p>
<h1 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h1><p>69. Sqrt(x) (Easy)</p>
<p><a href="https://leetcode.com/problems/sqrtx/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sqrtx/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</span><br></pre></td></tr></table></figure>

<p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p>
<p>对于 x = 8，它的开方是 2.82842...，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, h = x;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> sqrt = x / mid;</span><br><span class="line">        <span class="keyword">if</span> (sqrt == mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; sqrt) &#123;</span><br><span class="line">            h = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h1><p>744. Find Smallest Letter Greater Than Target (Easy)</p>
<p><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">letters = ["c", "f", "j"]</span><br><span class="line">target = "d"</span><br><span class="line">Output: "f"</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">letters = ["c", "f", "j"]</span><br><span class="line">target = "k"</span><br><span class="line">Output: "c"</span><br></pre></td></tr></table></figure>

<p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = letters.length;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (letters[m] &lt;= target) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l &lt; n ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h1><p>540. Single Element in a Sorted Array (Medium)</p>
<p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p>
<p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p>
<p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p>
<p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            m--;   <span class="comment">// 保证 l/h/m 都在偶数位，使得查找区间大小一直都是奇数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == nums[m + <span class="number">1</span>]) &#123;</span><br><span class="line">            l = m + <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h1><p>278. First Bad Version (Easy)</p>
<p><a href="https://leetcode.com/problems/first-bad-version/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/first-bad-version/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：给定一个元素 n 代表有 [1, 2, ..., n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p>
<p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, h = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">            h = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h1><p>153. Find Minimum in Rotated Sorted Array (Medium)</p>
<p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2],</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt;= nums[h]) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h1><p>34. Find First and Last Position of Element in Sorted Array</p>
<p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> first = binarySearch(nums, target);</span><br><span class="line">    <span class="keyword">int</span> last = binarySearch(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length; <span class="comment">// 注意 h 的初始值</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] &gt;= target) &#123;</span><br><span class="line">            h = m;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 贪心思想</title>
    <url>/blog/post/dce69e68.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-分配饼干">1. 分配饼干</a></li>
<li><a href="#2-不重叠的区间个数">2. 不重叠的区间个数</a></li>
<li><a href="#3-投飞镖刺破气球">3. 投飞镖刺破气球</a></li>
<li><a href="#4-根据身高和序号重组队列">4. 根据身高和序号重组队列</a></li>
<li><a href="#5-买卖股票最大的收益">5. 买卖股票最大的收益</a></li>
<li><a href="#6-买卖股票的最大收益-ii">6. 买卖股票的最大收益 II</a></li>
<li><a href="#7-种植花朵">7. 种植花朵</a></li>
<li><a href="#8-判断是否为子序列">8. 判断是否为子序列</a></li>
<li><a href="#9-修改一个数成为非递减数组">9. 修改一个数成为非递减数组</a></li>
<li><a href="#10-子数组最大的和">10. 子数组最大的和</a></li>
<li><a href="#11-分隔字符串使同种字符出现在一起">11. 分隔字符串使同种字符出现在一起</a><!-- GFM-TOC -->


</li>
</ul><p>保证每次操作都是局部最优的，并且最后得到的结果是全局最优的。</p><a id="more"></a><!-- GFM-TOC -->


<h1 id="1-分配饼干"><a href="#1-分配饼干" class="headerlink" title="1. 分配饼干"></a>1. 分配饼干</h1><p>455. Assign Cookies (Easy)</p>
<p><a href="https://leetcode.com/problems/assign-cookies/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/assign-cookies/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: grid[1,3], size[1,2,4]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<p>题目描述：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p>
<ol>
<li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li>
<li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li>
</ol>
<p>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p>
<p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p>
<div align="center"> <img src="pics/6fb7cf89-71b3-48c1-bc6a-5110e1f1fc15.gif" width="600px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] grid, <span class="keyword">int</span>[] size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid == <span class="keyword">null</span> || size == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(grid);</span><br><span class="line">    Arrays.sort(size);</span><br><span class="line">    <span class="keyword">int</span> gi = <span class="number">0</span>, si = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (gi &lt; grid.length &amp;&amp; si &lt; size.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[gi] &lt;= size[si]) &#123;</span><br><span class="line">            gi++;</span><br><span class="line">        &#125;</span><br><span class="line">        si++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-不重叠的区间个数"><a href="#2-不重叠的区间个数" class="headerlink" title="2. 不重叠的区间个数"></a>2. 不重叠的区间个数</h1><p>435. Non-overlapping Intervals (Medium)</p>
<p><a href="https://leetcode.com/problems/non-overlapping-intervals/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: You don't need to remove any of the intervals since they're already non-overlapping.</span><br></pre></td></tr></table></figure>

<p>题目描述：计算让一组区间不重叠所需要移除的区间个数。</p>
<p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p>
<p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p>
<p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; end) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        end = intervals[i][<span class="number">1</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals.length - cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 lambda 表示式创建 Comparator 会导致算法运行时间过长，如果注重运行时间，可以修改为普通创建 Comparator 语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="3-投飞镖刺破气球"><a href="#3-投飞镖刺破气球" class="headerlink" title="3. 投飞镖刺破气球"></a>3. 投飞镖刺破气球</h1><p>452. Minimum Number of Arrows to Burst Balloons (Medium)</p>
<p><a href="https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>题目描述：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p>
<p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(points, Comparator.comparingInt(o -&gt; o[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>, end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        end = points[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-根据身高和序号重组队列"><a href="#4-根据身高和序号重组队列" class="headerlink" title="4. 根据身高和序号重组队列"></a>4. 根据身高和序号重组队列</h1><p>406. Queue Reconstruction by Height(Medium)</p>
<p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>

<p>题目描述：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p>
<p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p>
<p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">    <span class="keyword">if</span> (people == <span class="keyword">null</span> || people.length == <span class="number">0</span> || people[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(people, (a, b) -&gt; (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] - b[<span class="number">1</span>] : b[<span class="number">0</span>] - a[<span class="number">0</span>]));</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : people) &#123;</span><br><span class="line">        queue.add(p[<span class="number">1</span>], p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[queue.size()][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-买卖股票最大的收益"><a href="#5-买卖股票最大的收益" class="headerlink" title="5. 买卖股票最大的收益"></a>5. 买卖股票最大的收益</h1><p>121. Best Time to Buy and Sell Stock (Easy)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p>
<p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = prices.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> soFarMin = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (soFarMin &gt; prices[i]) soFarMin = prices[i];</span><br><span class="line">        <span class="keyword">else</span> max = Math.max(max, prices[i] - soFarMin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-买卖股票的最大收益-II"><a href="#6-买卖股票的最大收益-II" class="headerlink" title="6. 买卖股票的最大收益 II"></a>6. 买卖股票的最大收益 II</h1><p>122. Best Time to Buy and Sell Stock II (Easy)</p>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<p>题目描述：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p>
<p>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            profit += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-种植花朵"><a href="#7-种植花朵" class="headerlink" title="7. 种植花朵"></a>7. 种植花朵</h1><p>605. Can Place Flowers (Easy)</p>
<p><a href="https://leetcode.com/problems/can-place-flowers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/can-place-flowers/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">Output: True</span><br></pre></td></tr></table></figure>

<p>题目描述：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = flowerbed.length;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; cnt &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flowerbed[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre = i == <span class="number">0</span> ? <span class="number">0</span> : flowerbed[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> next = i == len - <span class="number">1</span> ? <span class="number">0</span> : flowerbed[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">0</span> &amp;&amp; next == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-判断是否为子序列"><a href="#8-判断是否为子序列" class="headerlink" title="8. 判断是否为子序列"></a>8. 判断是否为子序列</h1><p>392. Is Subsequence (Medium)</p>
<p><a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/is-subsequence/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">s = "abc", t = "ahbgdc"</span><br><span class="line">Return true.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        index = t.indexOf(c, index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-修改一个数成为非递减数组"><a href="#9-修改一个数成为非递减数组" class="headerlink" title="9. 修改一个数成为非递减数组"></a>9. 修改一个数成为非递减数组</h1><p>665. Non-decreasing Array (Easy)</p>
<p><a href="https://leetcode.com/problems/non-decreasing-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/non-decreasing-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [4,2,3]</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</span><br></pre></td></tr></table></figure>

<p>题目描述：判断一个数组是否能只修改一个数就成为非递减数组。</p>
<p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且  <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossibility</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length &amp;&amp; cnt &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; nums[i - <span class="number">2</span>] &gt; nums[i]) &#123;</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i - <span class="number">1</span>] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-子数组最大的和"><a href="#10-子数组最大的和" class="headerlink" title="10. 子数组最大的和"></a>10. 子数组最大的和</h1><p>53. Maximum Subarray (Easy)</p>
<p><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">For example, given the array [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">the contiguous subarray [4,-1,2,1] has the largest sum = 6.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> preSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxSum = preSum;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        preSum = preSum &gt; <span class="number">0</span> ? preSum + nums[i] : nums[i];</span><br><span class="line">        maxSum = Math.max(maxSum, preSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="11-分隔字符串使同种字符出现在一起"><a href="#11-分隔字符串使同种字符出现在一起" class="headerlink" title="11. 分隔字符串使同种字符出现在一起"></a>11. 分隔字符串使同种字符出现在一起</h1><p>763. Partition Labels (Medium)</p>
<p><a href="https://leetcode.com/problems/partition-labels/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/partition-labels/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: S = "ababcbacadefegdehijhklij"</span><br><span class="line">Output: [9,7,8]</span><br><span class="line">Explanation:</span><br><span class="line">The partition is "ababcbaca", "defegde", "hijhklij".</span><br><span class="line">This is a partition so that each letter appears in at most one part.</span><br><span class="line">A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] lastIndexsOfChar = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        lastIndexsOfChar[char2Index(S.charAt(i))] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; partitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> firstIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (firstIndex &lt; S.length()) &#123;</span><br><span class="line">        <span class="keyword">int</span> lastIndex = firstIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = firstIndex; i &lt; S.length() &amp;&amp; i &lt;= lastIndex; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = lastIndexsOfChar[char2Index(S.charAt(i))];</span><br><span class="line">            <span class="keyword">if</span> (index &gt; lastIndex) &#123;</span><br><span class="line">                lastIndex = index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        partitions.add(lastIndex - firstIndex + <span class="number">1</span>);</span><br><span class="line">        firstIndex = lastIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">char2Index</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c - <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 排序</title>
    <url>/blog/post/30068991.html</url>
    <content><![CDATA[<ul>
<li><a href="#快速选择">快速选择</a></li>
<li><a href="#堆">堆</a><ul>
<li><a href="#1-kth-element">1. Kth Element</a></li>
</ul>
</li>
<li><a href="#桶排序">桶排序</a><ul>
<li><a href="#1-出现频率最多的-k-个元素">1. 出现频率最多的 k 个元素</a></li>
<li><a href="#2-按照字符出现次数对字符串排序">2. 按照字符出现次数对字符串排序</a></li>
</ul>
</li>
<li><a href="#荷兰国旗问题">荷兰国旗问题</a><ul>
<li><a href="#1-按颜色进行排序">1. 按颜色进行排序</a><!-- GFM-TOC -->


</li>
</ul>
</li>
</ul><h1 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h1><p>用于求解  <strong>Kth Element</strong>  问题，也就是第 K 个元素的问题。</p><p>可以使用快速排序的 partition() 进行实现。需要先打乱数组，否则最坏情况下时间复杂度为 O(N<sup>2</sup>)。</p><a id="more"></a><!-- GFM-TOC -->



<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>用于求解  <strong>TopK Elements</strong>  问题，也就是 K 个最小元素的问题。可以维护一个大小为 K 的最小堆，最小堆中的元素就是最小元素。最小堆需要使用大顶堆来实现，大顶堆表示堆顶元素是堆中最大元素。这是因为我们要得到 k 个最小的元素，因此当遍历到一个新的元素时，需要知道这个新元素是否比堆中最大的元素更小，更小的话就把堆中最大元素去除，并将新元素添加到堆中。所以我们需要很容易得到最大元素并移除最大元素，大顶堆就能很好满足这个要求。</p>
<p>堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 k 大的元素。</p>
<p>快速选择也可以求解 TopK Elements 问题，因为找到 Kth Element 之后，再遍历一次数组，所有小于等于 Kth Element 的元素都是 TopK Elements。</p>
<p>可以看到，快速选择和堆排序都可以求解 Kth Element 和 TopK Elements 问题。</p>
<h2 id="1-Kth-Element"><a href="#1-Kth-Element" class="headerlink" title="1. Kth Element"></a>1. Kth Element</h2><p>215. Kth Largest Element in an Array (Medium)</p>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<p>题目描述：找到倒数第 k 个的元素。</p>
<p><strong>排序</strong> ：时间复杂度 O(NlogN)，空间复杂度 O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆</strong> ：时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</span><br><span class="line">        pq.add(val);</span><br><span class="line">        <span class="keyword">if</span> (pq.size() &gt; k)  <span class="comment">// 维护堆的大小为 K</span></span><br><span class="line">            pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pq.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速选择</strong> ：时间复杂度 O(N)，空间复杂度 O(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k = nums.length - k;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; a[l] &amp;&amp; i &lt; h) ;</span><br><span class="line">        <span class="keyword">while</span> (a[--j] &gt; a[l] &amp;&amp; j &gt; l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="1-出现频率最多的-k-个元素"><a href="#1-出现频率最多的-k-个元素" class="headerlink" title="1. 出现频率最多的 k 个元素"></a>1. 出现频率最多的 k 个元素</h2><p>347. Top K Frequent Elements (Medium)</p>
<p><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given [1,1,1,2,2,3] and k = 2, return [1,2].</span><br></pre></td></tr></table></figure>

<p>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p>
<p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyForNum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> ArrayList[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key : frequencyForNum.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> frequency = frequencyForNum.get(key);</span><br><span class="line">        <span class="keyword">if</span> (buckets[frequency] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            buckets[frequency] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        buckets[frequency].add(key);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; topK = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; topK.size() &lt; k; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buckets[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buckets[i].size() &lt;= (k - topK.size())) &#123;</span><br><span class="line">            topK.addAll(buckets[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            topK.addAll(buckets[i].subList(<span class="number">0</span>, k - topK.size()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-按照字符出现次数对字符串排序"><a href="#2-按照字符出现次数对字符串排序" class="headerlink" title="2. 按照字符出现次数对字符串排序"></a>2. 按照字符出现次数对字符串排序</h2><p>451. Sort Characters By Frequency (Medium)</p>
<p><a href="https://leetcode.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">"tree"</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"eert"</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">'e' appears twice while 'r' and 't' both appear once.</span><br><span class="line">So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; frequencyForNum = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">        frequencyForNum.put(c, frequencyForNum.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;Character&gt;[] frequencyBucket = <span class="keyword">new</span> ArrayList[s.length() + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : frequencyForNum.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = frequencyForNum.get(c);</span><br><span class="line">        <span class="keyword">if</span> (frequencyBucket[f] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            frequencyBucket[f] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        frequencyBucket[f].add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = frequencyBucket.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frequencyBucket[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : frequencyBucket[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                str.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h1><p>荷兰国旗包含三种颜色：红、白、蓝。</p>
<p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p>
<div align="center"> <img src="pics/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png"> </div><br>


<h2 id="1-按颜色进行排序"><a href="#1-按颜色进行排序" class="headerlink" title="1. 按颜色进行排序"></a>1. 按颜色进行排序</h2><p>75. Sort Colors (Medium)</p>
<p><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sort-colors/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>

<p>题目描述：只有 0/1/2 三种颜色。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zero = -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">            swap(nums, ++zero, one++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>) &#123;</span><br><span class="line">            swap(nums, --two, one);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 题解 - 双指针</title>
    <url>/blog/post/a91249d8.html</url>
    <content><![CDATA[<ul>
<li><a href="#1-有序数组的-two-sum">1. 有序数组的 Two Sum</a></li>
<li><a href="#2-两数平方和">2. 两数平方和</a></li>
<li><a href="#3-反转字符串中的元音字符">3. 反转字符串中的元音字符</a></li>
<li><a href="#4-回文字符串">4. 回文字符串</a></li>
<li><a href="#5-归并两个有序数组">5. 归并两个有序数组</a></li>
<li><a href="#6-判断链表是否存在环">6. 判断链表是否存在环</a></li>
<li><a href="#7-最长子序列">7. 最长子序列</a><!-- GFM-TOC -->


</li>
</ul><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p><h1 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h1><p>167. Two Sum II - Input array is sorted (Easy)</p><a id="more"></a><!-- GFM-TOC -->



<p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">Output: index1=1, index2=2</span><br></pre></td></tr></table></figure>

<p>题目描述：在有序数组中找出两个数，使它们的和为 target。</p>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p>数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为  O(1)。</p>
<div align="center"> <img src="pics/437cb54c-5970-4ba9-b2ef-2541f7d6c81e.gif" width="200px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h1><p>633. Sum of Square Numbers (Easy)</p>
<p><a href="https://leetcode.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/sum-of-square-numbers/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure>

<p>题目描述：判断一个非负整数是否为两个整数的平方和。</p>
<p>可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p>
<p>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p>
<p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0<sup>2</sup> + x<sup>2</sup> 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p>
<p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(log<sub>2</sub>N)。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = (<span class="keyword">int</span>) Math.sqrt(target);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> powSum = i * i + j * j;</span><br><span class="line">        <span class="keyword">if</span> (powSum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (powSum &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h1><p>345. Reverse Vowels of a String (Easy)</p>
<p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given s = "leetcode", return "leotcede".</span><br></pre></td></tr></table></figure>

<div align="center"> <img src="pics/a7cb8423-895d-4975-8ef8-662a0029c772.png" width="400px"> </div><br>

<p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>
<p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p>
<ul>
<li>时间复杂度为 O(N)：只需要遍历所有元素一次</li>
<li>空间复杂度 O(1)：只需要使用两个额外变量</li>
</ul>
<div align="center"> <img src="pics/ef25ff7c-0f63-420d-8b30-eafbeea35d11.gif" width="400px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ci = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> cj = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!vowels.contains(ci)) &#123;</span><br><span class="line">            result[i++] = ci;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vowels.contains(cj)) &#123;</span><br><span class="line">            result[j--] = cj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = cj;</span><br><span class="line">            result[j--] = ci;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h1><p>680. Valid Palindrome II (Easy)</p>
<p><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "abca"</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character 'c'.</span><br></pre></td></tr></table></figure>

<p>题目描述：可以删除一个字符，判断是否能构成回文字符串。</p>
<p>所谓的回文字符串，是指具有左右对称特点的字符串，例如 &quot;abcba&quot; 就是一个回文字符串。</p>
<p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p>
<div align="center"> <img src="pics/fcc941ec-134b-4dcd-bc86-1702fd305300.gif" width="250px"> </div><br>

<p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p>
<p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p>
<p>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p>
<div align="center"> <img src="pics/db5f30a7-8bfa-4ecc-ab5d-747c77818964.gif" width="300px"> </div><br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPalindrome(s, i, j - <span class="number">1</span>) || isPalindrome(s, i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h1><p>88. Merge Sorted Array (Easy)</p>
<p><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<p>题目描述：把归并结果存到第一个数组上。</p>
<p>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = m - <span class="number">1</span>, index2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMerge = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h1><p>141. Linked List Cycle (Easy)</p>
<p><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">力扣</a></p>
<p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l1 = head, l2 = head.next;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span> &amp;&amp; l2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == l2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h1><p>524. Longest Word in Dictionary through Deleting (Medium)</p>
<p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/description/" target="_blank" rel="noopener">力扣</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p>
<p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSubstr(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubstr</span><span class="params">(String s, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 搭建 blog</title>
    <url>/blog/post/41a885c9.html</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p>http://www.likekeep.me/post/62703.html</p>
</blockquote>
<blockquote>
<p>https://www.jianshu.com/p/efbeddc5eb19</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>反击爬虫，前端工程师的脑洞可以有多大？</title>
    <url>/blog/post/f2bb9475.html</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。<br>而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是<strong>爬虫与反爬虫</strong>这一话题的由来。</p>
<a id="more"></a>

<h3 id="2-常见反爬虫策略"><a href="#2-常见反爬虫策略" class="headerlink" title="2. 常见反爬虫策略"></a>2. 常见反爬虫策略</h3><p>但是世界上没有一个网站，能做到完美地反爬虫。</p>
<p>如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于<strong>后端</strong>，也是目前比较常规单有效的手段，比如：</p>
<ul>
<li>User-Agent + Referer检测</li>
<li>账号及Cookie验证</li>
<li>验证码</li>
<li>IP限制频次</li>
</ul>
<p>而爬虫是可以无限逼近于真人的，比如：</p>
<ul>
<li>chrome headless或phantomjs来模拟浏览器环境</li>
<li><a href="http://udn.yyuap.com/doc/ae/920457.html" target="_blank" rel="noopener">tesseract</a>识别验证码</li>
<li>代理IP淘宝就能买到</li>
</ul>
<p>所以我们说，100%的反爬虫策略？不存在的。<br>更多的是体力活，是个难易程度的问题。</p>
<p>不过作为前端工程师，我们可以增加一下游戏难度，设计出一些<strong>很(sang)有(xin)意(bing)思(kuang)</strong>的反爬虫策略。</p>
<h3 id="3-前端与反爬虫"><a href="#3-前端与反爬虫" class="headerlink" title="3. 前端与反爬虫"></a>3. 前端与反爬虫</h3><h4 id="3-1-font-face拼凑式"><a href="#3-1-font-face拼凑式" class="headerlink" title="3.1 font-face拼凑式"></a>3.1 font-face拼凑式</h4><p><strong>例子：<a href="http://maoyan.com/films/342601" target="_blank" rel="noopener">猫眼电影</a></strong></p>
<p>猫眼电影里，对于票房数据，展示的并不是纯粹的数字。<br>页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs" alt></p>
<p>并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579" alt></p>
<h4 id="3-2-background拼凑式"><a href="#3-2-background拼凑式" class="headerlink" title="3.2 background拼凑式"></a>3.2 background拼凑式</h4><p><strong>例子：<a href="http://www.meituan.com/dianying/342601?#content" target="_blank" rel="noopener">美团</a></strong></p>
<p>与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW" alt></p>
<p>并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。</p>
<p>页面A：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry" alt><br>页面B：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL" alt></p>
<h4 id="3-3-字符穿插式"><a href="#3-3-字符穿插式" class="headerlink" title="3.3 字符穿插式"></a>3.3 字符穿插式</h4><p><strong>例子：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&mid=2247484365&idx=4&sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&scene=4" target="_blank" rel="noopener">微信公众号文章</a></strong></p>
<p>某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。<br>这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59" alt></p>
<p>对了，我的手机流量可以找谁报销吗？</p>
<h4 id="3-4-伪元素隐藏式"><a href="#3-4-伪元素隐藏式" class="headerlink" title="3.4 伪元素隐藏式"></a>3.4 伪元素隐藏式</h4><p><strong>例子：<a href="http://car.autohome.com.cn/config/series/3170.html" target="_blank" rel="noopener">汽车之家</a></strong></p>
<p>汽车之家里，把关键的厂商信息，做到了伪元素的content里。<br>这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5" alt></p>
<h4 id="3-5-元素定位覆盖式"><a href="#3-5-元素定位覆盖式" class="headerlink" title="3.5 元素定位覆盖式"></a>3.5 元素定位覆盖式</h4><p><strong>例子：<a href="https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&searchArrivalAirport=%E5%8C%97%E4%BA%AC&searchDepartureTime=2017-07-06&searchArrivalTime=2017-07-09&nextNDays=0&startSearch=true&fromCode=CAN&toCode=BJS&from=qunarindex&lowestPrice=null" target="_blank" rel="noopener">去哪儿</a></strong></p>
<p>还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个<code>i</code>标签渲染，再用两个<code>b</code>标签去绝对定位偏移量，覆盖故意展示错误的<code>i</code>标签，最后在视觉上形成正确的价格…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF" alt></p>
<p>这说明爬虫会解析css还不行，还得会做数学题。</p>
<h4 id="3-6-iframe异步加载式"><a href="#3-6-iframe异步加载式" class="headerlink" title="3.6 iframe异步加载式"></a>3.6 iframe异步加载式</h4><p><strong>例子：<a href="http://music.163.com/#/song?id=424477863" target="_blank" rel="noopener">网易云音乐</a></strong></p>
<p>网易云音乐页面一打开，html源码里几乎只有一个<code>iframe</code>，并且它的src是空白的：<code>about:blank</code>。接着js开始运行，把整个页面的框架异步塞到了iframe里面…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g" alt></p>
<p>不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。</p>
<h4 id="3-7-字符分割式"><a href="#3-7-字符分割式" class="headerlink" title="3.7 字符分割式"></a>3.7 字符分割式</h4><p><strong>例子：<a href="http://www.goubanjia.com/" target="_blank" rel="noopener">全网代理IP</a></strong></p>
<p>在一些展示代理IP信息的页面，对于IP的保护也是大费周折。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV" alt></p>
<p>他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p>
<h4 id="3-8-字符集替换式"><a href="#3-8-字符集替换式" class="headerlink" title="3.8 字符集替换式"></a>3.8 字符集替换式</h4><p><strong>例子：<a href="https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&arrCity=%E4%B8%8A%E6%B5%B7&goDate=2017-07-05&backDate=&sort=&airLine=&from=" target="_blank" rel="noopener">去哪儿移动侧</a></strong></p>
<p>同样会欺骗爬虫的还有去哪儿的移动版。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb" alt></p>
<p>html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq" alt></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
    <url>/blog/post/23046aa4.html</url>
    <content><![CDATA[<h1 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p>比如，你有个最简单的表，表里只有一个ID字段，在执行上面这个查询语句时，我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p><a id="more"></a>


<p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p>
<p><img src="/picture/content/mysql-01.png" alt="MySQL的逻辑架构图"></p>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL的逻辑架构图"></p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认存储引擎。</p>
<p>也就是说，你执行create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table 语句中使用 engine=memory，来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p>
<p>从图中不难看出，不同的存储引擎共用一个  <strong>Server</strong> 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄漏。如果你连的是生产服务器，强烈建议你不要这样做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个“Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用行的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p><img src="/picture/content/mysql-01-2.png" alt></p>
<p><img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" alt></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>
<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>
<p>2.如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二部：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的生效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的“select”这个关键字识别什么，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，词法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现的错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示（在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &apos;b&apos;@&apos;localhost&apos; for table &apos;T&apos;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在这些场景下，执行器调用一次，在引擎内部则扫描了多行，因此 <strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong> 我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我给你介绍了MySQL的逻辑架构，希望你对一个SQL语句完成执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的列子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p>
<p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句select * from T where k=1,那肯定是会报“不存在这个列”的错误：“Unknown column ‘k’ in ‘where clause’ ”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>02 | 日志架构：一条SQL更新语句是如何执行的？</title>
    <url>/blog/post/5fc62eb9.html</url>
    <content><![CDATA[<h1 id="02-日志架构：一条SQL更新语句是如何执行的？"><a href="#02-日志架构：一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志架构：一条SQL更新语句是如何执行的？"></a>02 | 日志架构：一条SQL更新语句是如何执行的？</h1><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p><p>那么，一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也不免会好奇，这是怎样做到的呢？</p><a id="more"></a>


<p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID = 2 这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL的逻辑架构图"></p>
<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和binlog在设计上有很多有意思的地方，这些涉及思路也可以用到你自己的程序里。</p>
<h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>不知道你还记不记得《孔乙已》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或者还帐的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本放出来核算。</li>
</ul>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回账本上。</p>
<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p>
<p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决整个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同事，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新帐腾出空间。</p>
<p>与此类似，InnoDB的redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这图所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong> 。</p>
<p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然指依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log 来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如 “给ID = 2这一行的c字段加1”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。 “追加写” 是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID = 2 这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID = 2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log 处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt></p>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是“两阶段提交”。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起： <strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用 “追加写” 的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。<br>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀网站记录</title>
    <url>/blog/post/e5ba9dfa.html</url>
    <content><![CDATA[<h2 id="计算机书籍"><a href="#计算机书籍" class="headerlink" title="计算机书籍"></a>计算机书籍</h2><ul>
<li><a href="https://itpanda.net/book/" target="_blank" rel="noopener">IT熊猫</a></li>
</ul>
]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>nice web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础(汇总)</title>
    <url>/blog/post/8b7b30a1.html</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>想要面试的初/中/想要面试的初/中/高级 Java 程序员<br>想要查漏补缺的人<br>想要不断完善和扩充自己 Java 技术栈的人<br>原本就掌握了技术却不知道怎么表达的人<br>有上进心,也愿意学习的人</p>
<p>一、 面试题覆盖全,且解析全面</p>
<p>这份面试题总内容包含了十九个模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM .</p>
<a id="more"></a>

<p>具体面试题如下</p>
<h2 id="一、-Java-基础"><a href="#一、-Java-基础" class="headerlink" title="一、 Java 基础"></a>一、 Java 基础</h2><ol>
<li><p>JDK 和 JRE 有什么区别？</p>
<ul>
<li><p>JDK:Java Deveplment Kit--面向开发人员的 SDK.它提供了 JAVA 的开发环境和运行环境</p>
<blockquote>
<p>SDK:Software Devemplment Kit--软件开发包</p>
</blockquote>
</li>
<li><p>JRE:Java Runtime Enviroment--面向使用者.提供了 JAVA 的运行环境</p>
</li>
<li><p>JVM:Java virtual machine--是我们常说的 Java 虚拟机</p>
</li>
</ul>
</li>
<li><p>== 和 equals 的区别是什么？</p>
<ul>
<li>==：比较的是两个字符串内存地址(堆内存)的数值是否相等,属于数值比较；</li>
<li>equals()：比较的是两个字符串的内容,属于内容比较.</li>
</ul>
</li>
<li><p>两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？</p>
<ul>
<li>对于 Object 类来说,equals()方法在对象上实现的是差别可能性最大的等价关系,即,对于任意非 null 的引用值 x 和 y,当且仅当 x 和 y 引用的是同一个对象,该方法才会返回 true.</li>
<li>需要注意的是当 equals()方法被 override 时,hashCode()也要被 override.按照一般 hashCode()方法的实现来说,相等的对象,它们的 hash code 一定相等.</li>
<li>并不要求根据 equals(java.lang.Object)方法不相等的两个对象,调用二者各自的 hashCode()方法必须产生不同的 integer 结果.</li>
<li>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<ol>
<li>相等(相同)的对象必须具有相等的哈希码(或者散列码).</li>
<li>如果两个对象的 hashCode 相同,它们并不一定相同.</li>
</ol>
</li>
</ul>
</li>
<li><p>final 在 java 中有什么作用？</p>
<ul>
<li>一旦你将引用声明作 final,你将不能改变这个引用了</li>
<li>可以用来生命：可以声明成员变量、方法、类以及本地变量.</li>
<li>final 关键字提高了性能.JVM 和 Java 应用都会缓存 final 变量.</li>
<li>final 变量可以安全的在多线程环境下进行共享,而不需要额外的同步开销.</li>
<li>使用 final 关键字,JVM 会对方法、变量及类进行优化.</li>
</ul>
</li>
<li><p>java 中的 Math.round(-1.5) 等于多少？</p>
<ul>
<li>Math.round(11.5)的返回值是 12,Math.round(-11.5)的返回值是-11.四舍五入的原理是在参数上加 0.5 然后进行下取整.</li>
<li>规则： 加 0.5,进行下取整;</li>
</ul>
</li>
<li><p>String 属于基础的数据类型吗？</p>
<ul>
<li>基础数据类型 8 种：byte、short、int、long、float、double、char、boolean</li>
<li>String 是对象,是引用类型.</li>
</ul>
</li>
<li><p>java 中操作字符串都有哪些类？它们之间有什么区别？</p>
<ul>
<li><a href="https://blog.csdn.net/qq_35246620/article/details/56024465" target="_blank" rel="noopener">链接</a></li>
<li>对于操作效率而言,一般来说,StringBuilder &gt; StringBuffer &gt; String；</li>
<li>对于线程安全而言,StringBuffer 是线程安全的,可用于多线程；而 StringBuilder 是非线程安全的,用于单线程；</li>
<li>对于频繁的字符串操作而言,无论是 StringBuffer 还是 StringBuilder,都优于 String.</li>
<li>String: 在 java.lang 下不可被继承的 final 类</li>
<li>StringBuffer:区别在于修改对象本身,线程安全可以用于多线程</li>
<li>StringBuilder: 脱胎于 StringBuffer,允许多线程方法添加或者删除,线程不安全,一般用于单线程.</li>
</ul>
</li>
<li><p>String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</p>
<blockquote>
<p><a href="https://www.cnblogs.com/bluestorm/p/3296897.html" target="_blank" rel="noopener">答案链接</a></p>
</blockquote>
<ul>
<li><p>String str = &quot;a&quot;; 这个只是一个引用,内存中如果有“a&quot;的话,str 就指向它；如果没有,才创建它;</p>
</li>
<li><p>如果你以后还用到&quot;a&quot;这个字符串的话并且是这样:String str1 = &quot;a&quot;; String str2 = &quot;a&quot;; String str2 = &quot;a&quot;; 这 4 个变量都共享一个字符串&quot;a&quot;.而 String str = new String(&quot;a&quot;);是根据&quot;a&quot;这个 String 对象再次构造一个 String 对象,将新构造出来的 String 对象的引用赋给 str.</p>
<blockquote>
<p><a href="https://www.cnblogs.com/aspirant/p/9193112.html" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何将字符串反转？</p>
</li>
</ol>
<ul>
<li>String reverse = new StringBuffer(string).reverse().toString();</li>
</ul>
<ol start="10">
<li>String 类的常用方法都有那些？</li>
</ol>
<ul>
<li><blockquote>
<p><a href="https://www.cnblogs.com/ABook/p/5527341.html" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
<li>public int length()</li>
<li>public char charAt(int index)</li>
<li>public String substring(int beginIndex, int endIndex)</li>
<li>public boolean equals(Object anotherObject)</li>
<li>public String concat(String str)//&quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;;</li>
<li>public int indexOf(int ch/String str)</li>
<li>public String toLowerCase()/public String toUpperCase()</li>
<li>public String replace(char oldChar, char newChar)</li>
<li>public String String trim()</li>
<li>public String[] split(String str)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求长度</span></span><br><span class="line"><span class="comment">// public int length();</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asdfgz"</span>);</span><br><span class="line"><span class="keyword">int</span> strlength = str.length();        <span class="comment">//strlength = 7</span></span><br><span class="line"><span class="comment">// 求某个字符串的某一位字符</span></span><br><span class="line"><span class="comment">// public char charAt(int index);</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asdfz"</span>);</span><br><span class="line"><span class="keyword">char</span> ch = str.charAt(<span class="number">4</span>);             <span class="comment">//ch=z</span></span><br><span class="line"><span class="comment">// 提取子串</span></span><br><span class="line"><span class="comment">// 1)public String substring(int beginIndex)</span></span><br><span class="line"><span class="comment">// 2)public String substring(int beginIndex,int endIndex);</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"asdfgxz"</span>);</span><br><span class="line">Stirng str2 = str1.substring(<span class="number">2</span>);     <span class="comment">// str2 = "dfzxc"</span></span><br><span class="line">String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);   <span class="comment">// str3 = "dfz"</span></span><br><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="comment">// 1)public int compareTo(String anotherString);//该方法是对字符串内容按字典顺序进行大小比较,通过返回的整数值指明当前字符串与参数字符串的大小关系.若当前对象比参数大则返回正整数,反之返回负整数,相等返回0.</span></span><br><span class="line"><span class="comment">// 2)public int compareToIgnore(String anotherString)//与compareTo方法相似,但忽略大小写.</span></span><br><span class="line"><span class="comment">// 3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.</span></span><br><span class="line"><span class="comment">// 4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似,但忽略大小写.</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line"><span class="keyword">int</span> a = str1.compareTo(str2);<span class="comment">//a&gt;0</span></span><br><span class="line"><span class="keyword">int</span> b = str1.compareToIgnoreCase(str2);<span class="comment">//b=0</span></span><br><span class="line"><span class="keyword">boolean</span> c = str1.equals(str2);<span class="comment">//c=false</span></span><br><span class="line"><span class="keyword">boolean</span> d = str1.equalsIgnoreCase(str2);<span class="comment">//d=true</span></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="comment">// public String concat(String str)//将参数中的字符串str连接到当前字符串的后面,效果等价于"+".</span></span><br><span class="line">String str = <span class="string">"aa"</span>.concat(<span class="string">"bb"</span>).concat(<span class="string">"cc"</span>); <span class="comment">//相当于String str = "aa"+"bb"+"cc";</span></span><br><span class="line"><span class="comment">// 字符串中单个字符查找</span></span><br><span class="line"><span class="comment">// 1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串,返回字符或子串在当前字符串中从左边起首次出现的位置,若没有出现则返回-1.</span></span><br><span class="line"><span class="comment">// 2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似,区别在于该方法从fromIndex位置向后查找.</span></span><br><span class="line"><span class="comment">// 3)public int lastIndexOf(int ch/String str)//该方法与第一种类似,区别在于该方法从字符串的末尾位置向前查找.</span></span><br><span class="line"><span class="comment">// 4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似,区别于该方法从fromIndex位置向前查找.</span></span><br><span class="line">String str = <span class="string">"I am a good student"</span>;</span><br><span class="line"><span class="keyword">int</span> a = str.indexOf(<span class="string">'a'</span>);<span class="comment">//a = 2</span></span><br><span class="line"><span class="keyword">int</span> b = str.indexOf(<span class="string">"good"</span>);<span class="comment">//b = 7</span></span><br><span class="line"><span class="keyword">int</span> c = str.indexOf(<span class="string">"w"</span>,<span class="number">2</span>);<span class="comment">//c = -1</span></span><br><span class="line"><span class="keyword">int</span> d = str.lastIndexOf(<span class="string">"a"</span>);<span class="comment">//d = 5</span></span><br><span class="line"><span class="keyword">int</span> e = str.lastIndexOf(<span class="string">"a"</span>,<span class="number">3</span>);<span class="comment">//e = 2</span></span><br><span class="line"><span class="comment">// 字符串中字符的大小写转换</span></span><br><span class="line"><span class="comment">// 1)public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串</span></span><br><span class="line"><span class="comment">// 2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asDF"</span>);</span><br><span class="line">String str1 = str.toLowerCase();<span class="comment">//str1 = "asdf"</span></span><br><span class="line">String str2 = str.toUpperCase();<span class="comment">//str2 = "ASDF"</span></span><br><span class="line"><span class="comment">// 字符串中字符的替换</span></span><br><span class="line"><span class="comment">// 1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符,并返回一个新的字符串.</span></span><br><span class="line"><span class="comment">// 2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串,应将新的字符串返回.</span></span><br><span class="line"><span class="comment">// 3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串,应将新的字符串返回.</span></span><br><span class="line">String str = <span class="string">"asdzxcasd"</span>;</span><br><span class="line">String str1 = str.replace(<span class="string">'a'</span>,<span class="string">'g'</span>);<span class="comment">//str1 = "gsdzxcgsd"</span></span><br><span class="line">String str2 = str.replace(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str2 = "fghzxcfgh"</span></span><br><span class="line">String str3 = str.replaceFirst(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str3 = "fghzxcasd"</span></span><br><span class="line">String str4 = str.replaceAll(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str4 = "fghzxcfgh"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="11">
<li><p>抽象类必须要有抽象方法吗？</p>
<ul>
<li>用 abstract 修饰的类就是抽象类,并不是说抽象类中必须有抽象方法,即使一个类中的方法全部实现过,也可以用 abstract 修饰为抽象类,所以抽象类不一定都有抽象方法.</li>
<li>延伸：因为真有一种情况可以将类定义为 static 类型的,那就是内部类.</li>
</ul>
</li>
<li><p>普通类和抽象类有哪些区别？</p>
<ul>
<li><p>1、普通类可以去实例化调用；抽象类不能被实例化,因为它是存在于一种概念而不非具体.</p>
</li>
<li><p>2、普通类和抽象类都可以被继承,但是抽象类被继承后子类必须重写继承的方法,除非自类也是抽象类.</p>
</li>
<li><p>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法.注意,抽象类和普通类的主要有三点区别：</p>
<ul>
<li>1)抽象方法必须为 public 或者 protected(因为如果为 private,则不能被子类继承,子类便无法实现该方法),缺省情况下默认为 public.</li>
<li>2)抽象类不能用来创建对象；</li>
<li>3)如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法.如果子类没有实现父类的抽象方法,则必须将子类也定义为为 abstract 类.</li>
</ul>
</li>
<li><p>在其他方面,抽象类和普通的类并没有区别</p>
</li>
</ul>
</li>
<li><p>抽象类能使用 final 修饰吗？</p>
<ul>
<li>不能,抽象方法是为了继承之后重写方法的,而用 final 修饰的类,无法继承</li>
</ul>
</li>
<li><p>接口和抽象类有什么区别？</p>
<ul>
<li><blockquote>
<p><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
<li>抽象类(abstract class):一个抽象类不能实例化,依然可以在类的实体(直白点就是能在｛｝里面)定义成员变量,成员方法,构造方法等.一个类中含有抽象方法(被 abstract 修饰),那么这个类必须被声明为抽象类(被 abstract 修饰).</li>
<li>接口(interface):接口在 java 中是一个抽象类型,是抽象方法的集合.一个类通过继承接口的方式,从而继承接口的抽象方法.</li>
</ul>
</li>
<li><p>java 中 IO 流分为几种？</p>
<ul>
<li>两种：输入流与输出流</li>
</ul>
</li>
<li><p>BIO、NIO、AIO 有什么区别？</p>
<ul>
<li>IO 的方式通常分为几种，同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO。</li>
<li><blockquote>
<p><a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Files 的常用方法都有哪些？</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>判断 File 对象对应的文件或者目录是否存在若存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除 File 对象对应的文件或者目录若成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>当 File 对象对应的文件不存在时，该方法将新建一个此 File 对象所指定的新文件若创建成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回 File 对象表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>String getPath()</td>
<td>返回 File 对象对应的路径</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>返回 File 对象对应的绝对路径（在 UNIX/Linux 等系统上，如果路径是以正斜线 / 开始的，则这个路径是绝对路径；在 Windows 等系统上，如果路径是从盘符开始的，则这个路径是绝对路径）</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回 File 对象对应目录的父目录，（即返回的目录不包含最后一级子目录）</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断 File 对象对应的文件或者目录是否可读若可读则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断 File 对象对应的文件或者目录是否可写。若可写则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断 File 对象对应的是否是文件（不是目录）若是文件则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断 File 对象对应的是否是目录（不是文件）若是目录则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断 File 对象对应的文件或者目录是否是绝对路径</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>返回 1970 年 1 月 1 日 0 时 0 分 0 秒到文件最好修改时间的毫秒值</td>
</tr>
<tr>
<td>long length()</td>
<td>返回文件内容长度</td>
</tr>
<tr>
<td>String [ ]list()</td>
<td>返回指定目录的全部内容，只列出名称</td>
</tr>
<tr>
<td>File[ ] listFiles()</td>
<td>返回一个包含了 File 对象所有子文件和子目录的 File 数组</td>
</tr>
</tbody></table>
</li>
<li><p>java 如何解决的多重继承</p>
<ul>
<li><a href="https://www.cnblogs.com/chenssy/p/3389027.html" target="_blank" rel="noopener">链接</a> - 1. 接口 - 2. 内部类</li>
</ul>
</li>
</ol>
<h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><ul>
<li><a href="https://blog.csdn.net/dengpeng0419/article/details/47983033" target="_blank" rel="noopener">链接</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院的 java 集合</a></li>
</ul>
<ol>
<li><p>java 容器都有哪些？</p>
<blockquote>
<p>Java 容器类类库的用途是“持有对象”，并将其划分为两个不同的概念：</p>
<p>1）Collection：一个独立元素的序列，这些元素都服从一条或者多条规则。 List 必须按照插入的顺序保存元素，而 set 不能有重复的元素。Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p>
<p>2）Map：一组成对的“键值对”对象，允许你使用键来查找值。</p>
</blockquote>
<pre><code>├Collection
│├List
││├LinkedList
││├ArrayList
││└Vector
││ └Stack
│└Set
│ ├HashSet
│ ├TreeSet
│ └LinkedSet
│
└Map
 ├Hashtable
 ├HashMap
 └WeakHashMap</code></pre></li>
<li><p>Collection 和 Collections 有什么区别？</p>
<ol>
<li><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<blockquote>
<p>Collection</p>
</blockquote>
<pre><code>├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set</code></pre></li>
<li><p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
</li>
</ol>
</li>
<li><p>List、Set、Map 之间的区别是什么？<br><a href="https://blog.csdn.net/SpeedMe/article/details/22398395" target="_blank" rel="noopener">链接 1</a></p>
<p><a href="https://blog.csdn.net/u012102104/article/details/79235938" target="_blank" rel="noopener">链接 2</a></p>
<p>数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型），而<strong>JAVA 集合可以存储和操作数目不固定的一组数据</strong>。</p>
<blockquote>
<p>java 集合的三个主要类型：</p>
<ul>
<li><p>Set (集)</p>
</li>
<li><p>List (列表)</p>
</li>
<li><p>Map(序列)</p>
</li>
</ul>
</blockquote>
<p><em>Java 所有“存储及随机访问一连串对象”的做法，array 是最有效率的一种。</em></p>
<blockquote>
<p>效率高，但容量固定且无法动态改变。<br>array 还有一个缺点是，无法判断其中实际存有多少元素，length 只是告诉我们 array 的容量。</p>
<p>Java 中有一个<strong>Arrays 类，专门用来操作 array</strong>。</p>
</blockquote>
<p>若撰写程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array 不适用。所以就要用到集合。</p>
<blockquote>
<p>集合分类：</p>
<p>Collection：List、Set<br>Map：HashMap、HashTable</p>
</blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td align="center">collection</td>
<td align="center">collection</td>
<td align="center"></td>
</tr>
<tr>
<td>常见实现类</td>
<td align="center">AbstractList(其常用子类有 ArrayList、LinkedList、Vector)</td>
<td align="center">AbstractSet(其常用子类有 HashSet、LinkedHashSet、TreeSet)</td>
<td align="center">HashMap、HashTable、TreeMap</td>
</tr>
<tr>
<td>常见方法</td>
<td align="center">add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td align="center">add( )、remove( )、clear( )、contains( )、size( )</td>
<td align="center">put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td align="center">可重复</td>
<td align="center">不可重复(用<code>equals()</code>判断)</td>
<td align="center">不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td align="center">有序</td>
<td align="center">无序(实际上由 HashCode 决定)</td>
<td align="center"></td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">Vector 线程安全</td>
<td align="center"></td>
<td align="center">Hashtable 线程安全</td>
</tr>
</tbody></table>
</li>
<li><p>HashMap 和 Hashtable 有什么区别？</p>
<p><a href="https://www.jianshu.com/p/5c34133ed372" target="_blank" rel="noopener">链接</a></p>
<ul>
<li>HashMap 不是线程安全的：hashmap 是 map 的接口实现类，是将键映射到值得对象，其中键与值都是对象，并不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。</li>
<li>HashTable 是线程安全 Collection：HashMap 是 HashTable 的轻量级实现，他们都完成了 Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。</li>
<li><strong>区别如下：</strong><ul>
<li>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
<li><del>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</del></li>
<li>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</li>
<li>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</li>
<li><del>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</del></li>
</ul>
</li>
</ul>
</li>
<li><p>如何决定使用 HashMap 还是 TreeMap？</p>
<ul>
<li>TreeMap&lt;K,V&gt;的 Key 值是要求实现 java.lang.Comparable，所以迭代的时候 TreeMap 默认是按照 Key 值升序排序的；TreeMap 的实现也是基于红黑树结构。</li>
<li>HashMap&lt;K,V&gt;的 Key 值实现散列 hashCode(),分布是散列的均匀的，不支持排序；数据结构主要是桶(数组),链表或红黑树。</li>
<li>大多情况下 HashMap 有更好的性能，所以大多不需要排序的时候我们会使用 HashMap.</li>
<li>数组：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为 O(1)；数组的特点是：寻址容易，插入和删除困难。</li>
<li>链表：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达 O（N）。链表的特点是：寻址困难，插入和删除容易。</li>
<li>哈希表：做出一种寻址容易，插入删除也容易的数据结构，哈希表是由数组+链表组成的</li>
</ul>
</li>
<li><p>说一下 HashMap 的实现原理？</p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院</a><br>数组+链表</p>
<blockquote>
<p>创建一个 entry 的数组，其中单个元素是 entry（以键值对的形式存储，而且存储了下个 entry 的地址）</p>
</blockquote>
<ul>
<li>存储:<ul>
<li>当我们 put 的时候，如果 key 存在了，那么新的 value 会代替旧的 value，并且如果 key 存在的情况下，该方法返回的是旧的 value，如果 key 不存在，那么返回 null。</li>
<li>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>说一下 HashSet 的实现原理？</p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashset.html" target="_blank" rel="noopener">极客学院</a></p>
</li>
<li><p>ArrayList 和 LinkedList 的区别是什么？</p>
<p><a href="https://www.jianshu.com/p/e591690afacb" target="_blank" rel="noopener">简书</a></p>
<ul>
<li>ArrayList 是实现了基于动态数组的结构，而 LinkedList 则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率。</li>
</ul>
</li>
<li><p>如何实现数组和 List 之间的转换？</p>
<p>​ <a href="https://blog.csdn.net/zjx2016/article/details/78273192" target="_blank" rel="noopener">csdn</a></p>
<ul>
<li>list 转数组：for，.toArray()</li>
<li>数组转 list：<ul>
<li><code>for(String str : arrays){ list.add(str); }</code></li>
<li><code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arrays));</code></li>
<li><code>List&lt;String&gt; list = Arrays.asList(arrays);</code></li>
<li><code>List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(arrays.length); Collections.addAll(list2, arrays);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList 和 Vector 的区别是什么？</p>
<ol>
<li>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</li>
</ol>
</li>
<li><p>Array 和 ArrayList 有何区别？</p>
<ul>
<li>存储内容比较：<ul>
<li>​ Array 数组可以包含基本类型和对象类型，</li>
<li>​ ArrayList 却只能包含对象类型。</li>
</ul>
</li>
</ul>
<blockquote>
<p>但是需要注意的是：Array 数组在存放的时候一定是同种类型的元素。ArrayList 就不一定了，因为 ArrayList 可以存储 Object。</p>
</blockquote>
<ul>
<li>空间大小比较：<ul>
<li>它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。</li>
<li>​ ArrayList 的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。</li>
</ul>
</li>
</ul>
</li>
<li><p>在 Queue 中 poll()和 remove()有什么区别？</p>
<p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">比较全的</a></p>
<p><strong>Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构</strong></p>
<p><strong>remove</strong> 移除并返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException 异常</p>
<p><strong>poll</strong> 移除并返问队列头部的元素 如果队列为空，则返回 null</p>
</li>
<li><p>哪些集合类是线程安全的？</p>
<p><a href="https://blog.csdn.net/laowang2915/article/details/73648208" target="_blank" rel="noopener">链接</a></p>
<p><a href="https://blog.csdn.net/lixiaobuaa/article/details/79689338" target="_blank" rel="noopener">链接 2</a></p>
<p>Vector：就比 Arraylist 多了个同步化机制（线程安全）。</p>
<p>Hashtable：就比 Hashmap 多了个线程安全。</p>
<p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<p>Stack：栈，也是线程安全的，继承于 Vector。</p>
</li>
<li><p>迭代器 Iterator 是什么？</p>
<ul>
<li>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<a href="https://www.nowcoder.com/questionTerminal/8863f297b1fc4bbca6de95528b6051e1" target="_blank" rel="noopener">链接</a></li>
<li>对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。<a href="https://blog.csdn.net/qq_33642117/article/details/52039691" target="_blank" rel="noopener">链接</a></li>
</ul>
</li>
<li><p>Iterator 怎么使用？有什么特点？<a href="https://blog.csdn.net/qq_20916555/article/details/51292063" target="_blank" rel="noopener">链接</a></p>
<ul>
<li>Java 中使用 Iterator 来遍历集合元素，Iterator 遍历集合元素有以下几个特点:<ul>
<li>Iterator 遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出 ConcurrentModificationEception 的异常。</li>
<li>Iterator 遍历集合元素的过程中可以通过 remove 方法来移除集合中的元素。</li>
<li>Iterator 必须依附某个 Collection 对象而存在，Iterator 本身不具有装载数据对象的功能。</li>
<li>Iterator.remove 方法删除的是上一次 Iterator.next()方法返回的对象。</li>
<li>强调以下 next（）方法，该方法通过游标指向的形式返回 Iterator 下一个元素。</li>
</ul>
</li>
<li><strong>Iterator 的常用方法</strong>:<ul>
<li>boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回 true</li>
<li>Object next(); 返回迭代器中下一个元素</li>
<li>void remove() ; 删除集合里上一个 next 方法调用的时候返回的对象元素</li>
<li>void forEachRemaining(Consumer action) ;使用 Lambdda 表达式的形式输出 Iterator 中所以的元素。注意该方法其实是间接调用 next()方法进行遍历，所以再次是 next（）方法的时候 Iterator 中的对象已经被遍历完了。</li>
</ul>
</li>
</ul>
</li>
<li><p>Iterator 和 ListIterator 有什么区别？<a href="https://blog.csdn.net/longshengguoji/article/details/41551491" target="_blank" rel="noopener">link</a></p>
<p>一．相同点</p>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。</li>
</ul>
<p>二．不同点</p>
<ol>
<li><p>使用范围不同，Iterator 可以应用于所有的集合，Set、List 和 Map 和这些集合的子类型。而 ListIterator 只能用于 List 及其子类型。</p>
</li>
<li><p>ListIterator 有 add 方法，可以向 List 中添加对象，而 Iterator 不能。</p>
</li>
<li><p>ListIterator 和 Iterator 都有 hasNext()和 next()方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious()和 previous()方法，可以实现逆向（顺序向前）遍历。Iterator 不可以。</p>
</li>
<li><p>ListIterator 可以定位当前索引的位置，nextIndex()和 previousIndex()可以实现。Iterator 没有此功能。</p>
</li>
<li><p>都可实现删除操作，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iterator 仅能遍历，不能修改。</p>
</li>
</ol>
</li>
<li><p>怎么确保一个集合不能被修改？<a href="https://blog.csdn.net/syilt/article/details/90548237" target="_blank" rel="noopener">link</a></p>
<ul>
<li><strong>利用 Collections 和 Guava 提供的类可实现的不可变对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collections</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">    map  = Collections.unmodifiableMap(map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Guava</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 这样被初始化之后 list是不能被改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list); <span class="comment">// 这样被初始化之后set是不能被改变的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="number">222</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//guava中的map的写法有点不一样如下：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder().put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><ol>
<li><p>并行和并发有什么区别？<a href="https://www.jianshu.com/p/b11e251d3dc7" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>并发:一个处理器同时处理多个任务。</p>
</li>
<li><p>并行:多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生</p>
</blockquote>
</li>
</ul>
</li>
<li><p>线程和进程的区别？<a href="https://www.cnblogs.com/WuXuanKun/p/6259965.html" target="_blank" rel="noopener">link</a></p>
<ul>
<li>进程代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个进程可以包括多个线程。</li>
<li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存.</li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述。</strong></li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong></li>
<li>几乎任何的操作系统都支持运行多个任务，通常一个任务就是一个程序，而一个程序就是一个进程。当一个进程运行时，内部可能包括多个顺序执行流，每个顺序执行流就是一个线程。</li>
<li>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。</li>
</ul>
</li>
<li><p>守护线程是什么？<a href="https://blog.csdn.net/shimiso/article/details/8964414" target="_blank" rel="noopener">link</a></p>
<ul>
<li>在 Java 中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</li>
<li>任何一个守护线程都是整个 JVM 中所有非守护线程的保姆：<ul>
<li>只要当前 JVM 实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着 JVM 一同结束工作。</li>
</ul>
</li>
<li>User 和 Daemon 两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread 已经全部退出运行了，只剩下 Daemon Thread 存在了，虚拟机也就退出了。</li>
</ul>
</li>
<li><p>创建线程有哪几种方式？<a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>三种：继承 Thread 类创建线程类/通过 Runnable 接口创建线程类/通过 Callable 和 Future 创建线程</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一、继承Thread类创建线程类</span></span><br><span class="line"><span class="comment">//（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</span></span><br><span class="line"><span class="comment">//（2）创建Thread子类的实例，即创建了线程对象。</span></span><br><span class="line"><span class="comment">//（3）调用线程对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		System.out.println(getName()+<span class="string">"  "</span>+i);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"  : "</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">				<span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二、通过Runnable接口创建线程类</span></span><br><span class="line"><span class="comment">//（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span></span><br><span class="line"><span class="comment">//（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</span></span><br><span class="line"><span class="comment">//（3）调用线程对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RunnableThreadTest rtt = <span class="keyword">new</span> RunnableThreadTest();</span><br><span class="line">				<span class="keyword">new</span> Thread(rtt,<span class="string">"新线程1"</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(rtt,<span class="string">"新线程2"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//三、通过Callable和Future创建线程</span></span><br><span class="line"><span class="comment">//（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</span></span><br><span class="line"><span class="comment">//（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</span></span><br><span class="line"><span class="comment">//（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</span></span><br><span class="line"><span class="comment">//（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</span><br><span class="line">		FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建线程的三种方式的对比:</p>
<ul>
<li>采用实现 Runnable、Callable 接口的方式创见多线程时<ul>
<li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法</li>
</ul>
</li>
<li>使用继承 Thread 类的方式创建多线程时<ul>
<li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li>
<li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>说一下 runnable 和 callable 有什么区别？<a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">link</a></p>
<ul>
<li>Callable 规定的方法是 call(),Runnable 规定的方法是 run()</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值(是 void)</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。<br>Callable 接口也是位于 java.util.concurrent 包中。</li>
</ul>
</li>
<li><p>线程有哪些状态？</p>
<ul>
<li>在 Java 当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</li>
<li>第一是创建状态。在生成线程对象，并没有调用该对象的 start 方法，这是线程处于创建状态；</li>
<li>第二是就绪状态。当调用了线程对象的 start 方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态</li>
<li>第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。</li>
<li>第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend 等方法都可以导致线程阻塞。</li>
<li>第五是死亡状态。如果一个线程的 run 方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪状态。</li>
</ul>
</li>
<li><p>sleep() 和 wait() 有什么区别？<a href="https://www.zhihu.com/question/23328075" target="_blank" rel="noopener">link</a></p>
<ul>
<li>“sleep 是 Thread 类的方法,wait 是 Object 类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
</li>
<li><p>notify()和 notifyAll()有什么区别？<a href="https://www.zhihu.com/question/37601861" target="_blank" rel="noopener">link</a></p>
<ul>
<li>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify 只会唤醒一个线程。</li>
</ul>
</li>
<li><p>线程的 run()和 start()有什么区别？</p>
<ol>
<li>start() 可以启动一个新线程，run()不能</li>
<li>start()不能被重复调用，run()可以</li>
<li>start()中的 run 代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用 run 方法必须等待其代码全部执行完才能继续执行下面的代码。</li>
<li>start() 实现了多线程，run()没有实现多线程。</li>
</ol>
</li>
<li><p>创建线程池有哪几种方式？<a href="https://blog.csdn.net/u011974987/article/details/51027795" target="_blank" rel="noopener">link</a></p>
<ul>
<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ul>
</li>
<li><p>线程池都有哪些状态？<a href="https://blog.csdn.net/L_kanglin/article/details/57411851" target="_blank" rel="noopener">link</a></p>
</li>
</ol>
<pre><code>![线程池的状态.jpg](..\pic\java的运行流程.jpg)

pic\java的运行流程.jpg

1、RUNNING

​    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
​    (2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

2、 SHUTDOWN

​    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
​    (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。

3、STOP

​    1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
​    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。

4、TIDYING

​    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
​    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。
​    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。

5、 TERMINATED

​    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。

​    (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</code></pre><ol start="12">
<li><p>线程池中 submit()和 execute()方法有什么区别？<a href="https://blog.csdn.net/guhong5153/article/details/71247266" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>execute 提交的方式只能提交一个 Runnable 的对象，且该方法的返回值是 void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过 ThreadFactory 主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</p>
</li>
<li><p>submit 提交的方式</p>
<ul>
<li><p><t> Future<t> submit(Callable<t> task);而 Callable 接口中是一个有返回值的 call 方法。如果在线程的执行过程中发生了异常，get 会获取到异常的信息。</t></t></t></p>
</li>
<li><p>Future&lt;?&gt; submit(Runnable task);也可以提交一个 Runable 接口的对象，这样当调用 get 方法的时候，如果线程执行成功会直接返回 null，如果线程执行异常会返回异常的信息</p>
</li>
<li><p><t> Future<t> submit(Runnable task, T result);除了 task 之外还有一个 result 对象，</t></t></p>
<p>当线程正常结束的时候调用 Future 的 get 方法会返回 result 对象，当线程抛出异常的时候会获取到对应的异常的信息。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 java 程序中怎么保证多线程的运行安全？</p>
</li>
<li><p>多线程锁的升级原理是什么？</p>
</li>
<li><p>什么是死锁？</p>
</li>
<li><p>怎么防止死锁？</p>
</li>
<li><p>ThreadLocal 是什么？有哪些使用场景？</p>
</li>
<li><p>说一下 synchronized 底层实现原理？</p>
</li>
<li><p>synchronized 和 volatile 的区别是什么？</p>
</li>
<li><p>synchronized 和 Lock 有什么区别？</p>
</li>
<li><p>synchronized 和 ReentrantLock 区别是什么？</p>
</li>
<li><p>说一下 atomic 的原理？</p>
</li>
</ol>
<h2 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h2><ol>
<li><p>什么是反射？<a href="<https://www.zhihu.com/question/24304289>">link</a></p>
<p><img src="..%5Cpic%5Cjava%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="java的运行流程.jpg"></p>
<p><strong><a href="[https://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F](https://www.sczyh30.com/posts/Java/java-reflection-1/#一、回顾：什么是反射？)">深入解析 Java 反射（1） - 基础</a></strong></p>
<ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
</ul>
</li>
<li><p>什么是 java 序列化？什么情况下需要序列化？<a href="https://blog.csdn.net/fan2012huan/article/details/49871163" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>序列化简单来说就<strong>保存对象在内存中的状态</strong>也可以说是<strong>实例化变量</strong>。这是 Java 提供的用来<strong>保存 Object state</strong>，一种保存对象状态的机制。只有实现了 serializable 接口的类的对象才能被实例化。</p>
</li>
<li><p>1 当你想把内存中的对象写入到硬盘时</p>
<p>​ 2 当你想用套接字在网络上传输对象时</p>
<p>​ 3 当你想通过 RMI 调用对象时</p>
<p>​ （RMI 是什么东西？）：RMI 总结来说就是远程调用对象，在一个 jvm 上调用另一个 jvm 的对象。</p>
</li>
</ul>
</li>
<li><p>动态代理是什么？有哪些应用？</p>
</li>
<li><p>怎么实现动态代理？</p>
</li>
</ol>
<h2 id="五、对象拷贝link"><a href="#五、对象拷贝link" class="headerlink" title="五、对象拷贝link"></a>五、对象拷贝<a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">link</a></h2><ol>
<li><p>为什么要使用克隆？</p>
<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了</p>
</li>
<li><p>如何实现对象克隆？</p>
<p><strong>浅克隆(ShallowClone)</strong>和<strong>深克隆(DeepClone)</strong></p>
</li>
<li><p>深拷贝和浅拷贝区别是什么？</p>
<ul>
<li>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。(在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。)</li>
<li>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。(在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。)</li>
</ul>
</li>
</ol>
<h2 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h2><ol>
<li>jsp 和 servlet 有什么区别？</li>
<li>jsp 有哪些内置对象？作用分别是什么？</li>
<li>说一下 jsp 的 4 种作用域？</li>
<li>session 和 cookie 有什么区别？</li>
<li>说一下 session 的工作原理？</li>
<li>如果客户端禁止 cookie 能实现 session 还能用吗？</li>
<li>spring mvc 和 struts 的区别是什么？</li>
<li>如何避免 sql 注入？</li>
<li>什么是 XSS 攻击,如何避免？</li>
<li>什么是 CSRF 攻击,如何避免？</li>
</ol>
<h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h2><blockquote>
<p>Java 的异常处理是通过 5 个关键字来实现的：try，catch，throw，throws，finally。</p>
</blockquote>
<ol>
<li>throw 和 throws 的区别？</li>
<li>final、finally、finalize 有什么区别？</li>
<li>try-catch-finally 中哪个部分可以省略？</li>
<li>try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？</li>
<li>常见的异常类有哪些？</li>
</ol>
<h2 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h2><ol>
<li>http 响应码 301 和 302 代表的是什么？有什么区别？</li>
<li>forward 和 redirect 的区别？</li>
<li>简述 tcp 和 udp 的区别？</li>
<li>tcp 为什么要三次握手,两次不行吗？为什么？</li>
<li>说一下 tcp 粘包是怎么产生的？</li>
<li>OSI 的七层模型都有哪些？</li>
<li>get 和 post 请求有哪些区别？</li>
<li>如何实现跨域？</li>
<li>说一下 JSONP 实现原理？</li>
</ol>
<h2 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h2><ol>
<li>说一下你熟悉的设计模式？</li>
<li>简单工厂和抽象工厂有什么区别？</li>
</ol>
<h2 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring/Spring MVC"></a>十、Spring/Spring MVC</h2><ol>
<li>为什么要使用 spring？</li>
<li>解释一下什么是 aop？</li>
<li>解释一下什么是 ioc？</li>
<li>spring 有哪些主要模块？</li>
<li>spring 常用的注入方式有哪些？</li>
<li>spring 中的 bean 是线程安全的吗？</li>
<li>spring 支持几种 bean 的作用域？</li>
<li>spring 自动装配 bean 有哪些方式？</li>
<li>spring 事务实现方式有哪些？</li>
<li>说一下 spring 的事务隔离？</li>
<li>说一下 spring mvc 运行流程？</li>
<li>spring mvc 有哪些组件？</li>
<li>@RequestMapping 的作用是什么？</li>
<li>@Autowired 的作用是什么？</li>
</ol>
<h2 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot/Spring Cloud"></a>十一、Spring Boot/Spring Cloud</h2><ol>
<li>什么是 spring boot？</li>
<li>为什么要用 spring boot？</li>
<li>spring boot 核心配置文件是什么？</li>
<li>spring boot 配置文件有哪几种类型？它们有什么区别？</li>
<li>spring boot 有哪些方式可以实现热部署？</li>
<li>jpa 和 hibernate 有什么区别？</li>
<li>什么是 spring cloud？</li>
<li>spring cloud 断路器的作用是什么？</li>
<li>spring cloud 的核心组件有哪些？</li>
</ol>
<h2 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a>十二、Hibernate</h2><ol>
<li>为什么要使用 hibernate？</li>
<li>什么是 ORM 框架？</li>
<li>hibernate 中如何在控制台查看打印的 sql 语句？</li>
<li>hibernate 有几种查询方式？</li>
<li>hibernate 实体类可以被定义为 final 吗？</li>
<li>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</li>
<li>hibernate 是如何工作的？</li>
<li>get()和 load()的区别？</li>
<li>说一下 hibernate 的缓存机制？</li>
<li>hibernate 对象有哪些状态？</li>
<li>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</li>
<li>hibernate 实体类必须要有无参构造函数吗？为什么？</li>
</ol>
<h2 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a>十三、Mybatis</h2><ol>
<li>mybatis 中 #{}和 ${}的区别是什么？</li>
<li>mybatis 有几种分页方式？</li>
<li>RowBounds 是一次性查询全部结果吗？为什么？</li>
<li>mybatis 逻辑分页和物理分页的区别是什么？</li>
<li>mybatis 是否支持延迟加载？延迟加载的原理是什么？</li>
<li>说一下 mybatis 的一级缓存和二级缓存？</li>
<li>mybatis 和 hibernate 的区别有哪些？</li>
<li>mybatis 有哪些执行器(Executor)？</li>
<li>mybatis 分页插件的实现原理是什么？</li>
<li>mybatis 如何编写一个自定义插件？</li>
</ol>
<h2 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h2><ol>
<li>rabbitmq 的使用场景有哪些？</li>
<li>rabbitmq 有哪些重要的角色？</li>
<li>rabbitmq 有哪些重要的组件？</li>
<li>rabbitmq 中 vhost 的作用是什么？</li>
<li>rabbitmq 的消息是怎么发送的？</li>
<li>rabbitmq 怎么保证消息的稳定性？</li>
<li>rabbitmq 怎么避免消息丢失？</li>
<li>要保证消息持久化成功的条件有哪些？</li>
<li>rabbitmq 持久化有什么缺点？</li>
<li>rabbitmq 有几种广播类型？</li>
<li>rabbitmq 怎么实现延迟消息队列？</li>
<li>rabbitmq 集群有什么用？</li>
<li>rabbitmq 节点的类型有哪些？</li>
<li>rabbitmq 集群搭建需要注意哪些问题？</li>
<li>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</li>
<li>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</li>
<li>rabbitmq 对集群节点停止顺序有要求吗？</li>
</ol>
<h2 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h2><ol>
<li>kafka 可以脱离 zookeeper 单独使用吗？为什么？</li>
<li>kafka 有几种数据保留的策略？</li>
<li>kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？</li>
<li>什么情况会导致 kafka 运行变慢？</li>
<li>使用 kafka 集群需要注意什么？</li>
</ol>
<h2 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h2><ol>
<li>zookeeper 是什么？</li>
<li>zookeeper 都有哪些功能？</li>
<li>zookeeper 有几种部署模式？</li>
<li>zookeeper 怎么保证主从节点的状态同步？</li>
<li>集群中为什么要有主节点？</li>
<li>集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？</li>
<li>说一下 zookeeper 的通知机制？</li>
</ol>
<h2 id="十七、MySql"><a href="#十七、MySql" class="headerlink" title="十七、MySql"></a>十七、MySql</h2><ol>
<li>数据库的三范式是什么？</li>
<li>一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？</li>
<li>如何获取当前数据库版本？</li>
<li>说一下 ACID 是什么？</li>
<li>char 和 varchar 的区别是什么？</li>
<li>float 和 double 的区别是什么？</li>
<li>mysql 的内连接、左连接、右连接有什么区别？</li>
<li>mysql 索引是怎么实现的？</li>
<li>怎么验证 mysql 的索引是否满足需求？</li>
<li>说一下数据库的事务隔离？</li>
<li>说一下 mysql 常用的引擎？</li>
<li>说一下 mysql 的行锁和表锁？</li>
<li>说一下乐观锁和悲观锁？</li>
<li>mysql 问题排查都有哪些手段？</li>
<li>如何做 mysql 的性能优化？</li>
</ol>
<h2 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h2><ol>
<li>redis 是什么？都有哪些使用场景？</li>
<li>redis 有哪些功能？</li>
<li>redis 和 memecache 有什么区别？</li>
<li>redis 为什么是单线程的？</li>
<li>什么是缓存穿透？怎么解决？</li>
<li>redis 支持的数据类型有哪些？</li>
<li>redis 支持的 java 客户端都有哪些？</li>
<li>jedis 和 redisson 有哪些区别？</li>
<li>怎么保证缓存和数据库数据的一致性？</li>
<li>redis 持久化有几种方式？<br>189.redis 怎么实现分布式锁？</li>
<li>redis 分布式锁有什么缺陷？</li>
<li>redis 如何做内存优化？</li>
<li>redis 淘汰策略有哪些？</li>
<li>redis 常见的性能问题有哪些？该如何解决？</li>
</ol>
<h2 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h2><ol>
<li>说一下 jvm 的主要组成部分？及其作用？</li>
<li>说一下 jvm 运行时数据区？</li>
<li>说一下堆栈的区别？</li>
<li>队列和栈是什么？有什么区别？</li>
<li>什么是双亲委派模型？</li>
<li>说一下类加载的执行过程？</li>
<li>怎么判断对象是否可以被回收？</li>
<li>java 中都有哪些引用类型？</li>
<li>说一下 jvm 有哪些垃圾回收算法？</li>
<li>说一下 jvm 有哪些垃圾回收器？</li>
<li>详细介绍一下 CMS 垃圾回收器？</li>
<li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li>
<li>简述分代垃圾回收器是怎么工作的？</li>
<li>说一下 jvm 调优的工具？</li>
<li>常用的 jvm 调优的参数都有哪些？</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/blog/post/66c016fb.html</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-说一下-jvm-的主要组成部分？及其作用？"><a href="#1-说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="1. 说一下 jvm 的主要组成部分？及其作用？"></a>1. 说一下 jvm 的主要组成部分？及其作用？</h2><ul>
<li><p>jvm的主要组成有，类加载器子系统，运行时数据区，执行引擎，本地库接口，垃圾收集模块；</p>
</li>
<li><p>首先通过类加载器（ClassLoader）会把 Java 字节码加载到内存中，</p>
</li>
<li><p>运行时数据区（Runtime Data Area）存储被加载的字节码，</p>
</li>
<li><p>而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，</p>
</li>
<li><p>而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
</li>
<li><p>垃圾收集模块，清除内存中多余的内容，回收可重复使用的内存空间。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-说一下-jvm-运行时数据区？"><a href="#2-说一下-jvm-运行时数据区？" class="headerlink" title="2. 说一下 jvm 运行时数据区？"></a>2. 说一下 jvm 运行时数据区？</h2><ul>
<li><p>运行时数据区，是Java程序运行时数据存储的区域，主要包括方法区、Java堆、虚拟机栈、本地方法栈、程序计数器、直接内存等；</p>
</li>
<li><p>方法区，存储运行时的常量池，已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的；</p>
</li>
<li><p>Java堆，存储对象实例，被所有线程共享的；</p>
</li>
<li><p>虚拟机栈，存放方法运行时所需的数据，称为栈帧；</p>
</li>
<li><p>本地方法栈，存储Java调用本地方法所需的数据；</p>
</li>
<li><p>程序计数器，记录当前线程所执行到的字节码的行号；</p>
</li>
</ul>
<h2 id="3-说一下堆栈的区别？"><a href="#3-说一下堆栈的区别？" class="headerlink" title="3. 说一下堆栈的区别？"></a>3. 说一下堆栈的区别？</h2><ul>
<li><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。 </p>
</li>
<li><p>共享性：堆是线程共享的，栈是线程私有的。 </p>
</li>
<li><p>空间大小：堆大小远远大于栈。</p>
</li>
</ul>
<h2 id="4-队列和栈是什么？有什么区别？"><a href="#4-队列和栈是什么？有什么区别？" class="headerlink" title="4. 队列和栈是什么？有什么区别？"></a>4. 队列和栈是什么？有什么区别？</h2><ul>
<li><p>队列和栈都是被用来预存储数据的。</p>
</li>
<li><p>队列允许先进先出检索元素，但也有例外的情况。</p>
</li>
<li><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
</li>
</ul>
<h2 id="5-什么是双亲委派模型？"><a href="#5-什么是双亲委派模型？" class="headerlink" title="5. 什么是双亲委派模型？"></a>5. 什么是双亲委派模型？</h2><ul>
<li><p>在介绍双亲委派模型之前先说下类加载器。<br>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。<br>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
</li>
<li><p>类加载器分类</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； </li>
<li>扩展类加载器（Extension ClassLoader），负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader），负责加载用户类路径（classpath）上的指定类库；</li>
<li>自定义类加载器；</li>
</ul>
</li>
<li><p>双亲委派模型：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，<br>而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，<br>这样所有的加载请求都会被传送到顶层的启动类加载器中，<br>只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，<br>子加载器才会尝试去加载类。</p>
</li>
</ul>
<h2 id="6-说一下类加载的执行过程？"><a href="#6-说一下类加载的执行过程？" class="headerlink" title="6. 说一下类加载的执行过程？"></a>6. 说一下类加载的执行过程？</h2><ul>
<li><p>类装载分为以下 5 个步骤，加载、检查、准备、解析、初始化；</p>
</li>
<li><p>加载：根据查找路径找到相应的 class 文件然后导入；</p>
</li>
<li><p>检查：检查加载的 class 文件的正确性；</p>
</li>
<li><p>准备：给类中的静态变量分配内存空间；</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p>
</li>
<li><p>初始化：对静态变量和静态代码块执行初始化工作。</p>
</li>
</ul>
<h2 id="7-怎么判断对象是否可以被回收？"><a href="#7-怎么判断对象是否可以被回收？" class="headerlink" title="7. 怎么判断对象是否可以被回收？"></a>7. 怎么判断对象是否可以被回收？</h2><ul>
<li><p>主要有两种方法，引用计数法和可达性分析；</p>
</li>
<li><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p>
</li>
<li><p>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
</li>
</ul>
<h2 id="8-java-中都有哪些引用类型？"><a href="#8-java-中都有哪些引用类型？" class="headerlink" title="8. java 中都有哪些引用类型？"></a>8. java 中都有哪些引用类型？</h2><ul>
<li><p>强引用：发生 gc 的时候不会被回收。</p>
</li>
<li><p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
</li>
<li><p>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
</li>
<li><p>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
</li>
</ul>
<h2 id="9-说一下-jvm-有哪些垃圾回收算法？"><a href="#9-说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="9. 说一下 jvm 有哪些垃圾回收算法？"></a>9. 说一下 jvm 有哪些垃圾回收算法？</h2><ul>
<li><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片;</p>
</li>
<li><p>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存;</p>
</li>
<li><p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半;</p>
</li>
<li><p>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p>
</li>
</ul>
<h2 id="10-说一下-jvm-有哪些垃圾回收器？"><a href="#10-说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="10. 说一下 jvm 有哪些垃圾回收器？"></a>10. 说一下 jvm 有哪些垃圾回收器？</h2><ul>
<li><p>Serial：最早的单线程串行垃圾回收器;</p>
</li>
<li><p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案;</p>
</li>
<li><p>ParNew：是 Serial 的多线程版本;</p>
</li>
<li><p>Parallel: 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量;</p>
</li>
<li><p>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法;</p>
</li>
<li><p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统;</p>
</li>
<li><p>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
</li>
</ul>
<h2 id="11-详细介绍一下-CMS-垃圾回收器？"><a href="#11-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="11. 详细介绍一下 CMS 垃圾回收器？"></a>11. 详细介绍一下 CMS 垃圾回收器？</h2><ul>
<li><p>CMS 是英文 Concurrent Mark-Sweep 的简称，</p>
</li>
<li><p>是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。</p>
</li>
<li><p>对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
</li>
<li><p>在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
</li>
<li><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，</p>
</li>
<li><p>当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
</li>
</ul>
<h2 id="12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><ul>
<li><p>回收器</p>
<ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge </li>
<li>老年代回收器：Serial Old、Parallel Old、CMS </li>
<li>整堆回收器：G1 </li>
</ul>
</li>
<li><p>两者的区别</p>
<ul>
<li>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</li>
<li>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li>
</ul>
</li>
</ul>
<h2 id="13-简述分代垃圾回收器是怎么工作的？"><a href="#13-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="13. 简述分代垃圾回收器是怎么工作的？"></a>13. 简述分代垃圾回收器是怎么工作的？</h2><ul>
<li><p>分代回收器有两个分区：老年代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
</li>
<li><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
</li>
<li><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
</li>
<li><p>老年代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
</li>
</ul>
<h2 id="14-说一下-jvm-调优的工具？"><a href="#14-说一下-jvm-调优的工具？" class="headerlink" title="14. 说一下 jvm 调优的工具？"></a>14. 说一下 jvm 调优的工具？</h2><ul>
<li><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下；</p>
</li>
<li><p>window下常用的是 jconsole 和 jvisualvm 这两款视图监控工具；</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控； </li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
</li>
<li><p>Linux下常用的有jps，jstat，jmap，jhat，jstack，jinfo；</p>
<ul>
<li>jps：虚拟机进程状况工具；</li>
<li>jstat：虚拟机统计信息监视工具；</li>
<li>jmap：Java内存印象工具；</li>
<li>jhat：虚拟机堆转储快照分析工具；</li>
<li>jstack：Java堆栈跟踪工具；</li>
<li>jinfo：Java配置信息工具。</li>
</ul>
</li>
</ul>
<h2 id="15-常用的-jvm-调优的参数都有哪些？"><a href="#15-常用的-jvm-调优的参数都有哪些？" class="headerlink" title="15. 常用的 jvm 调优的参数都有哪些？"></a>15. 常用的 jvm 调优的参数都有哪些？</h2><ul>
<li><p>-Xms2g：初始化推大小为 2g； -Xmx2g：堆最大内存为 2g；</p>
</li>
<li><p>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p>
</li>
<li><p>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p>
</li>
<li><p>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+PrintGC：开启打印 gc 信息；</p>
</li>
<li><p>-XX:+PrintGCDetails：打印 gc 详细信息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/blog/post/bae4ff13.html</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-redis-是什么？都有哪些使用场景？"><a href="#1-redis-是什么？都有哪些使用场景？" class="headerlink" title="1. redis 是什么？都有哪些使用场景？"></a>1. redis 是什么？都有哪些使用场景？</h2><ul>
<li><p>redis 是一个开源的，使用 C 语言编写，支持网络，可基于内存，可持久化的日志型、键值对数据库，并提供多种语言的API接口；</p>
</li>
<li><p>redis 使用场景主要有三种</p>
<ul>
<li>高并发的数据读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求的高的数据</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-redis-有哪些功能？"><a href="#2-redis-有哪些功能？" class="headerlink" title="2. redis 有哪些功能？"></a>2. redis 有哪些功能？</h2><ul>
<li>数据缓存</li>
<li>分布式锁</li>
<li>支持数据持久化</li>
<li>支持事物</li>
<li>支持消息队列</li>
</ul>
<h2 id="3-redis-和-memcache-有什么区别？"><a href="#3-redis-和-memcache-有什么区别？" class="headerlink" title="3. redis 和 memcache 有什么区别？"></a>3. redis 和 memcache 有什么区别？</h2><ul>
<li>存储数据类型，memcahe 存储的所有数据均为字符串，redis 支持更丰富的数据类型；</li>
<li>响应速度，redis 快于 memcache；</li>
<li>数据持久化， redis 支持，而 memcache 不支持；</li>
<li>redis 是单进程单线程的，memcache 是单进程多线程的。</li>
</ul>
<h2 id="4-redis-为什么是单线程的？"><a href="#4-redis-为什么是单线程的？" class="headerlink" title="4. redis 为什么是单线程的？"></a>4. redis 为什么是单线程的？</h2><ul>
<li>redis 处理用户的网络请求是单线程处理，在执行数据持久化时就不是单线程了，并且从 redis4.0 开始某些操作支持多线程；</li>
<li>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；</li>
<li>既然单线程容易实现，而且CPU不会成为瓶颈，多线程方案会加重系统的复杂性，因此采用单线程方案。</li>
</ul>
<h2 id="5-什么是缓存穿透？怎么解决？"><a href="#5-什么是缓存穿透？怎么解决？" class="headerlink" title="5. 什么是缓存穿透？怎么解决？"></a>5. 什么是缓存穿透？怎么解决？</h2><ul>
<li><p>缓存穿透，</p>
<ul>
<li>查询一个一定不存在的数据，由于缓存不命中时需要从数据库中查询，查不到数据就不写入缓存；</li>
<li>这将导致这个不存在的数据，每次请求都要到数据库去查询，造成缓存穿透。</li>
</ul>
</li>
<li><p>解决方案，</p>
<ul>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，</li>
<li>设置它的过期时间很短，最长不超过五分钟。</li>
</ul>
</li>
</ul>
<h2 id="6-redis-支持的数据类型有哪些？"><a href="#6-redis-支持的数据类型有哪些？" class="headerlink" title="6. redis 支持的数据类型有哪些？"></a>6. redis 支持的数据类型有哪些？</h2><ul>
<li><p>redis 支持五种数据类型，string 字符串， list 列表， hash 哈希， set 集合， zset 有序集合；</p>
</li>
<li><p>String，</p>
<ul>
<li>一个 key 对应一个 value；</li>
<li>是二进制安全的，可以包含任何数据；</li>
<li>string 类型的值最大能存储 512MB；</li>
</ul>
</li>
<li><p>List，</p>
<ul>
<li>简单的字符串列表，按照插入顺序排序；</li>
<li>可以在列表的头部或尾部插入数据；</li>
</ul>
</li>
<li><p>Hash，</p>
<ul>
<li>一个 key 对应一个 键值对集合；</li>
<li>集合是 string 类型的 field 和 value 的映射表，可以存储对象；</li>
</ul>
</li>
<li><p>Set，</p>
<ul>
<li>string 的无序集合；</li>
<li>通过哈希表实现，因此增删改查时间复杂度是O(1);</li>
</ul>
</li>
<li><p>Zset</p>
<ul>
<li>string 类型的数据集合，但是不允许重复的值；</li>
<li>每个元素都关联一个 double 类型的分数，根据分数来排序，元素不能有重复值，但是分数可以重复。</li>
</ul>
</li>
</ul>
<h2 id="7-redis-支持的-java-客户端都有哪些？"><a href="#7-redis-支持的-java-客户端都有哪些？" class="headerlink" title="7. redis 支持的 java 客户端都有哪些？"></a>7. redis 支持的 java 客户端都有哪些？</h2><ul>
<li>Redisson、Jedis、lettuce</li>
</ul>
<h2 id="8-jedis-和-redisson-有哪些区别？"><a href="#8-jedis-和-redisson-有哪些区别？" class="headerlink" title="8. jedis 和 redisson 有哪些区别？"></a>8. jedis 和 redisson 有哪些区别？</h2><ul>
<li><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p>
</li>
<li><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</p>
</li>
<li><p>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</li>
</ul>
<h2 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9. 怎么保证缓存和数据库数据的一致性？"></a>9. 怎么保证缓存和数据库数据的一致性？</h2><ul>
<li><p>合理设置缓存的过期时间，保证最终一致性；</p>
<ul>
<li>我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可；</li>
<li>也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存；</li>
</ul>
</li>
<li><p>先删除缓存，再更新数据库，延时一定时间再次删除缓存；</p>
</li>
<li><p>先更新数据库，再删缓存；</p>
</li>
<li><p>针对删除缓存失败的情况，增加重试机制；</p>
<ul>
<li>（1）更新数据库数据</li>
<li>（2）数据库会将操作信息写入binlog日志当中</li>
<li>（3）订阅程序提取出所需要的数据以及key</li>
<li>（4）另起一段非业务代码，获得该信息</li>
<li>（5）尝试删除缓存操作，发现删除失败</li>
<li>（6）将这些信息发送至消息队列</li>
<li>（7）重新从消息队列中获得该数据，重试操作。</li>
</ul>
</li>
</ul>
<h2 id="10-redis-持久化有几种方式？"><a href="#10-redis-持久化有几种方式？" class="headerlink" title="10. redis 持久化有几种方式？"></a>10. redis 持久化有几种方式？</h2><ul>
<li><p>Redis 的持久化有两种方式；</p>
</li>
<li><p>RDB（Redis Database），指定的时间间隔能对你的数据进行快照存储；</p>
</li>
<li><p>AOF（Append Only File），每一个收到的写命令都通过write函数追加到文件中。</p>
</li>
</ul>
<h2 id="11-redis-怎么实现分布式锁？"><a href="#11-redis-怎么实现分布式锁？" class="headerlink" title="11. redis 怎么实现分布式锁？"></a>11. redis 怎么实现分布式锁？</h2><ul>
<li><p>Redis 分布式锁，就是获取锁的时候在 redis 里设置一个值，释放锁的时候删除 redis 里的这个值；</p>
</li>
<li><p>其他程序要获取锁的时候，查询值是否存在，</p>
</li>
<li><p>若不存在则设置值，成功获取锁，就可以继续执行，</p>
</li>
<li><p>若存在则获取锁失败，就只能放弃或稍后重试。</p>
</li>
</ul>
<h2 id="12-redis-分布式锁有什么缺陷？"><a href="#12-redis-分布式锁有什么缺陷？" class="headerlink" title="12. redis 分布式锁有什么缺陷？"></a>12. redis 分布式锁有什么缺陷？</h2><ul>
<li>Redis 分布式锁不能解决超时的问题，</li>
<li>分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</li>
</ul>
<h2 id="13-redis-如何做内存优化？"><a href="#13-redis-如何做内存优化？" class="headerlink" title="13. redis 如何做内存优化？"></a>13. redis 如何做内存优化？</h2><ul>
<li><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>
</li>
<li><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
</li>
</ul>
<h2 id="14-redis-淘汰策略有哪些？"><a href="#14-redis-淘汰策略有哪些？" class="headerlink" title="14. redis 淘汰策略有哪些？"></a>14. redis 淘汰策略有哪些？</h2><ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<h2 id="15-redis-常见的性能问题有哪些？该如何解决？"><a href="#15-redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="15. redis 常见的性能问题有哪些？该如何解决？"></a>15. redis 常见的性能问题有哪些？该如何解决？</h2><ul>
<li><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</p>
</li>
<li><p>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/blog/post/54e1373e.html</url>
    <content><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h2><ul>
<li><p>第一范式，关系表中的每列都是原子不可分的项，即每个属性都是最基本的项；</p>
</li>
<li><p>第二范式，在满足第一范式的前提下，关系表的所有非主属性完全依赖于每一个候选关键属性；</p>
</li>
<li><p>第三范式，在满足第二范式的前提下，关系表的所有非主属性由主键直接决定。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几？"><a href="#一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几？" class="headerlink" title="一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？"></a>一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？</h2><ul>
<li>表引擎 MyISAM， id 为 8；</li>
<li>表引擎 InnoDB， id 为 6；</li>
<li>InnoDB 把表自增主键的最大 id 记录在内存里， 所有重启后会丢失最大 id。</li>
</ul>
<h2 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h2><ul>
<li>select version()</li>
</ul>
<h2 id="说一下-ACID-是什么？"><a href="#说一下-ACID-是什么？" class="headerlink" title="说一下 ACID 是什么？"></a>说一下 ACID 是什么？</h2><ul>
<li>ACID，事务的四大特性，原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)；</li>
<li>A，原子性，事务是一个不可分割的工作单位，要么都发生，要么都不发生；</li>
<li>C，事务必须使数据库，从一个一致性状态变换到另一个一致性状态；</li>
<li>I，事务的隔离性是指，多个用户并发访问数据库时，数据库为每个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务间相互隔离；</li>
<li>D，持久性要求，一个事务一旦被提交，它对数据库中数据的修改是永久性的，即使数据库发生故障也不会丢失。</li>
</ul>
<h2 id="说一下数据库的事务隔离？"><a href="#说一下数据库的事务隔离？" class="headerlink" title="说一下数据库的事务隔离？"></a>说一下数据库的事务隔离？</h2><ul>
<li>MySql的事务隔离是在 MySql.ini 配置文件里添加的，在文件的最后添加：transaction-isolation=REPEATABLE-READ</li>
<li>READ-UNCOMMITTED：读未提交，最低的隔离级别，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）</li>
<li>READ-COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（oracle默认级别，会出现幻读、不重复读）</li>
<li>REPEATABLE-READ：可重复读，就是在开始读取数据时，不再允许修改操作（mysql默认级别，会造成幻读）</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别 脏读：表示一个事务能读取另一个事务中还未提交的数据 不可重复读：指在一个事务内，多次读取同一数据 幻读：指同一个事务内多次查询返回的结果集不一样</li>
</ul>
<h2 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h2><ul>
<li><p>数据库中 char 固定长度，</p>
<ul>
<li>优点是效率高，缺点是占用多余空间，</li>
<li>适用场景为存储定长数据；</li>
</ul>
</li>
<li><p>数据库中 varchar 可变长度，</p>
<ul>
<li>存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度；</li>
</ul>
</li>
<li><p>空间上考虑适用 varchar， 效率上适用 char。</p>
</li>
</ul>
<h2 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h2><ul>
<li><p>mysql 数据库的 float 最多可以存储 8 位十进制数， 占 4 个字节；</p>
</li>
<li><p>double 最多可以存储 16 位十进制数，占 8 个字节。</p>
</li>
</ul>
<h2 id="mysql-的内连接、左连接、右连接有什么区别？"><a href="#mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="mysql 的内连接、左连接、右连接有什么区别？"></a>mysql 的内连接、左连接、右连接有什么区别？</h2><ul>
<li><p>内连接关键字：inner join；左连接：left join；右连接：right join；</p>
</li>
<li><p>内连接是把匹配的关联数据显示出来；</p>
</li>
<li><p>左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；</p>
</li>
<li><p>右连接是右边的表全部显示出来，左边的表显示出符合条件的数据；。</p>
</li>
</ul>
<h2 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h2><ul>
<li>常见的主要有两种结构：Hash索引和B+树索引，InnoDB引擎默认是B+树；</li>
<li>哈希索引适合等值查询，但是不无法进行范围查询，哈希索引没办法利用索引完成排序，也不支持多列联合索引的最左匹配原则，如果有大量重复键值的情况下，效率会很低，因此存在哈希碰撞的问题；</li>
<li>而B+树是一种多路平衡查询树，他的节点是天然有序的，对于范围查询的时候不需要做全表扫描。</li>
</ul>
<h2 id="怎么验证-mysql-的索引是否满足需求？"><a href="#怎么验证-mysql-的索引是否满足需求？" class="headerlink" title="怎么验证 mysql 的索引是否满足需求？"></a>怎么验证 mysql 的索引是否满足需求？</h2><ul>
<li>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求；</li>
<li>在正常的 sql 语句前加 explain 关键字。</li>
</ul>
<h2 id="说一下-mysql-常用的引擎？"><a href="#说一下-mysql-常用的引擎？" class="headerlink" title="说一下 mysql 常用的引擎？"></a>说一下 mysql 常用的引擎？</h2><ul>
<li><p>InnoDB 引擎：</p>
<ul>
<li>mysql 5.1 后默认的数据库引擎，</li>
<li>提供了对数据库 acid 事务的支持，</li>
<li>并且还提供了行级锁和外键的约束，</li>
<li>它的设计的目标就是处理大数据容量的数据库系统。</li>
<li>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。</li>
<li>但是该引擎是不支持全文搜索，同时启动也比较的慢，</li>
<li>它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。</li>
<li>由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li>
</ul>
</li>
<li><p>MyIASM 引擎：</p>
<ul>
<li>不提供事务的支持，也不支持行级锁和外键。</li>
<li>因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。</li>
<li>不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。</li>
<li>所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li>
</ul>
</li>
</ul>
<h2 id="说一下-mysql-的行锁和表锁？"><a href="#说一下-mysql-的行锁和表锁？" class="headerlink" title="说一下 mysql 的行锁和表锁？"></a>说一下 mysql 的行锁和表锁？</h2><ul>
<li>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁；</li>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h2 id="说一下乐观锁和悲观锁？"><a href="#说一下乐观锁和悲观锁？" class="headerlink" title="说一下乐观锁和悲观锁？"></a>说一下乐观锁和悲观锁？</h2><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>
<li>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</li>
</ul>
<h2 id="mysql-问题排查都有哪些手段？"><a href="#mysql-问题排查都有哪些手段？" class="headerlink" title="mysql 问题排查都有哪些手段？"></a>mysql 问题排查都有哪些手段？</h2><ul>
<li>使用 show processlist 命令查看当前所有连接信息；</li>
<li>使用 explain 命令查询 SQL 语句执行计划；</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h2 id="如何做-mysql-的性能优化？"><a href="#如何做-mysql-的性能优化？" class="headerlink" title="如何做 mysql 的性能优化？"></a>如何做 mysql 的性能优化？</h2><ul>
<li>为搜索字段创建索引；</li>
<li>避免sql语句不当使索引无效的情况</li>
<li>避免使用 select *，列出需要查询的字段，返回更少的数据，只返回需要的字段；</li>
<li>避免在where子句中使用!=，in，or；</li>
<li>使用连接查询代替子查询；</li>
<li>垂直分割分表；</li>
<li>选择正确的存储引擎。</li>
</ul>
<h2 id="一条sql执行时间过长，如何优化，从哪些方面？"><a href="#一条sql执行时间过长，如何优化，从哪些方面？" class="headerlink" title="一条sql执行时间过长，如何优化，从哪些方面？"></a>一条sql执行时间过长，如何优化，从哪些方面？</h2><ul>
<li>查看sql是否涉及多表的链表或者子查询，如果有，看看能否进行业务拆分，或者相关字段合并成临时表；</li>
<li>涉及链表的查询，是否能进行分表查询，查询之后进行字段整合；</li>
<li>是否可以对相应的字段做索引，加快查询速度；</li>
<li>针对数据量大的表进行历史表分离；</li>
<li>数据库主从分离，读写分离，降低读写对数据库同时操作的压力。MySQL自带binlog实现主从同步；</li>
<li>explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等；</li>
<li>查看MySQL日志，是否有其他问题。</li>
</ul>
<h2 id="当数据库中A-B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？"><a href="#当数据库中A-B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？" class="headerlink" title="当数据库中A,B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？"></a>当数据库中A,B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？</h2><ul>
<li>当A，B字段做了组合索引的时候，如果A在前，那么单独使用A会有索引效果，单独使用B则没有。</li>
</ul>
<h2 id="使用like查询是否走索引"><a href="#使用like查询是否走索引" class="headerlink" title="使用like查询是否走索引"></a>使用like查询是否走索引</h2><ul>
<li>后通配，走索引；</li>
<li>前通配，走全表。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DB</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/blog/post/b829b66a.html</url>
    <content><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="1-zookeeper-是什么？"><a href="#1-zookeeper-是什么？" class="headerlink" title="1. zookeeper 是什么？"></a>1. zookeeper 是什么？</h2><ul>
<li>zookeeper 是一个开源的分布式应用程序协调服务。</li>
<li>为分布式应用提供数据一致性服务，</li>
<li>功能包括，配置维护、域名服务、分布式同步、组服务。</li>
</ul>
<a id="more"></a>

<h2 id="2-zookeeper-都有哪些功能？"><a href="#2-zookeeper-都有哪些功能？" class="headerlink" title="2. zookeeper 都有哪些功能？"></a>2. zookeeper 都有哪些功能？</h2><ul>
<li>集群管理：监控节点存活状态、运行请求等；</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选举主节点，使用 zookeeper 可以协助完成这个过程；</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁，<ul>
<li>独占锁即一次只能有一个线程使用资源，</li>
<li>共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用；</li>
</ul>
</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
<h2 id="3-zookeeper-有几种部署模式？"><a href="#3-zookeeper-有几种部署模式？" class="headerlink" title="3. zookeeper 有几种部署模式？"></a>3. zookeeper 有几种部署模式？</h2><p>主要有三种：</p>
<ul>
<li>单机部署：一台服务器上运行；</li>
<li>集群部署：多台服务器构成集群运行；</li>
<li>伪集群部署：一台启动多个 zookeeper 实例构成集群运行。</li>
</ul>
<h2 id="4-zookeeper-怎么保证主从节点的状态同步？"><a href="#4-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4. zookeeper 怎么保证主从节点的状态同步？"></a>4. zookeeper 怎么保证主从节点的状态同步？</h2><ul>
<li>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。</li>
<li>实现这个机制的协议叫做 zab 协议。 </li>
<li>zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。</li>
<li>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。</li>
<li>状态同步保证了 leader 和 server 具有相同的系统状态。</li>
</ul>
<h2 id="5-集群中为什么要有主节点？"><a href="#5-集群中为什么要有主节点？" class="headerlink" title="5. 集群中为什么要有主节点？"></a>5. 集群中为什么要有主节点？</h2><ul>
<li>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，</li>
<li>这样可以大大减少重复计算，提高性能，所以就需要主节点。</li>
</ul>
<h2 id="6-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗？"><a href="#6-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗？" class="headerlink" title="6. 集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？"></a>6. 集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？</h2><ul>
<li>可以继续使用，</li>
<li>单数服务器只要没超过一半的服务器宕机就可以继续使用。</li>
</ul>
<h2 id="7-说一下-zookeeper-的通知机制？"><a href="#7-说一下-zookeeper-的通知机制？" class="headerlink" title="7. 说一下 zookeeper 的通知机制？"></a>7. 说一下 zookeeper 的通知机制？</h2><ul>
<li>客户端端会对某个 znode 建立一个 watcher 事件，</li>
<li>当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，</li>
<li>然后客户端可以根据 znode 变化来做出业务上的改变。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/blog/post/9a7d5a13.html</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="1-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#1-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="1. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>1. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><ul>
<li>kafka 不能脱离 zookeeper 单独使用，</li>
<li>因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</li>
</ul>
<a id="more"></a>

<h2 id="2-kafka-有几种数据保留的策略？"><a href="#2-kafka-有几种数据保留的策略？" class="headerlink" title="2. kafka 有几种数据保留的策略？"></a>2. kafka 有几种数据保留的策略？</h2><ul>
<li>kafka 有两种数据保存策略：<ul>
<li>按照过期时间保留,</li>
<li>按照存储的消息大小保留。</li>
</ul>
</li>
</ul>
<h2 id="3-kafka-同时设置了-7-天和-10G-清除数据-到第五天的时候消息达到了-10G-这个时候-kafka-将如何处理？"><a href="#3-kafka-同时设置了-7-天和-10G-清除数据-到第五天的时候消息达到了-10G-这个时候-kafka-将如何处理？" class="headerlink" title="3. kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？"></a>3. kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？</h2><ul>
<li>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</li>
</ul>
<h2 id="4-什么情况会导致-kafka-运行变慢？"><a href="#4-什么情况会导致-kafka-运行变慢？" class="headerlink" title="4. 什么情况会导致 kafka 运行变慢？"></a>4. 什么情况会导致 kafka 运行变慢？</h2><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h2 id="5-使用-kafka-集群需要注意什么？"><a href="#5-使用-kafka-集群需要注意什么？" class="headerlink" title="5. 使用 kafka 集群需要注意什么？"></a>5. 使用 kafka 集群需要注意什么？</h2><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/blog/post/b543ced0.html</url>
    <content><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-rabbitmq-的使用场景有哪些？"><a href="#1-rabbitmq-的使用场景有哪些？" class="headerlink" title="1. rabbitmq 的使用场景有哪些？"></a>1. rabbitmq 的使用场景有哪些？</h2><ul>
<li>跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。</p>
</li>
<li><p>应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。</p>
</li>
<li><p>消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。</p>
</li>
<li><p>应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。</p>
</li>
<li><p>跨局域网，甚至跨城市的通讯（CDN行业），比如北京机房与广州机房的应用程序的通信。</p>
</li>
</ul>
<h2 id="2-rabbitmq-有哪些重要的角色？"><a href="#2-rabbitmq-有哪些重要的角色？" class="headerlink" title="2. rabbitmq 有哪些重要的角色？"></a>2. rabbitmq 有哪些重要的角色？</h2><ul>
<li>RabbitMQ 中重要的角色有：生产者、消费者和代理：</li>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h2 id="3-rabbitmq-有哪些重要的组件？"><a href="#3-rabbitmq-有哪些重要的组件？" class="headerlink" title="3. rabbitmq 有哪些重要的组件？"></a>3. rabbitmq 有哪些重要的组件？</h2><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
<h2 id="4-rabbitmq-中-vhost-的作用是什么？"><a href="#4-rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="4. rabbitmq 中 vhost 的作用是什么？"></a>4. rabbitmq 中 vhost 的作用是什么？</h2><ul>
<li>vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。</li>
<li>其内部均含有独立的 queue、exchange 和 binding 等，</li>
<li>但最最重要的是，其拥有独立的权限系统，</li>
<li>可以做到 vhost 范围的用户控制。</li>
<li>当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段</li>
<li>一个典型的例子就是不同的应用可以跑在不同的 vhost 中。</li>
</ul>
<h2 id="5-rabbitmq-的消息是怎么发送的？"><a href="#5-rabbitmq-的消息是怎么发送的？" class="headerlink" title="5. rabbitmq 的消息是怎么发送的？"></a>5. rabbitmq 的消息是怎么发送的？</h2><ul>
<li>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，</li>
<li>客户端和 rabbit server 之间会创建一个 tcp 连接，</li>
<li>一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），</li>
<li>你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），</li>
<li>信道是创建在“真实” tcp 上的虚拟连接，</li>
<li>amqp 命令都是通过信道发送出去的，</li>
<li>每个信道都会有一个唯一的 id，</li>
<li>不论是发布消息，订阅队列都是通过这个信道完成的。</li>
</ul>
<h2 id="6-rabbitmq-怎么保证消息的稳定性？"><a href="#6-rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="6. rabbitmq 怎么保证消息的稳定性？"></a>6. rabbitmq 怎么保证消息的稳定性？</h2><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
<h2 id="7-rabbitmq-怎么避免消息丢失？"><a href="#7-rabbitmq-怎么避免消息丢失？" class="headerlink" title="7. rabbitmq 怎么避免消息丢失？"></a>7. rabbitmq 怎么避免消息丢失？</h2><ul>
<li><p>消息持久化</p>
</li>
<li><p>ACK确认机制</p>
</li>
<li><p>设置集群镜像模式</p>
</li>
<li><p>消息补偿机制</p>
</li>
</ul>
<h2 id="8-要保证消息持久化成功的条件有哪些？"><a href="#8-要保证消息持久化成功的条件有哪些？" class="headerlink" title="8. 要保证消息持久化成功的条件有哪些？"></a>8. 要保证消息持久化成功的条件有哪些？</h2><p>四个条件都满足才能保证消息持久化成功</p>
<ul>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
</ul>
<h2 id="9-rabbitmq-持久化有什么缺点？"><a href="#9-rabbitmq-持久化有什么缺点？" class="headerlink" title="9. rabbitmq 持久化有什么缺点？"></a>9. rabbitmq 持久化有什么缺点？</h2><ul>
<li>持久化的缺地就是降低了服务器的吞吐量，</li>
<li>因为使用的是磁盘而非内存存储，从而降低了吞吐量。</li>
<li>可尽量使用 ssd 硬盘来缓解吞吐量的问题。</li>
</ul>
<h2 id="10-rabbitmq-有几种广播类型？"><a href="#10-rabbitmq-有几种广播类型？" class="headerlink" title="10. rabbitmq 有几种广播类型？"></a>10. rabbitmq 有几种广播类型？</h2><p>三种广播模式：</p>
<ul>
<li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li>
<li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li>
<li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息。</li>
</ul>
<h2 id="11-rabbitmq-怎么实现延迟消息队列？"><a href="#11-rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="11. rabbitmq 怎么实现延迟消息队列？"></a>11. rabbitmq 怎么实现延迟消息队列？</h2><ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
<h2 id="12-rabbitmq-集群有什么用？"><a href="#12-rabbitmq-集群有什么用？" class="headerlink" title="12. rabbitmq 集群有什么用？"></a>12. rabbitmq 集群有什么用？</h2><p>集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h2 id="13-rabbitmq-节点的类型有哪些？"><a href="#13-rabbitmq-节点的类型有哪些？" class="headerlink" title="13. rabbitmq 节点的类型有哪些？"></a>13. rabbitmq 节点的类型有哪些？</h2><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
<h2 id="14-rabbitmq-集群搭建需要注意哪些问题？"><a href="#14-rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="14. rabbitmq 集群搭建需要注意哪些问题？"></a>14. rabbitmq 集群搭建需要注意哪些问题？</h2><ul>
<li>各节点之间使用“--link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
<h2 id="15-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#15-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="15. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>15. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
<h2 id="16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="16. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>16. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<h2 id="17-rabbitmq-对集群节点停止顺序有要求吗？"><a href="#17-rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="17. rabbitmq 对集群节点停止顺序有要求吗？"></a>17. rabbitmq 对集群节点停止顺序有要求吗？</h2><ul>
<li>RabbitMQ 对集群的停止的顺序是有要求的，</li>
<li>应该先关闭内存节点，最后再关闭磁盘节点。</li>
<li>如果顺序恰好相反的话，可能会造成消息的丢失。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/blog/post/da3e1361.html</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-mybatis-中-和-的区别是什么？"><a href="#1-mybatis-中-和-的区别是什么？" class="headerlink" title="1. mybatis 中 #{}和 ${}的区别是什么？"></a>1. mybatis 中 #{}和 ${}的区别是什么？</h2><ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值；</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ul>
<a id="more"></a>

<h2 id="2-mybatis-有几种分页方式？"><a href="#2-mybatis-有几种分页方式？" class="headerlink" title="2. mybatis 有几种分页方式？"></a>2. mybatis 有几种分页方式？</h2><ul>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ul>
<h2 id="3-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#3-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="3. RowBounds 是一次性查询全部结果吗？为什么？"></a>3. RowBounds 是一次性查询全部结果吗？为什么？</h2><ul>
<li>是一次性查询全部结果，只不过会根据参数丢掉一部分</li>
</ul>
<h2 id="4-mybatis-逻辑分页和物理分页的区别是什么？"><a href="#4-mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="4. mybatis 逻辑分页和物理分页的区别是什么？"></a>4. mybatis 逻辑分页和物理分页的区别是什么？</h2><ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
<h2 id="5-mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#5-mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="5. mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>5. mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2><ul>
<li><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，</p>
<ul>
<li>association指的就是一对一，collection指的就是一对多查询。</li>
<li>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li>
</ul>
</li>
<li><p>它的原理是，使用CGLIB创建目标对象的代理对象，</p>
<ul>
<li>当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，</li>
<li>拦截器invoke()方法发现a.getB()是null值，</li>
<li>那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，</li>
<li>然后调用a.setB(b)，于是a的对象b属性就有值了，</li>
<li>接着完成a.getB().getName()方法的调用。</li>
</ul>
</li>
</ul>
<h2 id="6-说一下-mybatis-的一级缓存和二级缓存？"><a href="#6-说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="6. 说一下 mybatis 的一级缓存和二级缓存？"></a>6. 说一下 mybatis 的一级缓存和二级缓存？</h2><ul>
<li><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
</li>
<li><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；</p>
</li>
<li><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
</ul>
<h2 id="7-mybatis-和-hibernate-的区别有哪些？"><a href="#7-mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="7. mybatis 和 hibernate 的区别有哪些？"></a>7. mybatis 和 hibernate 的区别有哪些？</h2><ul>
<li><p>Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p>
</li>
<li><p>Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p>
</li>
<li><p>开发方面</p>
<ul>
<li>hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</li>
<li>Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</li>
<li>但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，发杂语句较多，选择hibernate 就不是一个好方案。</li>
</ul>
</li>
<li><p>sql优化方面</p>
<ul>
<li>Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</li>
<li>Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</li>
</ul>
</li>
<li><p>对象管理比对</p>
<ul>
<li>Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</li>
<li>Mybatis 需要自行管理 映射关系；</li>
</ul>
</li>
<li><p>缓存方面 </p>
<ul>
<li>相同点：Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</li>
<li>不同点：</li>
<li>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</li>
<li>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</li>
</ul>
</li>
<li><p>比较：</p>
<ul>
<li>Hibernate 具有良好的管理机制，用户不需要关注SQL，如果二级缓存出现脏数据，系统会保存，；</li>
<li>Mybatis 在使用的时候要谨慎，避免缓存Cache 的使用。</li>
</ul>
</li>
<li><p>Hibernate优势</p>
<ul>
<li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li>
<li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li>
<li>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</li>
</ul>
</li>
<li><p>Mybatis优势</p>
<ul>
<li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。</li>
<li>MyBatis容易掌握，而Hibernate门槛较高。</li>
</ul>
</li>
<li><p>一句话总结</p>
<ul>
<li>Mybatis：小巧、方便、高效、简单、直接、半自动化</li>
<li>Hibernate：强大、方便、高效、复杂、间接、全自动化</li>
</ul>
</li>
</ul>
<h2 id="8-mybatis-有哪些执行器-Executor-？"><a href="#8-mybatis-有哪些执行器-Executor-？" class="headerlink" title="8. mybatis 有哪些执行器(Executor)？"></a>8. mybatis 有哪些执行器(Executor)？</h2><p>Mybatis有三种基本的执行器（Executor）：</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
<h2 id="9-mybatis-分页插件的实现原理是什么？"><a href="#9-mybatis-分页插件的实现原理是什么？" class="headerlink" title="9. mybatis 分页插件的实现原理是什么？"></a>9. mybatis 分页插件的实现原理是什么？</h2><ul>
<li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，</li>
<li>在插件的拦截方法内拦截待执行的sql，然后重写sql，</li>
<li>根据dialect方言，添加对应的物理分页语句和物理分页参数。</li>
</ul>
<h2 id="10-mybatis-如何编写一个自定义插件？"><a href="#10-mybatis-如何编写一个自定义插件？" class="headerlink" title="10. mybatis 如何编写一个自定义插件？"></a>10. mybatis 如何编写一个自定义插件？</h2><p>Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>
<ul>
<li>Executor：拦截执行器的方法(log记录)</li>
<li>StatementHandler ：拦截Sql语法构建的处理</li>
<li>ParameterHandler ：拦截参数的处理</li>
<li>ResultSetHandler ：拦截结果集的处理</li>
<li>Mybatis自定义插件必须实现Interceptor接口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">    void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>intercept方法：拦截器具体处理逻辑方法</p>
</blockquote>
<blockquote>
<p>plugin方法：根据签名signatureMap生成动态代理对象</p>
</blockquote>
<blockquote>
<p>setProperties方法：设置Properties属性</p>
</blockquote>
<p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：</p>
<ul>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/blog/post/6f8276a9.html</url>
    <content><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><h2 id="1-为什么要使用-hibernate？"><a href="#1-为什么要使用-hibernate？" class="headerlink" title="1. 为什么要使用 hibernate？"></a>1. 为什么要使用 hibernate？</h2><ul>
<li>对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li>
<li>hibernate 是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li>
<li>hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性。</li>
<li>hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ul>
<a id="more"></a>

<h2 id="2-什么是-ORM-框架？"><a href="#2-什么是-ORM-框架？" class="headerlink" title="2. 什么是 ORM 框架？"></a>2. 什么是 ORM 框架？</h2><ul>
<li>对象-关系映射（Object-Relational Mapping，简称ORM），</li>
<li>面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，</li>
<li>关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。</li>
<li>对象和关系数据是业务实体的两种表现形式，<ul>
<li>业务实体在内存中表现为对象，</li>
<li>在数据库中表现为关系数据。</li>
</ul>
</li>
<li>内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。</li>
<li>因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</li>
</ul>
<h2 id="3-hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#3-hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="3. hibernate 中如何在控制台查看打印的 sql 语句？"></a>3. hibernate 中如何在控制台查看打印的 sql 语句？</h2><ul>
<li>application.properties配置文件, spring.jpa.properties.hibernate.show_sql=true</li>
</ul>
<h2 id="4-hibernate-有几种查询方式？"><a href="#4-hibernate-有几种查询方式？" class="headerlink" title="4. hibernate 有几种查询方式？"></a>4. hibernate 有几种查询方式？</h2><p>主要有三种</p>
<ul>
<li>hql查询<ul>
<li>属性查询</li>
<li>参数查询、命名参数查询</li>
<li>关联查询</li>
<li>分页查询</li>
<li>统计函数</li>
</ul>
</li>
<li>sql查询</li>
<li>条件查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HQL:  Hibernate Query Language. 面向对象的写法:</span><br><span class="line">	Query query = session.createQuery(&quot;from Customer where name = ?&quot;);</span><br><span class="line">	query.setParameter(0, &quot;Good Luck&quot;);</span><br><span class="line">	Query.list();</span><br><span class="line"></span><br><span class="line">SQL:</span><br><span class="line">	SQLQuery query = session.createSQLQuery(&quot;select * from customer&quot;);</span><br><span class="line">	List&lt;Object[]&gt; list = query.list();</span><br><span class="line"></span><br><span class="line">	SQLQuery query = session.createSQLQuery(&quot;select * from customer&quot;);</span><br><span class="line">	query.addEntity(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = query.list();</span><br><span class="line"></span><br><span class="line">QBC:  Query By Criteria.(条件查询):</span><br><span class="line">	Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">	criteria.add(Restrictions.eq(&quot;name&quot;, &quot;大佬&quot;));</span><br><span class="line">	List&lt;Customer&gt; list = criteria.list();</span><br></pre></td></tr></table></figure>

<ul>
<li>HQL和SQL的区别<ul>
<li>HQL是面向对象查询操作的，</li>
<li>SQL是结构化查询语言 是面向数据库表结构的。</li>
</ul>
</li>
</ul>
<h2 id="5-hibernate-实体类可以被定义为-final-吗？"><a href="#5-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="5. hibernate 实体类可以被定义为 final 吗？"></a>5. hibernate 实体类可以被定义为 final 吗？</h2><ul>
<li>可以将Hibernate的实体类定义为final类，但这种做法并不好。</li>
<li>因为Hibernate会使用代理模式在延迟关联的情况下提高性能，</li>
<li>如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，</li>
<li>如此一来就限制了使用可以提升性能的手段。</li>
<li>不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法的话，</li>
<li>你就能够避免出现前面所说的不利后果。</li>
</ul>
<h2 id="6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><ul>
<li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，</li>
<li>如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li>
</ul>
<h2 id="7-hibernate-是如何工作的？"><a href="#7-hibernate-是如何工作的？" class="headerlink" title="7. hibernate 是如何工作的？"></a>7. hibernate 是如何工作的？</h2><ul>
<li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li>
<li>由hibernate.cfg.xml中的读取并解析映射信息</li>
<li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li>
<li>Session session = sf.openSession();//打开Sesssion</li>
<li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li>
<li>persistent operate操作数据，持久化操作</li>
<li>tx.commit();//提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ul>
<h2 id="8-get-和-load-的区别？"><a href="#8-get-和-load-的区别？" class="headerlink" title="8. get()和 load()的区别？"></a>8. get()和 load()的区别？</h2><ul>
<li>load() 没有使用对象的其他属性的时候，没有 SQL， 延迟加载</li>
<li>get() 没有使用对象的其他属性的时候，也生成了 SQL， 立即加载</li>
</ul>
<h2 id="9-说一下-hibernate-的缓存机制？"><a href="#9-说一下-hibernate-的缓存机制？" class="headerlink" title="9. 说一下 hibernate 的缓存机制？"></a>9. 说一下 hibernate 的缓存机制？</h2><ul>
<li><p>Hibernate中的缓存分为一级缓存和二级缓存。</p>
<ul>
<li>一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。</li>
<li>二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</li>
</ul>
</li>
<li><p>什么样的数据适合存放到第二级缓存中？</p>
<ul>
<li>很少被修改的数据 帖子的最后回复时间</li>
<li>经常被查询的数据 电商的地点</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
</li>
<li><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。</p>
</li>
</ul>
<h2 id="10-hibernate-对象有哪些状态？"><a href="#10-hibernate-对象有哪些状态？" class="headerlink" title="10. hibernate 对象有哪些状态？"></a>10. hibernate 对象有哪些状态？</h2><p>hibernate里对象有三种状态：</p>
<ul>
<li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li>
<li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li>
<li>Detached（脱管）：当session close()完之后，变成Detached。</li>
</ul>
<h2 id="11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2><ul>
<li><p>openSession </p>
<ul>
<li>从字面上可以看得出来，是打开一个新的session对象，</li>
<li>而且每次使用都是打开一个新的session，</li>
<li>假如连续使用多次，则获得的session不是同一个对象，</li>
<li>并且使用完需要调用close方法关闭session。</li>
</ul>
</li>
<li><p>getCurrentSession ，</p>
<ul>
<li>从字面上可以看得出来，是获取当前上下文一个session对象，</li>
<li>当第一次使用此方法时，会自动产生一个session对象，</li>
<li>并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，</li>
<li>简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），</li>
<li>所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</li>
</ul>
</li>
</ul>
<h2 id="12-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#12-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="12. hibernate 实体类必须要有无参构造函数吗？为什么？"></a>12. hibernate 实体类必须要有无参构造函数吗？为什么？</h2><ul>
<li><p>必须，</p>
<ul>
<li>因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，</li>
<li>这个方法就是通过调用默认构造方法来创建实例对象的。</li>
</ul>
</li>
<li><p>另外再提醒一点，</p>
<ul>
<li>如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），</li>
<li>但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，</li>
<li>这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，</li>
<li>只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot/Spring Cloud</title>
    <url>/blog/post/b3383f7f.html</url>
    <content><![CDATA[<h1 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h1><h2 id="1-什么是-spring-boot？"><a href="#1-什么是-spring-boot？" class="headerlink" title="1. 什么是 spring boot？"></a>1. 什么是 spring boot？</h2><ul>
<li><p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMVC框架等，</p>
</li>
<li><p>Spring的核心内容在于控制反转(IOC)和依赖注入(DI),</p>
</li>
<li><p>在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
</li>
<li><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，</p>
</li>
<li><p>所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，</p>
</li>
<li><p>所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-为什么要用-spring-boot？"><a href="#2-为什么要用-spring-boot？" class="headerlink" title="2. 为什么要用 spring boot？"></a>2. 为什么要用 spring boot？</h2><ul>
<li>使编码变简单</li>
<li>使配置变简单</li>
<li>使部署变简单</li>
<li>使监控变简单</li>
<li>Spring的不足</li>
</ul>
<h2 id="3-spring-boot-核心配置文件是什么？"><a href="#3-spring-boot-核心配置文件是什么？" class="headerlink" title="3. spring boot 核心配置文件是什么？"></a>3. spring boot 核心配置文件是什么？</h2><p>Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h2 id="4-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#4-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="4. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>4. spring boot 配置文件有哪几种类型？它们有什么区别？</h2><ul>
<li>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</li>
<li>相对于properties文件而言，yml文件更年轻，也有很多的坑。</li>
<li>可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</li>
</ul>
<h2 id="5-spring-boot-有哪些方式可以实现热部署？"><a href="#5-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="5. spring boot 有哪些方式可以实现热部署？"></a>5. spring boot 有哪些方式可以实现热部署？</h2><ul>
<li><p>SpringBoot热部署实现有两种方式：</p>
</li>
<li><p>使用spring loaded</p>
</li>
<li><p>使用spring-boot-devtools</p>
</li>
</ul>
<h2 id="6-jpa-和-hibernate-有什么区别？"><a href="#6-jpa-和-hibernate-有什么区别？" class="headerlink" title="6. jpa 和 hibernate 有什么区别？"></a>6. jpa 和 hibernate 有什么区别？</h2><ul>
<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。</li>
<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>
<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>
<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>
<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>
<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>
</ul>
<h2 id="7-什么是-spring-cloud？"><a href="#7-什么是-spring-cloud？" class="headerlink" title="7. 什么是 spring cloud？"></a>7. 什么是 spring cloud？</h2><ul>
<li><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>
</li>
<li><p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>
</li>
<li><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
</ul>
</li>
<li><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>
</li>
</ul>
<h2 id="8-spring-cloud-断路器的作用是什么？"><a href="#8-spring-cloud-断路器的作用是什么？" class="headerlink" title="8. spring cloud 断路器的作用是什么？"></a>8. spring cloud 断路器的作用是什么？</h2><ul>
<li><p>在Spring Cloud中使用了 Hystrix 来实现断路器的功能，</p>
</li>
<li><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</p>
</li>
<li><p>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</p>
</li>
<li><p>断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
</li>
<li><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。</p>
</li>
<li><p>它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。</p>
</li>
<li><p>如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，</p>
</li>
<li><p>或以提醒管理员当断路器跳闸，以在打开状态。</p>
</li>
</ul>
<h2 id="9-spring-cloud-的核心组件有哪些？"><a href="#9-spring-cloud-的核心组件有哪些？" class="headerlink" title="9. spring cloud 的核心组件有哪些？"></a>9. spring cloud 的核心组件有哪些？</h2><ul>
<li><p>服务发现——Netflix Eureka</p>
<ul>
<li>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。</li>
<li>由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。</li>
<li>Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li>
<li>Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</li>
</ul>
</li>
<li><p>客服端负载均衡——Netflix Ribbon</p>
<ul>
<li>Ribbon，主要提供客户侧的软件负载均衡算法。</li>
<li>Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。</li>
<li>Ribbon内置可插拔、可定制的负载均衡组件。</li>
</ul>
</li>
<li><p>断路器——Netflix Hystrix</p>
<ul>
<li>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</li>
<li>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</li>
<li>断路器模式也使应用程序能够检测故障是否已经解决。</li>
<li>如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li>
</ul>
</li>
<li><p>服务网关——Netflix Zuul</p>
<ul>
<li>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</li>
</ul>
</li>
<li><p>分布式配置——Spring Cloud Config</p>
<ul>
<li>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring/Spring MVC</title>
    <url>/blog/post/ae9d29e2.html</url>
    <content><![CDATA[<h1 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h1><h2 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h2><ul>
<li>简介<ul>
<li>目的：解决企业应用开发的复杂性</li>
<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>
<li>范围：任何Java应用</li>
<li>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>轻量　　</p>
<ul>
<li>从大小与开销两方面而言Spring都是轻量的。</li>
<li>完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。</li>
<li>并且Spring所需的处理开销也是微不足道的。</li>
<li>此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
</ul>
</li>
<li><p>控制反转　　</p>
<ul>
<li>Sping通过一种称作控制反转（IoC）的技术促进了松耦合。</li>
<li>当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</li>
<li>你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
</ul>
</li>
<li><p>面向切面　　</p>
<ul>
<li>Spring提供了面向切面编程的丰富支持，</li>
<li>允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。</li>
<li>应用对象只实现它们应该做的——完成业务逻辑——仅此而已。</li>
<li>它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
</ul>
</li>
<li><p>容器</p>
<ul>
<li>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，</li>
<li>你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），</li>
<li>你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li>
<li>然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li>Spring可以将简单的组件配置、组合成为复杂的应用。</li>
<li>在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。</li>
<li>Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li>
</ul>
</li>
<li><p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
</li>
</ul>
<h2 id="Spring的设计模式有几种？"><a href="#Spring的设计模式有几种？" class="headerlink" title="Spring的设计模式有几种？"></a>Spring的设计模式有几种？</h2><ul>
<li><p>9种。</p>
</li>
<li><p>简单工厂：FactoryBean。</p>
</li>
<li><p>工厂方法：xml文件的factory-bean属性指定工厂方法。</p>
</li>
<li><p>单例模式：默认唯一的访问点是BeanFactory访问点。</p>
</li>
<li><p>适配器模式：HanderAdapter，AdvisorAdaptor。</p>
</li>
<li><p>装饰器模式：Wrapper，Decorator。</p>
</li>
<li><p>代理模式：AOP功能的原理就使用代理模式。</p>
</li>
<li><p>观察者模式：监听器。</p>
</li>
<li><p>策略模式：实例化对象的时候使用策略模式。</p>
</li>
<li><p>模板方法模式：JdbcTemplate。</p>
</li>
</ul>
<h2 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h2><ul>
<li><p>主要有七个模块；</p>
</li>
<li><p>核心容器（Spring Core）</p>
<ul>
<li>核心容器提供Spring框架的基本功能。</li>
<li>Spring以bean的方式组织和管理Java应用中的各个组件及其关系。</li>
<li>Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。</li>
<li>BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</li>
</ul>
</li>
<li><p>应用上下文（Spring Context）</p>
<ul>
<li>Spring上下文是一个配置文件，向Spring框架提供上下文信息。</li>
<li>Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
</ul>
</li>
<li><p>Spring面向切面编程（Spring AOP）</p>
<ul>
<li>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。</li>
<li>所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。</li>
<li>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</li>
<li>通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
</ul>
</li>
<li><p>JDBC和DAO模块（Spring DAO）</p>
<ul>
<li>JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。</li>
<li>异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</li>
</ul>
</li>
<li><p>对象实体映射（Spring ORM）</p>
<ul>
<li>Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，</li>
<li>其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</li>
</ul>
</li>
<li><p>Web模块（Spring Web）</p>
<ul>
<li>Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。</li>
<li>所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
</ul>
</li>
<li><p>MVC模块（Spring Web MVC）</p>
<ul>
<li>MVC框架是一个全功能的构建Web应用程序的MVC实现。</li>
<li>通过策略接口，MVC框架变成为高度可配置的。</li>
<li>MVC容纳了大量视图技术，其中包括JSP、POI等，</li>
<li>模型来有JavaBean来构成，存放于 model 当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码，由c的事情。</li>
<li>Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。</li>
<li>Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，</li>
<li>毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</li>
</ul>
</li>
</ul>
<h2 id="Spring容器有几种？"><a href="#Spring容器有几种？" class="headerlink" title="Spring容器有几种？"></a>Spring容器有几种？</h2><ul>
<li>BeanFactory是最简答的容器，提供了基本的DI支持。最常用的BeanFactory实现就是XmlBeanFactory类。</li>
<li>ApplicationContext扩展了BeanFactory的功能，提供面向应用的服务。</li>
<li>通过缓存在map中，实现了类的复用。</li>
</ul>
<h2 id="beanfactory和applicationcontext是什么关系，使用有什么区别。"><a href="#beanfactory和applicationcontext是什么关系，使用有什么区别。" class="headerlink" title="beanfactory和applicationcontext是什么关系，使用有什么区别。"></a>beanfactory和applicationcontext是什么关系，使用有什么区别。</h2><ul>
<li>ApplicationContex提供了一种解析文本消息的方法，一种加载文件资源（如图像）的通用方法，它们可以将事件发布到注册为侦听器的bean。</li>
<li>此外，可以在应用程序上下文中以声明方式处理容器中的容器或容器上的操作，这些操作必须以编程方式与Bean Factory一起处理。</li>
<li>ApplicationContex实现MessageSource，一个用于获取本地化消息的接口，实际的实现是可插入的。</li>
</ul>
<h2 id="FactoryBean如何使用？"><a href="#FactoryBean如何使用？" class="headerlink" title="FactoryBean如何使用？"></a>FactoryBean如何使用？</h2><ul>
<li>一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean. </li>
<li>如果类的配置复杂，那么就可以实现一个FactoryBean接口的工厂类，在getObject()方法中定制实例化逻辑。</li>
<li>当使用这个类的时候，Spring通过反射机制发现这个类实现了该工厂接口，就通过getObject()方法返回实例。</li>
<li>如果要获得工厂类本身的实例，则需要在beanName前面加&quot;&amp;&quot;。</li>
</ul>
<h1 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h1><h2 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h2><ul>
<li><p>面向方面的编程（AOP）是一种编程技术，它允许程序员模块化横切关注点或行为，这些问题或行为跨越典型的责任分工，例如日志记录和事务管理。</p>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</p>
</li>
<li><p>OOP（Object-Oriented Programing，面向对象编程）</p>
<ul>
<li>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。</li>
<li>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。</li>
<li>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。</li>
<li>例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</li>
<li>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。</li>
<li>这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
</ul>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程）</p>
<ul>
<li>它利用一种称为“横切”的技术，剖解开封装的对象内部，</li>
<li>并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。</li>
<li>所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，</li>
<li>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
<li>AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；</li>
<li>那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。</li>
<li>然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</li>
</ul>
</li>
<li><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。</p>
<ul>
<li>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</li>
<li>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。</li>
<li>比如权限认证、日志、事务处理。</li>
<li>AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
<li>AOP的核心思想就是，将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。</li>
</ul>
</li>
</ul>
<h2 id="Spring-AOP中的关注点和交叉关注点之间有什么区别？"><a href="#Spring-AOP中的关注点和交叉关注点之间有什么区别？" class="headerlink" title="Spring AOP中的关注点和交叉关注点之间有什么区别？"></a>Spring AOP中的关注点和交叉关注点之间有什么区别？</h2><ul>
<li><p>关注点是我们希望在应用程序模块中拥有的行为。关注点可以定义为我们想要实现的功能。</p>
</li>
<li><p>跨领域的关注点是一个适用于整个应用程序的问题，它会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要的问题，因此它们是跨领域的问题。</p>
</li>
</ul>
<h2 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h2><ul>
<li>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</li>
<li>把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</li>
</ul>
<h2 id="AOP和IOC的原理是什么？"><a href="#AOP和IOC的原理是什么？" class="headerlink" title="AOP和IOC的原理是什么？"></a>AOP和IOC的原理是什么？</h2><ul>
<li><p>ioc控制反转是由Spring容器负责创建对象，管理对象（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
</li>
<li><p>di依赖注入是spring容器根据描述配置将被依赖的类通过构造器或者setter方法注入正在被实例化的类。</p>
</li>
<li><p>aop切面编程是通过抽取公共的日志、权限、事务等切面逻辑，通过jdk或者cglib的动态代理生成代理类将增强代码织入原代码中。合并类的公共处理逻辑可以减少重复代码和耦合，侵入性小，便于容器测试。</p>
</li>
<li><p>AOP 和 IOC是Spring精华部分，AOP可以看做是对OOP的补充，对代码进行横向的扩展，通过代理模式实现，代理模式有静态代理，动态代理，Spring利用的是动态代理，在程序运行过程中将增强代码织入原代码中。</p>
</li>
</ul>
<h2 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h2><ul>
<li>set 注入</li>
<li>构造方法注入</li>
<li>接口注入</li>
</ul>
<h2 id="如何创建动态AOP代理？"><a href="#如何创建动态AOP代理？" class="headerlink" title="如何创建动态AOP代理？"></a>如何创建动态AOP代理？</h2><ul>
<li><p>创建代理的步骤：获取增强方法/增强器，根据增强方法/增强器进行代理。</p>
</li>
<li><p>目标对象如果实现了接口，默认通过JDK代理，也可以强制cglib代理。如果没有实现接口，就必须使用cglib库，Spring会自动实现jdk动态代理和cglib之间的转换。</p>
</li>
<li><p>加载时织入(LTW)是在虚拟机载入字节码文件是动态植入AspectJ切面。LTM参数在虚拟机层面的的设置不够具体，Spring的对LTW的设置可以在类加载器的粒度上打开，通过外部增强实现效果，就不必在工程内部修改代码。</p>
</li>
</ul>
<h2 id="如何创建静态AOP代理？"><a href="#如何创建静态AOP代理？" class="headerlink" title="如何创建静态AOP代理？"></a>如何创建静态AOP代理？</h2><ul>
<li>将动态代理改为静态代理，配置文件需要添加：<code>&lt;context:load-time-weaver /&gt;</code>，然后在META-INF文件夹下建立aop.xml：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;</span><br><span class="line">&lt;aspectj&gt;</span><br><span class="line">	&lt;weaver&gt;&lt;include within=&quot;xx.*&quot; /&gt;&lt;/weaver&gt;</span><br><span class="line">	&lt;aspects&gt;&lt;aspect name=&quot;xx.AspectConfig&quot; /&gt;&lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="Spring-bean的定义和作用域是什么？"><a href="#Spring-bean的定义和作用域是什么？" class="headerlink" title="Spring bean的定义和作用域是什么？"></a>Spring bean的定义和作用域是什么？</h2><ul>
<li><p>Spring Beans是构成Spring应用程序主干的Java对象。</p>
<ul>
<li>它们由Spring IoC容器实例化，组装和管理。</li>
<li>这些bean是使用提供给容器的配置元数据创建的，例如，以XML定义的形式。</li>
</ul>
</li>
<li><p>bean的作用域包括单例，原型，请求，回话，全局。</p>
</li>
</ul>
<h2 id="Bean的生命周期是什么？"><a href="#Bean的生命周期是什么？" class="headerlink" title="Bean的生命周期是什么？"></a>Bean的生命周期是什么？</h2><ul>
<li>创建Bean的实例；</li>
<li>按照配置注入属性；</li>
<li>调用可能实现的BeanNameAware接口方法，传参id。</li>
<li>调用可能实现的BeanFactoryAware接口方法，传参Spring工厂。</li>
<li>调用可能实现的ApplicationContextAware接口方法，传参Spring上下文。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化前方法。</li>
<li>调用可能配置的init-method初始化方法。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化后方法。开始使用。</li>
<li>销毁时，调用可能实现的DisposableBean的destroy方法。</li>
<li>最后，调用可能配置的destroy-method销毁方法。</li>
</ul>
<h2 id="bean的加载过程是什么？"><a href="#bean的加载过程是什么？" class="headerlink" title="bean的加载过程是什么？"></a>bean的加载过程是什么？</h2><ul>
<li>转换对应的beanName。</li>
<li>尝试从缓存中加载单例。</li>
<li>bean的实例化。</li>
<li>对原型模式检查类的依赖。</li>
<li>检查父类工厂。</li>
<li>转化bean的定义类。</li>
<li>寻找依赖。</li>
<li>针对不同的scope创建bean。</li>
<li>类型转换。</li>
</ul>
<h2 id="Spring中如何让A和B两个bean按顺序加载？"><a href="#Spring中如何让A和B两个bean按顺序加载？" class="headerlink" title="Spring中如何让A和B两个bean按顺序加载？"></a>Spring中如何让A和B两个bean按顺序加载？</h2><ul>
<li>用dependon注解依赖关系。</li>
</ul>
<h2 id="什么是循环依赖，Spring如何解决？"><a href="#什么是循环依赖，Spring如何解决？" class="headerlink" title="什么是循环依赖，Spring如何解决？"></a>什么是循环依赖，Spring如何解决？</h2><ul>
<li><p>循环依赖就是循环引用，方法之间的环调用，构成有向环。 </p>
<ul>
<li>Spring的构造器循环依赖将正在创建的 beanName(id) 标志符记录到“当前创建bean池”（构造状态表），</li>
<li>构造所需的类的beanName继续添加到表中，如果已有记录，就说明有环结构，抛出循环依赖的异常。</li>
</ul>
</li>
<li><p>Spring的setter注入的循环依赖是通过提前暴露刚构造完（尚未setter注入）的bean来完成的，且只能解决单例范围的依赖。</p>
<ul>
<li>通过提前暴露一个单例工厂方法，使其他bean能引用到该bean，把beanName标志符加入到“当前创建bean池”中，</li>
<li>然后setter注入后续类，后续类因此创建单例，加入自己的标志符。</li>
<li>当后续类检测到setter需要的类已经位于池中，就通过该标志符在另一个表中找到对应的ObjectFactory工厂，</li>
<li>进而返回工厂类创建的bean. 然后在第二个循环中依次setter注入工厂类创建的bean。</li>
</ul>
</li>
<li><p>Spring的prototype作用域的bean, Spring容器无法完成依赖注入，因为不缓存该作用域的bean,因此无法提前暴露。</p>
</li>
</ul>
<h2 id="如何获取单例？"><a href="#如何获取单例？" class="headerlink" title="如何获取单例？"></a>如何获取单例？</h2><ul>
<li>在全局变量加锁的情况下。</li>
<li>检查singletonObjects缓存类中是否已加载，</li>
<li>没有加载就把beanName记录到加载状态表，</li>
<li>通过ObjectFactory的方法得到实例化bean，</li>
<li>从加载状态表中移除这个beanName，</li>
<li>缓存实例并删除其他状态表的记录。</li>
</ul>
<h2 id="如何从缓存中获取单例bean？"><a href="#如何从缓存中获取单例bean？" class="headerlink" title="如何从缓存中获取单例bean？"></a>如何从缓存中获取单例bean？</h2><ul>
<li>创建单例的时候会存在依赖注入的情况，</li>
<li>而在创建依赖的时候为了避免循环依赖，</li>
<li>Spring创建Bean的原则是不等bean创建完成就会将创建bean的ObjectFactory加入到缓存，</li>
<li>一旦下一个bean创建时需要依赖上个bean，就直接使用ObjectFactory.</li>
</ul>
<h2 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="Bean 是线程安全的吗？"></a>Bean 是线程安全的吗？</h2><ul>
<li>单例的bean不安全，prototype和request作用域的，安全。</li>
<li>通过无状态的设计实现线程安全。</li>
</ul>
<h2 id="创建bean的实例"><a href="#创建bean的实例" class="headerlink" title="创建bean的实例"></a>创建bean的实例</h2><ul>
<li>初始化前先解析，如果已经创建了代理或者在初始化前的后处理器方法中改变了bean, 则直接返回就可以了。否则需要进行常规bean的创建。</li>
<li>创建过程包括：清除单例缓存，创建bean的实例(将BeanDefinition转换为BeanWrapper)，合并类定义的后处理器类解析父类和注解等，依赖处理，属性填充，检查循环依赖，注册DisposableBean, 完成创建并返回。</li>
<li>创建bean的实例，优先使用根定义类的工厂方法实例化，解析构造函数并构造实例。构造实例，要先检查缓存的构造器的唯一解析结果，没解析过的要重新先解析。然后对这个解析结果进行自动注入构造或者默认构造器构造(直接实例化)。</li>
<li>自动注入构造，初始化一个新的类包装器，依次从指定传参、根类定义缓存和配置中获取构造方法参数列表（并转换类型）和参数的个数，从指定传参或者反射获取构造器数组，按照构造器参数从多到少和公开优先的顺序排序，遍历解析构造器并加入缓存，参数类型转换，验证构造函数不是父类重写关系，根据实例化策略和构造函数与参数实例化bean.</li>
<li>实例化策略，如果没有使用replace(覆盖方法)或者lookup(动态替换)配置的方法，直接反射即可实例化。否则就需要使用cglib进行动态代理，将动态的拦截器增强切面方法织入类中，返回代理类。</li>
<li>记录创建bean的ObjectFactory。属性注入，包括根据根据名称、类型注入。</li>
<li>初始化bean，包括激活Aware三个方法，后处理器的前后使用，激活自定义的init方法。</li>
<li>ApplicationContext是对BeanFactory的功能扩展，详见refresh()函数对AC的初始化：</li>
<li>准备刷新上下文环境（准备并验证系统属性或者环境变量），初始化FactoryBean并读取xml，填充FB的功能(如自动注入的注解)，开发者定制的子类覆盖方法(postProcessBeanFactory)执行，FB的后处理器执行，注册拦截bean创建的bean处理器（获取bean时调用），为上下文初始化Message国际化语言源，初始化应用消息广播器并AEM中，留给子类来初始化其他的bean, 在注册的bean中查找监听器bean并注册，初始化剩下的单例，完成刷新过程后，通知生命周期处理器刷新过程，同时发出上下文刷新时间通知其他类。</li>
<li>开发者定制的工厂类后处理方法，为类的创建提供了灵活性。</li>
</ul>
<h2 id="Bean-的创建过程是什么？"><a href="#Bean-的创建过程是什么？" class="headerlink" title="Bean 的创建过程是什么？"></a>Bean 的创建过程是什么？</h2><ul>
<li><p>根据class属性或名称解析类，通过override属性的同名方法个数验证合理性或者标记为没有重载方法，然后进行初始化前的预处理，创建bean.</p>
</li>
<li><p>lookup-method和replace-method两个配置功能的加载就是设置到RootBeanDefinition的methodOverrides属性中。实现原理是在bean实例化时如果检测到存在methodOverrides属性，就会动态地为当前bean生成代理并使用对应的拦截器为bean作增强处理。</p>
</li>
<li><p>实例化的前置处理过程的bean经短路判断非空，则直接返回这个bean，忽略后续bean的创建。AOP功能就是基于这种判断。</p>
</li>
</ul>
<h2 id="如何从bean的实例中获取对象？"><a href="#如何从bean的实例中获取对象？" class="headerlink" title="如何从bean的实例中获取对象？"></a>如何从bean的实例中获取对象？</h2><ul>
<li>加载bean后通过getObjectForBeanInstance方法检测当前bean是否是FactoryBean类型，</li>
<li>是则调用该类型的工厂方法返回真正需要的bean实例，并进行后处理。</li>
</ul>
<h2 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h2><ul>
<li>spring 支持 5 种作用域，如下：<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：</li>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>
</ul>
</li>
<li>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li>
</ul>
<h2 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h2><ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h2><ul>
<li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li>
<li>程序化事务：提供编码的形式管理和维护事务。</li>
</ul>
<h2 id="哪种事务管理类型更可取？"><a href="#哪种事务管理类型更可取？" class="headerlink" title="哪种事务管理类型更可取？"></a>哪种事务管理类型更可取？</h2><ul>
<li>Spring Framework的大多数用户选择声明式事务管理，因为它是对应用程序代码影响最小的选项，因此最符合非侵入式轻量级容器的理想。</li>
<li>声明式事务管理优于程序化事务管理，但它不如程序化事务管理灵活，后者允许您通过代码控制事务。</li>
</ul>
<h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><ul>
<li><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
</li>
<li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
</li>
<li><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
<li><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
</li>
<li><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
</li>
<li><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
</li>
</ul>
<h2 id="Spring-Framework的事务管理有哪些好处？"><a href="#Spring-Framework的事务管理有哪些好处？" class="headerlink" title="Spring Framework的事务管理有哪些好处？"></a>Spring Framework的事务管理有哪些好处？</h2><ul>
<li>它在不同的事务API（如JTA，JDBC，Hibernate，JPA和JDO）之间提供了一致的编程模型。 </li>
<li>与许多复杂的事务API（如JTA）相比，它为程序化事务管理提供了更简单的API。 </li>
<li>它支持声明式事务管理。 </li>
<li>它与Spring的各种数据访问抽象集成得非常好。</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h2><ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h2 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h2><ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h2 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h2><ul>
<li>将 http 请求映射到相应的类/方法上。</li>
</ul>
<h2 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h2><ul>
<li>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，</li>
<li>通过@Autowired 的使用来消除 set/get 方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/post/364ea8cc.html</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1. 说一下你熟悉的设计模式？"></a>1. 说一下你熟悉的设计模式？</h2><ul>
<li>根据目的来分可以可以分成3类，创建型、结构型、行为型；<ul>
<li>创建型有5种，工厂方法，抽象工厂，原型，单例，建造者；</li>
<li>结构型有7种，适配器，代理，桥接，装饰，外观，享元，组合；</li>
<li>行为型有11种，模板方法，解释器，策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录；</li>
</ul>
</li>
<li>根据作用范围来分，可以有两类，分别是类模式、对象模式；<ul>
<li>类模式主要有4种，工厂方法，类的适配器，模板方法，解释器；</li>
<li>对象模式有20种，单例，原型，抽象工厂，建造者，代理，对象的适配器，桥接，装饰，外观，享元，组合，策略，命令，责任链，状态，观察者，中介者，迭代器，访问者，备忘录；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例，原型，抽象工厂，建造者</td>
<td>代理，(对象）适配器，桥接，装饰，外观，享元，组合</td>
<td>策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录</td>
</tr>
</tbody></table>
<h2 id="2-简单工厂和抽象工厂有什么区别？"><a href="#2-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2. 简单工厂和抽象工厂有什么区别？"></a>2. 简单工厂和抽象工厂有什么区别？</h2><ul>
<li>简单工厂，可以理解为专门生产某一个产品的工厂；</li>
<li>工厂方法，是生产某一类产品的工厂，是生产具体产品的工厂的父类；</li>
<li>抽象工厂，生产多类产品的工厂；</li>
</ul>
<h2 id="3-设计的基本原则有哪些？"><a href="#3-设计的基本原则有哪些？" class="headerlink" title="3. 设计的基本原则有哪些？"></a>3. 设计的基本原则有哪些？</h2><ul>
<li><p>设置模式的六大原则，开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特法则，合成复用原则；</p>
</li>
<li><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；</p>
</li>
<li><p>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现；</p>
</li>
<li><p>依赖倒转原则，针对接口编程，依赖于抽象而不依赖于具体；</p>
</li>
<li><p>接口隔离原则，使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度；</p>
</li>
<li><p>迪米特法则又称为，最少知道原则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立；</p>
</li>
<li><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</li>
</ul>
<h2 id="4-设计模式简介"><a href="#4-设计模式简介" class="headerlink" title="4. 设计模式简介"></a>4. 设计模式简介</h2><ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/blog/post/50daec4.html</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>1. http 响应码 301 和 302 代表的是什么？有什么区别？</h2><ul>
<li><p>301：永久重定向。</p>
</li>
<li><p>302：暂时重定向。</p>
</li>
<li><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-forward-和-redirect-的区别？"><a href="#2-forward-和-redirect-的区别？" class="headerlink" title="2. forward 和 redirect 的区别？"></a>2. forward 和 redirect 的区别？</h2><ul>
<li>forward 是转发 和 redirect 是重定向：</li>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h2 id="3-简述-tcp-和-udp-的区别？"><a href="#3-简述-tcp-和-udp-的区别？" class="headerlink" title="3. 简述 tcp 和 udp 的区别？"></a>3. 简述 tcp 和 udp 的区别？</h2><ul>
<li><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
</li>
<li><p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
</li>
</ul>
<h2 id="4-tcp-为什么要三次握手-两次不行吗？为什么？"><a href="#4-tcp-为什么要三次握手-两次不行吗？为什么？" class="headerlink" title="4. tcp 为什么要三次握手,两次不行吗？为什么？"></a>4. tcp 为什么要三次握手,两次不行吗？为什么？</h2><ul>
<li>如果采用两次握手，<ul>
<li>那么只要服务器发出确认数据包就会建立连接，</li>
<li>但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，</li>
<li>这样服务器端就白白浪费了一定的资源。</li>
</ul>
</li>
<li>若采用三次握手，<ul>
<li>服务器端没有收到来自客户端的再此确认，</li>
<li>则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-tcp-粘包是怎么产生的？"><a href="#5-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="5. 说一下 tcp 粘包是怎么产生的？"></a>5. 说一下 tcp 粘包是怎么产生的？</h2><ul>
<li>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
</li>
</ul>
<h2 id="6-OSI-的七层模型都有哪些？"><a href="#6-OSI-的七层模型都有哪些？" class="headerlink" title="6. OSI 的七层模型都有哪些？"></a>6. OSI 的七层模型都有哪些？</h2><ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h2 id="7-get-和-post-请求有哪些区别？"><a href="#7-get-和-post-请求有哪些区别？" class="headerlink" title="7. get 和 post 请求有哪些区别？"></a>7. get 和 post 请求有哪些区别？</h2><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h2 id="8-如何实现跨域？"><a href="#8-如何实现跨域？" class="headerlink" title="8. 如何实现跨域？"></a>8. 如何实现跨域？</h2><ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
<h2 id="9-说一下-JSONP-实现原理？"><a href="#9-说一下-JSONP-实现原理？" class="headerlink" title="9. 说一下 JSONP 实现原理？"></a>9. 说一下 JSONP 实现原理？</h2><ul>
<li>jsonp：JSON with Padding，</li>
<li>它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/blog/post/23a3bd72.html</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><blockquote>
<p>Java 的异常处理是通过 5 个关键字来实现的：try，catch，throw，throws，finally。</p>
</blockquote>
<h2 id="1-throw-和-throws-的区别？"><a href="#1-throw-和-throws-的区别？" class="headerlink" title="1. throw 和 throws 的区别？"></a>1. throw 和 throws 的区别？</h2><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<a id="more"></a>

<h2 id="2-final、finally、finalize-有什么区别？"><a href="#2-final、finally、finalize-有什么区别？" class="headerlink" title="2. final、finally、finalize 有什么区别？"></a>2. final、finally、finalize 有什么区别？</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="3-try-catch-finally-中哪个部分可以省略？"><a href="#3-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3. try-catch-finally 中哪个部分可以省略？"></a>3. try-catch-finally 中哪个部分可以省略？</h2><ul>
<li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，</li>
<li>也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li>
</ul>
<h2 id="4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？"><a href="#4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？" class="headerlink" title="4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？"></a>4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？</h2><ul>
<li>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</li>
</ul>
<h2 id="5-常见的异常类有哪些？"><a href="#5-常见的异常类有哪些？" class="headerlink" title="5. 常见的异常类有哪些？"></a>5. 常见的异常类有哪些？</h2><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web</title>
    <url>/blog/post/fb60fea1.html</url>
    <content><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="1-jsp-和-servlet-有什么区别？"><a href="#1-jsp-和-servlet-有什么区别？" class="headerlink" title="1. jsp 和 servlet 有什么区别？"></a>1. jsp 和 servlet 有什么区别？</h2><ul>
<li>JSP是servlet技术的扩展，本质上就是servlet的简易方式。</li>
<li>servlet和JSP最主要的不同点在于，<ul>
<li>servlet的应用逻辑是在Java文件中，并且完全从表示层中的html里分离开来，</li>
<li>而JSP的情况是Java和html可以组合成一个扩展名为JSP的文件。</li>
</ul>
</li>
<li>JSP侧重于视图，servlet主要用于控制逻辑。</li>
</ul>
<a id="more"></a>

<h2 id="2-jsp-有哪些内置对象？作用分别是什么？"><a href="#2-jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="2. jsp 有哪些内置对象？作用分别是什么？"></a>2. jsp 有哪些内置对象？作用分别是什么？</h2><ul>
<li>JSP有9大内置对象：<ul>
<li>request：封装客户端的请求，其中包含来自get或post请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面对象（相当于java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
</li>
</ul>
<h2 id="3-说一下-jsp-的-4-种作用域？"><a href="#3-说一下-jsp-的-4-种作用域？" class="headerlink" title="3. 说一下 jsp 的 4 种作用域？"></a>3. 说一下 jsp 的 4 种作用域？</h2><ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li>application：代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="4-session-和-cookie-有什么区别？"><a href="#4-session-和-cookie-有什么区别？" class="headerlink" title="4. session 和 cookie 有什么区别？"></a>4. session 和 cookie 有什么区别？</h2><ul>
<li>存储位置不同：session存储在服务器端；cookie存储在浏览器端。</li>
<li>安全性不同：cookie安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie有容量限制，每个站点下的cookie也有个数限制。</li>
<li>存储的多样性：session可以存储在Redis中、数据库中、应用程序中；而cookie只能存储在浏览器中。</li>
</ul>
<h2 id="5-说一下-session-的工作原理？"><a href="#5-说一下-session-的工作原理？" class="headerlink" title="5. 说一下 session 的工作原理？"></a>5. 说一下 session 的工作原理？</h2><ul>
<li>session的工作原理是客户端登录完成之后，服务器会创建对应的session，</li>
<li>session创建完之后，会把session的id发送给客户端，客户端再存储到浏览器中。</li>
<li>这样客户端每次访问服务器时，都会带着sessionid，服务器拿到sessionid之后，</li>
<li>在内存找到与之对应的session这样就可以正常工作了。</li>
</ul>
<h2 id="6-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#6-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="6. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</h2><ul>
<li>可以用，session只是依赖cookie存储sessionid，如果cookie被禁用了，</li>
<li>可以使用url中添加sessionid的方式保证session能正常使用。</li>
</ul>
<h2 id="7-spring-mvc-和-struts-的区别是什么？"><a href="#7-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="7. spring mvc 和 struts 的区别是什么？"></a>7. spring mvc 和 struts 的区别是什么？</h2><ul>
<li>拦截级别：struts2是类级别的拦截；spring mvc是方法级别的拦截。</li>
<li>数据独立性：spring mvc的方法之间基本上独立的，独享request和response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量；而struts2虽然方法之间也是独立的，但其所有action变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li>
<li>拦截机制：struts2有以自己的interceptor机制，spring mvc用的是独立的aop方式，这样导致struts2的配置文件量比spring mvc大。</li>
<li>对ajax的支持：spring mvc集成了ajax，所有ajax使用很方便，只需要一个注解@ResponseBody就可以实现了；而struts2一般需要安装插件或者自己写代码才行。</li>
</ul>
<h2 id="8-如何避免-sql-注入？"><a href="#8-如何避免-sql-注入？" class="headerlink" title="8. 如何避免 sql 注入？"></a>8. 如何避免 sql 注入？</h2><ul>
<li>使用预处理PreparedStatement。</li>
<li>使用正则表达式过滤掉字符中的特殊字符。</li>
</ul>
<h2 id="9-什么是-XSS-攻击-如何避免？"><a href="#9-什么是-XSS-攻击-如何避免？" class="headerlink" title="9. 什么是 XSS 攻击,如何避免？"></a>9. 什么是 XSS 攻击,如何避免？</h2><ul>
<li><p>XSS攻击：即跨站脚本攻击，它是Web程序中常见的漏洞。</p>
<ul>
<li>原理是攻击者往Web页面里插入恶意的脚本代码（css代码、JavaScript代码等），</li>
<li>当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，</li>
<li>如盗取用户cookie、破坏页面结构、重定向到其他网站等。</li>
</ul>
</li>
<li><p>预防XSS的核心是必须对输入的数据做过滤处理。</p>
</li>
</ul>
<h2 id="10-什么是-CSRF-攻击-如何避免？"><a href="#10-什么是-CSRF-攻击-如何避免？" class="headerlink" title="10. 什么是 CSRF 攻击,如何避免？"></a>10. 什么是 CSRF 攻击,如何避免？</h2><ul>
<li>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品、虚拟货币转账等。</li>
<li>防御手段：<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加token并验证。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>对象拷贝</title>
    <url>/blog/post/ee837b98.html</url>
    <content><![CDATA[<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><h2 id="1-为什么要使用克隆？"><a href="#1-为什么要使用克隆？" class="headerlink" title="1. 为什么要使用克隆？"></a>1. 为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了</p>
<a id="more"></a>

<h2 id="2-如何实现对象克隆？"><a href="#2-如何实现对象克隆？" class="headerlink" title="2. 如何实现对象克隆？"></a>2. 如何实现对象克隆？</h2><ul>
<li><p>实现Cloneable接口并重写Object类中的clone()方法。</p>
</li>
<li><p>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
</li>
</ul>
<h2 id="3-深拷贝和浅拷贝区别是什么？"><a href="#3-深拷贝和浅拷贝区别是什么？" class="headerlink" title="3. 深拷贝和浅拷贝区别是什么？"></a>3. 深拷贝和浅拷贝区别是什么？</h2><ul>
<li>在浅克隆中，<ul>
<li>如果原型对象的成员变量是值类型，将复制一份给克隆对象；</li>
<li>如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，</li>
<li>也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</li>
<li>(在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。)</li>
</ul>
</li>
<li>在深克隆中，<ul>
<li>无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，</li>
<li>深克隆将原型对象的所有引用对象也复制一份给克隆对象。</li>
<li>(在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/blog/post/7af799fd.html</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h2><ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
</ul>
<a id="more"></a>

<h2 id="2-什么是-java-序列化？什么情况下需要序列化？"><a href="#2-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="2. 什么是 java 序列化？什么情况下需要序列化？"></a>2. 什么是 java 序列化？什么情况下需要序列化？</h2><ul>
<li><p>序列化简单来说就<strong>保存对象在内存中的状态</strong>也可以说是<strong>实例化变量</strong>。这是 Java 提供的用来<strong>保存 Object state</strong>，一种保存对象状态的机制。只有实现了 serializable 接口的类的对象才能被实例化。</p>
<ul>
<li>1 当你想把内存中的对象写入到硬盘时</li>
<li>2 当你想用套接字在网络上传输对象时</li>
<li>3 当你想通过 RMI （远程方法调用） 调用对象时</li>
</ul>
<p>​ （RMI 是什么东西？）：RMI 总结来说就是远程调用对象，在一个 jvm 上调用另一个 jvm 的对象。</p>
</li>
</ul>
<h2 id="3-动态代理是什么？有哪些应用？"><a href="#3-动态代理是什么？有哪些应用？" class="headerlink" title="3. 动态代理是什么？有哪些应用？"></a>3. 动态代理是什么？有哪些应用？</h2><ul>
<li>动态代理是运行时动态生成的代理类。</li>
<li>动态代理的应用有spring aop、hibernate数据查询、测试框架的后端mock、rpc、Java注解对象获取等。</li>
</ul>
<h2 id="4-怎么实现动态代理？"><a href="#4-怎么实现动态代理？" class="headerlink" title="4. 怎么实现动态代理？"></a>4. 怎么实现动态代理？</h2><ul>
<li>JDK原生态代理和cglib动态代理。</li>
<li>JDK原生动态代理是基于接口实现的，</li>
<li>cglib是基于继承当前类的子类实现的。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/blog/post/5729df21.html</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1. 并行和并发有什么区别？"></a>1. 并行和并发有什么区别？</h2><ul>
<li><p>并发:一个处理器同时处理多个任务；</p>
</li>
<li><p>并行:多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
</ul>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生</p>
</blockquote>
<a id="more"></a>

<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2. 线程和进程的区别？"></a>2. 线程和进程的区别？</h2><ul>
<li>操作系统都支持运行多个任务，通常一个任务就是一个程序，而一个程序就是一个进程。当一个进程运行时，内部可能包括多个顺序执行流，每个顺序执行流就是一个线程。</li>
<li>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。</li>
<li>进程代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个进程可以包括多个线程。</li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong></li>
</ul>
<h2 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3. 守护线程是什么？"></a>3. 守护线程是什么？</h2><ul>
<li>在 Java 中有三类线程：主线程、User Thread(用户线程)、Daemon Thread(守护线程)；</li>
<li>守护线程指程序运行的时候在后台提供一种通用服务的线程，比如gc；</li>
<li>主线程和守护线程一起销毁，与用户线程互不影响。</li>
</ul>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4. 创建线程有哪几种方式？"></a>4. 创建线程有哪几种方式？</h2><ul>
<li><p>三种：继承 Thread 类创建线程类/通过 Runnable 接口创建线程类/通过 Callable 和 Future 创建线程</p>
</li>
<li><p>一、继承Thread类创建线程类</p>
<ol>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>二、通过Runnable接口创建线程类</p>
<ol>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>三、通过Callable和Future创建线程</p>
<ol>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</li>
</ol>
</li>
<li><p>采用实现 Runnable、Callable 接口的方式创建多线程时</p>
<ul>
<li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法</li>
</ul>
</li>
<li><p>使用继承 Thread 类的方式创建多线程时</p>
<ul>
<li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li>
<li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-runnable-和-callable-有什么区别？"><a href="#5-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="5. 说一下 runnable 和 callable 有什么区别？"></a>5. 说一下 runnable 和 callable 有什么区别？</h2><ul>
<li>Callable 规定的方法是 call(), Runnable 规定的方法是 run()</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。<br>Callable 接口也是位于 java.util.concurrent 包中。</li>
</ul>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6. 线程有哪些状态？"></a>6. 线程有哪些状态？</h2><p>在 Java 当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>第一是创建状态。在生成线程对象，并没有调用该对象的 start 方法，这是线程处于创建状态；</li>
<li>第二是就绪状态。当调用了线程对象的 start 方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态</li>
<li>第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。</li>
<li>第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend 等方法都可以导致线程阻塞。</li>
<li>第五是死亡状态。如果一个线程的 run 方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪状态。</li>
</ul>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7. sleep() 和 wait() 有什么区别？"></a>7. sleep() 和 wait() 有什么区别？</h2><ul>
<li>sleep 是 Thread 类的方法,wait 是 Object 类中定义的方法。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
<h2 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8. notify()和 notifyAll()有什么区别？"></a>8. notify()和 notifyAll()有什么区别？</h2><ul>
<li>唤醒线程，是将线程由等待池移动到锁池，</li>
<li>notifyAll 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。</li>
<li>notify 只会唤醒一个线程。</li>
</ul>
<h2 id="9-线程的-run-和-start-有什么区别？"><a href="#9-线程的-run-和-start-有什么区别？" class="headerlink" title="9. 线程的 run()和 start()有什么区别？"></a>9. 线程的 run()和 start()有什么区别？</h2><ol>
<li>start() 是启动一个新线程执行 run 代码，run() 是当前线程执行 run 代码；</li>
<li>start() 不能被重复调用，run() 可以</li>
<li>start() 中的 run 代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用 run() 必须等待其代码全部执行完才能继续执行下面的代码。</li>
<li>start() 实现了多线程，run() 没有实现多线程。</li>
</ol>
<h2 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10. 创建线程池有哪几种方式？"></a>10. 创建线程池有哪几种方式？</h2><ol>
<li>使用 ThreadPoolExecutor 的构造方法</li>
<li>Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执</li>
<li>Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ol>
<h2 id="11-线程池都有哪些状态？"><a href="#11-线程池都有哪些状态？" class="headerlink" title="11. 线程池都有哪些状态？"></a>11. 线程池都有哪些状态？</h2><p><img src="..%5Cpic%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="线程池的状态.jpg"></p>
<p>1、RUNNING<br>(1) 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(2) 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态，并且线程池中的任务数为 0！</p>
<p>2、 SHUTDOWN<br>(1) 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的 shutdown()接口时，线程池由 RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP<br>(1) 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的 shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING<br>(1) 状态说明：当所有的任务已终止，ctl 记录的”任务数量”为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 terminated()。terminated()在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated()函数来实现。<br>(2) 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。<br>当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED<br>(1) 状态说明：线程池彻底终止，就变成 TERMINATED 状态。<br>(2) 状态切换：线程池处在 TIDYING 状态时，执行完 terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<h2 id="12-线程池中-submit-和-execute-方法有什么区别？"><a href="#12-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="12. 线程池中 submit()和 execute()方法有什么区别？"></a>12. 线程池中 submit()和 execute()方法有什么区别？</h2><ul>
<li><p>execute 提交的方式只能提交一个 Runnable 的对象，且该方法的返回值是 void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过 ThreadFactory 主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</p>
</li>
<li><p>submit 提交的方式</p>
</li>
<li><p><t> Future<t> submit(Callable<t> task);而 Callable 接口中是一个有返回值的 call 方法。如果在线程的执行过程中发生了异常，get 会获取到异常的信息。</t></t></t></p>
</li>
<li><p>Future&lt;?&gt; submit(Runnable task);也可以提交一个 Runable 接口的对象，这样当调用 get 方法的时候，如果线程执行成功会直接返回 null，如果线程执行异常会返回异常的信息</p>
</li>
<li><p><t> Future<t> submit(Runnable task, T result);除了 task 之外还有一个 result 对象，</t></t></p>
<p>当线程正常结束的时候调用 Future 的 get 方法会返回 result 对象，当线程抛出异常的时候会获取到对应的异常的信息。</p>
</li>
</ul>
<h2 id="13-在-java-程序中怎么保证多线程的运行安全？"><a href="#13-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="13. 在 java 程序中怎么保证多线程的运行安全？"></a>13. 在 java 程序中怎么保证多线程的运行安全？</h2><ol>
<li>使用安全类，比如 Java. util. concurrent 下的类;</li>
<li>使用自动锁 synchronized;</li>
<li>使用手动锁 Lock.</li>
</ol>
<p>1、互斥同步<br>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<br>此外，ReentrantLock也是通过互斥来实现同步。在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。<br>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p>
<p>2、非阻塞同步<br>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。<br>非阻塞的实现CAS（CompareAndSwap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p>
<p>CAS缺点：<br>ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<br>ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>3、无需同步方案<br>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<p>1）可重入代码<br>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。<br>可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。<br>（类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）</p>
<p>2）线程本地存储 ThreadLocal<br>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。</p>
<h2 id="14-多线程-synchronized-锁的升级原理是什么？"><a href="#14-多线程-synchronized-锁的升级原理是什么？" class="headerlink" title="14. 多线程 synchronized 锁的升级原理是什么？"></a>14. 多线程 <strong>synchronized</strong> 锁的升级原理是什么？</h2><ul>
<li>synchronized 锁升级原理：<ul>
<li>在锁对象的对象头里面有一个 threadid 字段，</li>
<li>在第一次访问的时候 threadid 为空，</li>
<li>jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，</li>
<li>再次进入的时候会先判断 threadid 是否与其线程 id 一致，</li>
<li>如果一致, 则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，</li>
<li>通过自旋循环一定次数来获取锁，</li>
<li>执行一定次数之后，如果还没有正常获取到要使用的对象，</li>
<li>此时就会把锁从轻量级升级为重量级锁，</li>
<li>此过程就构成了 synchronized 锁的升级。</li>
</ul>
</li>
</ul>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h2 id="15-什么是死锁？"><a href="#15-什么是死锁？" class="headerlink" title="15. 什么是死锁？"></a>15. 什么是死锁？</h2><p>如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。<br>举例来说：有两个进程A和B,A持有资源a等待b资源，B持有资源b等待a资源，两个进程都在等待另一个资源的同时不释放资源，就形成死锁。<br>死锁的发生必须具备以下四个必要条件。</p>
<p>1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p>2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p>4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<h2 id="16-怎么防止死锁？"><a href="#16-怎么防止死锁？" class="headerlink" title="16. 怎么防止死锁？"></a>16. 怎么防止死锁？</h2><blockquote>
<p>处理死锁的思路如下：</p>
</blockquote>
<p>预防死锁：<br>破坏四个必要件中的一个或多个来预防死锁</p>
<p>避免死锁：<br>在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。</p>
<p>检测死锁：<br>运行时产生死锁，及时发现思索，将程序解脱出来。</p>
<p>解除死锁：<br>发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程</p>
<blockquote>
<p>预防死锁的办法：</p>
</blockquote>
<p>破坏请求和保持条件：</p>
<ol>
<li>一次性的申请所有资源。之后不在申请资源，如果不满足资源条件则得不到资源分配。</li>
<li>只获得初期资源运行，之后将运行完的资源释放，请求新的资源。</li>
</ol>
<blockquote>
<p>破坏不可抢占条件：</p>
</blockquote>
<p>当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。</p>
<blockquote>
<p>死锁的解除办法：</p>
<ol>
<li>抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li>
<li>终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。</li>
</ol>
</blockquote>
<h2 id="17-ThreadLocal-是什么？有哪些使用场景？"><a href="#17-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="17. ThreadLocal 是什么？有哪些使用场景？"></a>17. ThreadLocal 是什么？有哪些使用场景？</h2><ul>
<li><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
</li>
<li><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
</li>
</ul>
<h2 id="18-说一下-synchronized-底层实现原理？"><a href="#18-说一下-synchronized-底层实现原理？" class="headerlink" title="18. 说一下 synchronized 底层实现原理？"></a>18. 说一下 synchronized 底层实现原理？</h2><ul>
<li>synchronized 是由一对 monitorenter/monitorexit 指令实现的，</li>
<li>monitor 对象是同步的基本实现单元。</li>
<li>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，</li>
<li>因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。</li>
<li>但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，</li>
<li>也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</li>
</ul>
<h2 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h2><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="20-synchronized-和-Lock-有什么区别？"><a href="#20-synchronized-和-Lock-有什么区别？" class="headerlink" title="20. synchronized 和 Lock 有什么区别？"></a>20. synchronized 和 Lock 有什么区别？</h2><ul>
<li><p>synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p>
</li>
<li><p>Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p>
</li>
</ul>
<blockquote>
<p>synchronized和Lock比较</p>
</blockquote>
<ul>
<li>synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="21-synchronized-和-ReentrantLock-区别是什么？"><a href="#21-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="21. synchronized 和 ReentrantLock 区别是什么？"></a>21. synchronized 和 ReentrantLock 区别是什么？</h2><blockquote>
<p>两者的共同点：</p>
</blockquote>
<p>1）协调多线程对共享对象、变量的访问</p>
<p>2）可重入，同一线程可以多次获得同一个锁</p>
<p>3）都保证了可见性和互斥性</p>
<blockquote>
<p>两者的不同点：</p>
</blockquote>
<p>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁</p>
<p>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</p>
<p>3）ReentrantLock是API级别的，synchronized是JVM级别的</p>
<p>4）ReentrantLock可以实现公平锁</p>
<p>5）ReentrantLock通过Condition可以绑定多个条件</p>
<p>6）底层实现不一样 synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>
<h2 id="22-说一下-atomic-的原理？"><a href="#22-说一下-atomic-的原理？" class="headerlink" title="22. 说一下 atomic 的原理？"></a>22. 说一下 atomic 的原理？</h2><ul>
<li>atomic 主要利用 CAS (Compare And Swap) 和 volatile 和 native 方法来保证原子操作，</li>
<li>从而避免 synchronized 的高开销，执行效率大为提升。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>容器</title>
    <url>/blog/post/8f8103b7.html</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul>
<li><a href="https://blog.csdn.net/dengpeng0419/article/details/47983033" target="_blank" rel="noopener">链接</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院的 java 集合</a></li>
</ul>
<a id="more"></a>

<h2 id="1-java-容器都有哪些？"><a href="#1-java-容器都有哪些？" class="headerlink" title="1. java 容器都有哪些？"></a>1. java 容器都有哪些？</h2><blockquote>
<p>Java 容器类类库的用途是“持有对象”，并将其划分为两个不同的概念：</p>
<p>1）Collection集合接口，<br>List 必须按照插入的顺序保存元素，<br>Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p>
<p>2）Map是用来存储成对的“键值”组合容器，允许你使用键来查找值。</p>
</blockquote>
<pre><code>├Collection
│├List
││├LinkedList
││├ArrayList
││└Vector
││ └Stack
│└Set
│ ├HashSet
│ ├TreeSet
│ └LinkedSet
│
└Map
 ├Hashtable
 ├HashMap
 └WeakHashMap</code></pre><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol>
<li>java.util.Collection 是一个集合接口。<ul>
<li>提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collection 接口在 Java 类库中有很多具体的实现。</li>
<li>Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Collection</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├List</span><br><span class="line">│├LinkedList</span><br><span class="line">│├ArrayList</span><br><span class="line">│└Vector</span><br><span class="line">│　└Stack</span><br><span class="line">└Set</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>java.util.Collections 是一个包装类。<ul>
<li>包含有各种有关集合操作的静态多态方法。</li>
<li>此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</li>
</ul>
</li>
</ol>
<h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><table>
<thead>
<tr>
<th>比较</th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td align="center">collection</td>
<td align="center">collection</td>
<td align="center"></td>
</tr>
<tr>
<td>常见实现类</td>
<td align="center">AbstractList(其常用子类有 ArrayList、LinkedList、Vector)</td>
<td align="center">AbstractSet(其常用子类有 HashSet、LinkedHashSet、TreeSet)</td>
<td align="center">HashMap、HashTable、TreeMap</td>
</tr>
<tr>
<td>常见方法</td>
<td align="center">add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td align="center">add( )、remove( )、clear( )、contains( )、size( )</td>
<td align="center">put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td align="center">可重复</td>
<td align="center">不可重复(用<code>equals()</code>判断)</td>
<td align="center">不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td align="center">有序</td>
<td align="center">无序(实际上由 HashCode 决定)</td>
<td align="center"></td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">Vector 线程安全</td>
<td align="center"></td>
<td align="center">Hashtable 线程安全</td>
</tr>
</tbody></table>
<h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><blockquote>
<p><strong>相同点：</strong></p>
<ul>
<li>HashMap 和 Hashtable 都实现了接口 Map, Cloneable, Serializable；</li>
<li>都是将键映射到值的集合对象，其中键与值都是对象，不能包含重复键，但可以包含重复值。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>区别如下：</strong></p>
<ul>
<li>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许；</li>
<li>HashTable 继承自 Dictionary 类，而 HashMap 继承自 AbstractMap 类；</li>
<li>HashTable 的方法使用 synchronized 修饰，是线程安全的， HashMap 线程不安全。</li>
</ul>
</blockquote>
<h2 id="5-如何决定使用-HashMap-还是-TreeMap？"><a href="#5-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使用 HashMap 还是 TreeMap？"></a>5. 如何决定使用 HashMap 还是 TreeMap？</h2><ul>
<li>TreeMap&lt;K,V&gt; 内存储的 Key 是有序的，其 Key 值是要求实现 java.lang.Comparable，所以迭代的时候 TreeMap 默认是按照 Key 值升序排序的；TreeMap 的实现也是基于红黑树结构。</li>
<li>HashMap&lt;K,V&gt;的 Key 值实现散列 hashCode(),分布是散列的均匀的，不支持排序；数据结构主要是桶(数组),链表或红黑树。</li>
<li>大多情况下 HashMap 有更好的性能，所以大多不需要排序的时候我们会使用 HashMap.</li>
</ul>
<h2 id="6-说一下-HashMap-的实现原理？"><a href="#6-说一下-HashMap-的实现原理？" class="headerlink" title="6. 说一下 HashMap 的实现原理？"></a>6. 说一下 HashMap 的实现原理？</h2><ul>
<li>底层实现是数组+链表，JDK8 以后是数组+链表+红黑树；</li>
<li>当我们往 HashMap 中 put 元素的时候，会将新元素存进去，如果存在相等的 Key 则会替换原先的值；</li>
<li>根据 Key的 hash 值得到这个元素在数组中的位置（即下标），</li>
<li>如果数组该位置上已经存放有其他元素了，</li>
<li>那么在这个位置上的元素将以链表的形式存放，</li>
<li>新加入的放在链头，最先加入的放在链尾；</li>
<li>如果链表长度大于等于7 ，则会将链表转换成红黑树；</li>
<li>如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li>
</ul>
<h2 id="7-说一下-HashSet-的实现原理？"><a href="#7-说一下-HashSet-的实现原理？" class="headerlink" title="7. 说一下 HashSet 的实现原理？"></a>7. 说一下 HashSet 的实现原理？</h2><p>底层使用HashMap实现</p>
<h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul>
<li>ArrayList 是实现了基于动态数组的结构；</li>
<li>LinkedList 则是基于实现链表的数据结构；</li>
<li>数据的更新和查找，ArrayList 效率高于 LinkedList，ArrayList 可以根据下标快速定位， LinkedList 只能从头依次查询；</li>
<li>数据的增加和删除，LinkedList效率更高一些，ArrayList 需要同时变更其后的数据下标， LinkedList只需变更前后节点的下一步引用。</li>
</ul>
<h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul>
<li>list 转数组， List 的方法 toArray;</li>
<li>数组转 list， Arrays 的方法 asList.</li>
</ul>
<h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul>
<li>ArrayList 和 Vector 都继承了 AbstractList，都实现了接口List, RandomAccess, Cloneable, Serializable；</li>
<li>Vector 中的方法大多使用 synchronized 关键字修饰，是线程安全的， ArrayList 是线程不安全的。</li>
</ul>
<h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><blockquote>
<p>存储内容比较：</p>
<ul>
<li>​ Array 数组可以包含基本类型和对象类型，</li>
<li>​ ArrayList 却只能包含对象类型。</li>
</ul>
</blockquote>
<blockquote>
<p>空间大小比较：</p>
<ul>
<li>它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。</li>
<li>ArrayList 的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。</li>
</ul>
</blockquote>
<h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul>
<li>Queue 队列是一个先入先出（FIFO）的数据结构;</li>
<li><strong>remove</strong> 移除并返回队列头部的元素如果队列为空，则抛出一个 NoSuchElementException 异常;</li>
<li><strong>poll</strong> 移除并返问队列头部的元素如果队列为空，则返回 null.</li>
</ul>
<h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Hashtable, ConcurrentHashMap, Vector, Stack</p>
<h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><ul>
<li>Iterator接口提供遍历任何Collection的接口；</li>
<li>Collection的实现类使用迭代器方法来获取迭代器实例；</li>
<li>迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<h2 id="15-Iterator-怎么使用？有什么特点？"><a href="#15-Iterator-怎么使用？有什么特点？" class="headerlink" title="15. Iterator 怎么使用？有什么特点？"></a>15. Iterator 怎么使用？有什么特点？</h2><ul>
<li>Java 中使用 Iterator 来遍历集合元素，Iterator 遍历集合元素有以下几个特点:<ul>
<li>Iterator 遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出 ConcurrentModificationEception 的异常。</li>
<li>Iterator 遍历集合元素的过程中可以通过 remove 方法来移除集合中的元素。</li>
<li>Iterator 必须依附某个 Collection 对象而存在，Iterator 本身不具有装载数据对象的功能。</li>
<li>Iterator.remove 方法删除的是上一次 Iterator.next()方法返回的对象。</li>
<li>强调以下 next（）方法，该方法通过游标指向的形式返回 Iterator 下一个元素。</li>
</ul>
</li>
<li><strong>Iterator 的常用方法</strong>:<ul>
<li>boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回 true</li>
<li>Object next(); 返回迭代器中下一个元素</li>
<li>void remove() ; 删除集合里上一个 next 方法调用的时候返回的对象元素</li>
<li>void forEachRemaining(Consumer action) ;使用 Lambdda 表达式的形式输出 Iterator 中所以的元素。注意该方法其实是间接调用 next()方法进行遍历，所以再次是 next（）方法的时候 Iterator 中的对象已经被遍历完了。</li>
</ul>
</li>
</ul>
<h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><p>一．相同点</p>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。</li>
</ul>
<p>二．不同点</p>
<ol>
<li>使用范围不同，Iterator 可以应用于所有的集合，Set、List 和 Map 和这些集合的子类型。而 ListIterator 只能用于 List 及其子类型。</li>
<li>ListIterator 有 add 方法，可以向 List 中添加对象，而 Iterator 不能。</li>
<li>ListIterator 和 Iterator 都有 hasNext()和 next()方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious()和 previous()方法，可以实现逆向（顺序向前）遍历。Iterator 不可以。</li>
<li>ListIterator 可以定位当前索引的位置，nextIndex()和 previousIndex()可以实现。Iterator 没有此功能。</li>
<li>都可实现删除操作，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iterator 仅能遍历，不能修改。</li>
</ol>
<h2 id="17-怎么确保一个集合不能被修改？"><a href="#17-怎么确保一个集合不能被修改？" class="headerlink" title="17. 怎么确保一个集合不能被修改？"></a>17. 怎么确保一个集合不能被修改？</h2><ul>
<li>利用 Collections 提供的 unmodifiableCollection 方法</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/blog/post/f7ede91d.html</url>
    <content><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h2><ul>
<li>JDK:Java Development Kit--面向开发人员的 SDK.它提供了 JAVA 的开发环境和运行环境<blockquote>
<p>SDK:Software Development Kit--软件开发包</p>
</blockquote>
</li>
<li>JRE:Java Runtime Environment--面向使用者.提供了 JAVA 的运行环境，包含JVM</li>
<li>JVM:Java Virtual Machine--是我们常说的 Java 虚拟机</li>
</ul>
<a id="more"></a>

<h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h2><ul>
<li>==：基本数据类型比较的是数值，引用类型比较的是内存地址是否相等；</li>
<li>equals：是调用equals方法来比较两个对象<ol>
<li>在没有重写equals方法的情况下，默认调用Object类的equals方法，实际上使用==来比较对象的内存地址；</li>
<li>字符串重写了equals方法，比较的是两个字符串的内容是否一致。</li>
</ol>
</li>
</ul>
<h2 id="3-两个对象的-hashCode-相同-则-equals-也一定为-true-对吗？"><a href="#3-两个对象的-hashCode-相同-则-equals-也一定为-true-对吗？" class="headerlink" title="3. 两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？"></a>3. 两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？</h2><ul>
<li>不对。</li>
<li>需要注意的是当 equals 方法被重写时, hashCode 方法也要被重写.</li>
<li>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<ol>
<li>相等(相同)的对象必须具有相等的哈希码(或者散列码).</li>
<li>如果两个对象的 hashCode 相同,它们并不一定相同.</li>
</ol>
</li>
</ul>
<h2 id="4-final-在-java-中有什么作用？"><a href="#4-final-在-java-中有什么作用？" class="headerlink" title="4. final 在 java 中有什么作用？"></a>4. final 在 java 中有什么作用？</h2><ul>
<li>final 的作用是告诉编译器一块数据是恒定不变得；</li>
<li>final 修饰的类不能被集成，final 类的方法默认都是 final 修饰的，但 final 类的成员变量默认不是final的；</li>
<li>final 修饰方法不能被子类重写，但可以被子类继承；</li>
<li>final 修饰的成员变量表示常量，只能被赋值一次，初次赋值后值不能再被改变；</li>
<li>final 不能修饰构造方法。</li>
</ul>
<h2 id="5-java-中的-Math-round-1-5-等于多少？"><a href="#5-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. java 中的 Math.round(-1.5) 等于多少？"></a>5. java 中的 Math.round(-1.5) 等于多少？</h2><ul>
<li>Math.round(11.5)的返回值是 12,Math.round(-11.5)的返回值是-11.</li>
<li>四舍五入的原理是在参数上加 0.5 然后进行下取整.</li>
</ul>
<h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h2><ul>
<li>基础数据类型 8 种：byte、short、int、long、float、double、char、boolean</li>
<li>String 是对象,是引用类型.</li>
</ul>
<h2 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. java 中操作字符串都有哪些类？它们之间有什么区别？</h2><ul>
<li>主要有三种, String, StringBuffer, StringBuilder；</li>
<li>String使用final修饰，所用方法都是返回new String，因此对String对象的任何修改操作都会生成新对象，不会影响原对象；</li>
<li>StringBuffer对字符串操作的方法都加了synchronized关键字，保证线程安全；</li>
<li>StringBuilder不保证线程安全；</li>
<li>对于操作效率而言,一般来说,StringBuilder 大于 StringBuffer 大于 String；</li>
<li>对于线程安全而言,StringBuffer 是线程安全的；而 StringBuilder 是非线程安全的；</li>
<li>对于频繁的字符串操作而言,无论是 StringBuffer 还是 StringBuilder,都优于 String.</li>
</ul>
<h2 id="8-String-str-quot-i-quot-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-quot-i-quot-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=&quot;i&quot;与 String str=new String(“i”)一样吗？"></a>8. String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</h2><ul>
<li>String str = &quot;a&quot;, 内存中如果有“a&quot;,str 就指向它；如果没有,才创建“a”，str指向被创建的“a”;</li>
<li>String str = new String(&quot;a&quot;), 是构造一个 String 对象指向“a”,再将新对象的地址赋给 str.</li>
</ul>
<h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><ul>
<li>利用 StringBuffer 的 reverse 方法</li>
<li>将字符串，从后向前遍历一遍</li>
<li>将字符串，依次放入栈里，再从栈里读出</li>
<li>二分法，将字符串的前后一半分别翻转，再组合在一起</li>
</ul>
<h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回字符串是否长度为0</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回字符串某一位的字符 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 提取子串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串比较</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串是否相等</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anotherObject)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回特定字符在字符串中首次出现的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch/String str)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串转换成小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//字符串转换成大写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 替换特殊的子字符串成新的子字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 去除字符串两端的空格</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 根据特定表达式分割字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><ul>
<li>抽象类不一定要有抽象方法；</li>
<li>用 abstract 修饰的类就是抽象类,即使一个类中的方法全部实现过,也可以用 abstract 修饰为抽象类,所以抽象类不一定都有抽象方法.</li>
<li>延伸：因为真有一种情况可以将类定义为 static 类型的,那就是内部类.</li>
</ul>
<h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul>
<li>1、普通类可以去实例化调用；抽象类不能被实例化,因为它是存在于一种概念而不非具体.</li>
<li>2、普通类和抽象类都可以被继承,但是抽象类被继承后子类必须重写继承的抽象方法,除非自类也是抽象类.</li>
<li>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法.</li>
<li>注意,抽象类和普通类的主要有三点区别：<ul>
<li>1)抽象方法必须为 public 或者 protected,缺省情况下默认为 public.(因为如果为 private,则不能被子类继承,子类便无法实现该方法)</li>
<li>2)抽象类不能用来创建对象；</li>
<li>3)如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法.如果子类没有实现父类的抽象方法,则必须将子类也定义为为 abstract 类.</li>
</ul>
</li>
</ul>
<h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h2><ul>
<li>不能,抽象类是为了让子类继承之后重写其方法的,而用 final 修饰的类,无法被继承</li>
</ul>
<h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认方法实现</td>
<td>抽象类可以有默认的方法实现</td>
<td>接口不能有默认的方法实现。java8以后有特别</td>
</tr>
<tr>
<td>实现</td>
<td>抽象类的子类使用 extends 来继承</td>
<td>接口必须使用 implements 来实现接口</td>
</tr>
<tr>
<td>构造函数</td>
<td>抽象类可以有构造函数</td>
<td>接口不能有</td>
</tr>
<tr>
<td>main 方法</td>
<td>抽象类可以有 main 方法，并且我们能运行它</td>
<td>接口不能有 main 方法</td>
</tr>
<tr>
<td>实现数量</td>
<td>类只能有一个抽象类</td>
<td>类可以有多个接口</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口中的方法默认使用 public 修饰</td>
</tr>
</tbody></table>
<h2 id="15-java-中-IO-流分为几种？"><a href="#15-java-中-IO-流分为几种？" class="headerlink" title="15. java 中 IO 流分为几种？"></a>15. java 中 IO 流分为几种？</h2><ul>
<li>按功能划分：输入流、输出流</li>
<li>按类型划分：字符流、字节流</li>
</ul>
<h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h2><ul>
<li>java支持方面<ul>
<li>同步阻塞的 BIO, 服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善;</li>
<li>同步非阻塞的 NIO, 服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理;</li>
<li>异步非阻塞的 AIO, 服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.</li>
</ul>
</li>
<li>适用场景<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
</li>
</ul>
<h2 id="17-Files-的常用方法都有哪些？"><a href="#17-Files-的常用方法都有哪些？" class="headerlink" title="17. Files 的常用方法都有哪些？"></a>17. Files 的常用方法都有哪些？</h2><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>判断 File 对象对应的文件或者目录是否存在若存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除 File 对象对应的文件或者目录若成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>当 File 对象对应的文件不存在时，该方法将新建一个此 File 对象所指定的新文件若创建成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回 File 对象表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>String getPath()</td>
<td>返回 File 对象对应的路径</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>返回 File 对象对应的绝对路径（在 UNIX/Linux 等系统上，如果路径是以正斜线 / 开始的，则这个路径是绝对路径；在 Windows 等系统上，如果路径是从盘符开始的，则这个路径是绝对路径）</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回 File 对象对应目录的父目录，（即返回的目录不包含最后一级子目录）</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断 File 对象对应的文件或者目录是否可读若可读则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断 File 对象对应的文件或者目录是否可写。若可写则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断 File 对象对应的是否是文件（不是目录）若是文件则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断 File 对象对应的是否是目录（不是文件）若是目录则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断 File 对象对应的文件或者目录是否是绝对路径</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>返回 1970 年 1 月 1 日 0 时 0 分 0 秒到文件最好修改时间的毫秒值</td>
</tr>
<tr>
<td>long length()</td>
<td>返回文件内容长度</td>
</tr>
<tr>
<td>String [ ]list()</td>
<td>返回指定目录的全部内容，只列出名称</td>
</tr>
<tr>
<td>File[ ] listFiles()</td>
<td>返回一个包含了 File 对象所有子文件和子目录的 File 数组</td>
</tr>
</tbody></table>
<h2 id="18-java-如何解决的多重继承"><a href="#18-java-如何解决的多重继承" class="headerlink" title="18. java 如何解决的多重继承"></a>18. java 如何解决的多重继承</h2><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征</p>
<ol>
<li>接口，实现多个接口；</li>
<li>内部类，使用多个内部类分别继承不同的类，向外提供内部类的方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
