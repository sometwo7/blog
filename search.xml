<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 搭建 blog</title>
    <url>/blog/post/41a885c9.html</url>
    <content><![CDATA[<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote>
<p>http://www.likekeep.me/post/62703.html</p>
</blockquote>
<blockquote>
<p>https://www.jianshu.com/p/efbeddc5eb19</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>反击爬虫，前端工程师的脑洞可以有多大？</title>
    <url>/blog/post/f2bb9475.html</url>
    <content><![CDATA[<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。<br>而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是<strong>爬虫与反爬虫</strong>这一话题的由来。</p>
<a id="more"></a>

<h3 id="2-常见反爬虫策略"><a href="#2-常见反爬虫策略" class="headerlink" title="2. 常见反爬虫策略"></a>2. 常见反爬虫策略</h3><p>但是世界上没有一个网站，能做到完美地反爬虫。</p>
<p>如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于<strong>后端</strong>，也是目前比较常规单有效的手段，比如：</p>
<ul>
<li>User-Agent + Referer检测</li>
<li>账号及Cookie验证</li>
<li>验证码</li>
<li>IP限制频次</li>
</ul>
<p>而爬虫是可以无限逼近于真人的，比如：</p>
<ul>
<li>chrome headless或phantomjs来模拟浏览器环境</li>
<li><a href="http://udn.yyuap.com/doc/ae/920457.html" target="_blank" rel="noopener">tesseract</a>识别验证码</li>
<li>代理IP淘宝就能买到</li>
</ul>
<p>所以我们说，100%的反爬虫策略？不存在的。<br>更多的是体力活，是个难易程度的问题。</p>
<p>不过作为前端工程师，我们可以增加一下游戏难度，设计出一些<strong>很(sang)有(xin)意(bing)思(kuang)</strong>的反爬虫策略。</p>
<h3 id="3-前端与反爬虫"><a href="#3-前端与反爬虫" class="headerlink" title="3. 前端与反爬虫"></a>3. 前端与反爬虫</h3><h4 id="3-1-font-face拼凑式"><a href="#3-1-font-face拼凑式" class="headerlink" title="3.1 font-face拼凑式"></a>3.1 font-face拼凑式</h4><p><strong>例子：<a href="http://maoyan.com/films/342601" target="_blank" rel="noopener">猫眼电影</a></strong></p>
<p>猫眼电影里，对于票房数据，展示的并不是纯粹的数字。<br>页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs" alt></p>
<p>并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579" alt></p>
<h4 id="3-2-background拼凑式"><a href="#3-2-background拼凑式" class="headerlink" title="3.2 background拼凑式"></a>3.2 background拼凑式</h4><p><strong>例子：<a href="http://www.meituan.com/dianying/342601?#content" target="_blank" rel="noopener">美团</a></strong></p>
<p>与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW" alt></p>
<p>并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。</p>
<p>页面A：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry" alt><br>页面B：<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL" alt></p>
<h4 id="3-3-字符穿插式"><a href="#3-3-字符穿插式" class="headerlink" title="3.3 字符穿插式"></a>3.3 字符穿插式</h4><p><strong>例子：<a href="https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&mid=2247484365&idx=4&sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&scene=4" target="_blank" rel="noopener">微信公众号文章</a></strong></p>
<p>某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。<br>这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。<br><img src="http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59" alt></p>
<p>对了，我的手机流量可以找谁报销吗？</p>
<h4 id="3-4-伪元素隐藏式"><a href="#3-4-伪元素隐藏式" class="headerlink" title="3.4 伪元素隐藏式"></a>3.4 伪元素隐藏式</h4><p><strong>例子：<a href="http://car.autohome.com.cn/config/series/3170.html" target="_blank" rel="noopener">汽车之家</a></strong></p>
<p>汽车之家里，把关键的厂商信息，做到了伪元素的content里。<br>这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5" alt></p>
<h4 id="3-5-元素定位覆盖式"><a href="#3-5-元素定位覆盖式" class="headerlink" title="3.5 元素定位覆盖式"></a>3.5 元素定位覆盖式</h4><p><strong>例子：<a href="https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&searchArrivalAirport=%E5%8C%97%E4%BA%AC&searchDepartureTime=2017-07-06&searchArrivalTime=2017-07-09&nextNDays=0&startSearch=true&fromCode=CAN&toCode=BJS&from=qunarindex&lowestPrice=null" target="_blank" rel="noopener">去哪儿</a></strong></p>
<p>还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个<code>i</code>标签渲染，再用两个<code>b</code>标签去绝对定位偏移量，覆盖故意展示错误的<code>i</code>标签，最后在视觉上形成正确的价格…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF" alt></p>
<p>这说明爬虫会解析css还不行，还得会做数学题。</p>
<h4 id="3-6-iframe异步加载式"><a href="#3-6-iframe异步加载式" class="headerlink" title="3.6 iframe异步加载式"></a>3.6 iframe异步加载式</h4><p><strong>例子：<a href="http://music.163.com/#/song?id=424477863" target="_blank" rel="noopener">网易云音乐</a></strong></p>
<p>网易云音乐页面一打开，html源码里几乎只有一个<code>iframe</code>，并且它的src是空白的：<code>about:blank</code>。接着js开始运行，把整个页面的框架异步塞到了iframe里面…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g" alt></p>
<p>不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。</p>
<h4 id="3-7-字符分割式"><a href="#3-7-字符分割式" class="headerlink" title="3.7 字符分割式"></a>3.7 字符分割式</h4><p><strong>例子：<a href="http://www.goubanjia.com/" target="_blank" rel="noopener">全网代理IP</a></strong></p>
<p>在一些展示代理IP信息的页面，对于IP的保护也是大费周折。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV" alt></p>
<p>他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p>
<h4 id="3-8-字符集替换式"><a href="#3-8-字符集替换式" class="headerlink" title="3.8 字符集替换式"></a>3.8 字符集替换式</h4><p><strong>例子：<a href="https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&arrCity=%E4%B8%8A%E6%B5%B7&goDate=2017-07-05&backDate=&sort=&airLine=&from=" target="_blank" rel="noopener">去哪儿移动侧</a></strong></p>
<p>同样会欺骗爬虫的还有去哪儿的移动版。</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb" alt></p>
<p>html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…</p>
<p><img src="http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq" alt></p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>01 | 基础架构：一条SQL查询语句是如何执行的？</title>
    <url>/blog/post/23046aa4.html</url>
    <content><![CDATA[<h1 id="01-基础架构：一条SQL查询语句是如何执行的？"><a href="#01-基础架构：一条SQL查询语句是如何执行的？" class="headerlink" title="01 | 基础架构：一条SQL查询语句是如何执行的？"></a>01 | 基础架构：一条SQL查询语句是如何执行的？</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p>比如，你有个最简单的表，表里只有一个ID字段，在执行上面这个查询语句时，我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。所以今天我想和你一起把MySQL拆解一下，看看里面都有哪些“零件”，希望借由这个拆解过程，让你对MySQL有更深入的理解。这样当我们碰到MySQL的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p><a id="more"></a>


<p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p>
<p><img src="/picture/content/mysql-01.png" alt="MySQL的逻辑架构图"></p>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL的逻辑架构图"></p>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认存储引擎。</p>
<p>也就是说，你执行create table 建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。不过，你也可以通过指定存储引擎的类型来选择别的引擎，比如在create table 语句中使用 engine=memory，来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同，在后面的文章中，我们会讨论到引擎的选择。</p>
<p>从图中不难看出，不同的存储引擎共用一个  <strong>Server</strong> 层，也就是从连接器到执行器的部分。你可以先对每个组件的名字有个印象，接下来我会结合开头提到的那条SQL语句，带你走一遍整个执行流程，依次看下每个组件的作用。</p>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure>

<p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄漏。如果你连的是生产服务器，强烈建议你不要这样做。</p>
<p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>
<ul>
<li>如果用户名或密码不对，你就会收到一个“Access denied for user”的错误，然后客户端程序结束执行。</li>
<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>
</ul>
<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用行的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p>
<p><img src="/picture/content/mysql-01-2.png" alt></p>
<p><img src="https://static001.geekbang.org/resource/image/f2/ed/f2da4aa3a672d48ec05df97b9f992fed.png" alt></p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p>
<p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒：Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p>
<p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p>
<p>1.定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p>
<p>2.如果你用的是MySQL5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二部：查询缓存。</p>
<p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<p>查询缓存的生效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure>

<p>需要注意的是，MySQL8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p>
<p>分析器先会做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p>
<p>MySQL从你输入的“select”这个关键字识别什么，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p>
<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，词法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p>
<p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;elect * from t where ID=1&apos; at line 1</span><br></pre></td></tr></table></figure>

<p>一般语法错误会提示第一个出现的错误的位置，所以你要关注的是紧接“use near”的内容。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure>

<ul>
<li>既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li>
<li>也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p>
<p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示（在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &apos;b&apos;@&apos;localhost&apos; for table &apos;T&apos;</span><br></pre></td></tr></table></figure>

<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在这些场景下，执行器调用一次，在引擎内部则扫描了多行，因此 <strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong> 我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>今天我给你介绍了MySQL的逻辑架构，希望你对一个SQL语句完成执行流程的各个阶段有了一个初步的印象。由于篇幅的限制，我只是用一个查询的列子将各个环节过了一遍。如果你还对每个环节的展开细节存有疑问，也不用担心，后续在实战章节中我还会再提到它们。</p>
<p>我给你留一个问题吧，如果表T中没有字段k，而你执行了这个语句select * from T where k=1,那肯定是会报“不存在这个列”的错误：“Unknown column ‘k’ in ‘where clause’ ”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>02 | 日志架构：一条SQL更新语句是如何执行的？</title>
    <url>/blog/post/5fc62eb9.html</url>
    <content><![CDATA[<h1 id="02-日志架构：一条SQL更新语句是如何执行的？"><a href="#02-日志架构：一条SQL更新语句是如何执行的？" class="headerlink" title="02 | 日志架构：一条SQL更新语句是如何执行的？"></a>02 | 日志架构：一条SQL更新语句是如何执行的？</h1><p>前面我们系统了解了一个查询语句的执行流程，并介绍了执行过程中涉及的处理模块。相信你还记得，一条查询语句的执行过程一般是经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p><p>那么，一条更新语句的执行流程又是怎样的呢？</p><p>之前你可能经常听DBA同事说，MySQL可以恢复到半个月内任意一秒的状态，惊叹的同时，你是不是心中也不免会好奇，这是怎样做到的呢？</p><a id="more"></a>


<p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure>

<p>如果要将ID = 2 这一行的值加1，SQL语句就会这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p>
<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="MySQL的逻辑架构图"></p>
<p>你执行语句前要先连接数据库，这是连接器的工作。</p>
<p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p>
<p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log 和binlog在设计上有很多有意思的地方，这些涉及思路也可以用到你自己的程序里。</p>
<h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>不知道你还记不记得《孔乙已》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p>
<p>如果有人要赊账或者还帐的话，掌柜一般有两种做法：</p>
<ul>
<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>
<li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本放出来核算。</li>
</ul>
<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回账本上。</p>
<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p>
<p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决整个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p>
<p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同事，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新帐腾出空间。</p>
<p>与此类似，InnoDB的redo log 是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这图所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png" alt></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>write pos 和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong> 。</p>
<p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>前面我们讲过，MySQL整体来看，其实就有两块：一块是Server层，它主要做的是MySQL功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p>
<p>我想你肯定会问，为什么会有两份日志呢？</p>
<p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然指依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log 来实现crash-safe能力。</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如 “给ID = 2这一行的c字段加1”。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。 “追加写” 是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p>
<ol>
<li>执行器先找引擎取ID = 2 这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID = 2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log 处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p>
<p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt></p>
<p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是“两阶段提交”。</p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起： <strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p>
<p>前面我们说过了，binlog会记录所有的逻辑操作，并且是采用 “追加写” 的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p>
<p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p>
<ul>
<li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li>
<li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li>
</ul>
<p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。<br>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p>
<p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>
<p>仍然用前面的update语句做例子。假设当前ID=2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p>
]]></content>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀网站记录</title>
    <url>/blog/post/e5ba9dfa.html</url>
    <content><![CDATA[<h2 id="计算机书籍"><a href="#计算机书籍" class="headerlink" title="计算机书籍"></a>计算机书籍</h2><ul>
<li><a href="https://itpanda.net/book/" target="_blank" rel="noopener">IT熊猫</a></li>
</ul>
]]></content>
      <categories>
        <category>website</category>
      </categories>
      <tags>
        <tag>nice web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础(汇总)</title>
    <url>/blog/post/8b7b30a1.html</url>
    <content><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>想要面试的初/中/想要面试的初/中/高级 Java 程序员<br>想要查漏补缺的人<br>想要不断完善和扩充自己 Java 技术栈的人<br>原本就掌握了技术却不知道怎么表达的人<br>有上进心,也愿意学习的人</p>
<p>一、 面试题覆盖全,且解析全面</p>
<p>这份面试题总内容包含了十九个模块：Java 基础、容器、多线程、反射、对象拷贝、Java Web 模块、异常、网络、设计模式、Spring/Spring MVC、Spring Boot/Spring Cloud、Hibernate、Mybatis、RabbitMQ、Kafka、Zookeeper、MySql、Redis、JVM .</p>
<a id="more"></a>

<p>具体面试题如下</p>
<h2 id="一、-Java-基础"><a href="#一、-Java-基础" class="headerlink" title="一、 Java 基础"></a>一、 Java 基础</h2><ol>
<li><p>JDK 和 JRE 有什么区别？</p>
<ul>
<li><p>JDK:Java Deveplment Kit--面向开发人员的 SDK.它提供了 JAVA 的开发环境和运行环境</p>
<blockquote>
<p>SDK:Software Devemplment Kit--软件开发包</p>
</blockquote>
</li>
<li><p>JRE:Java Runtime Enviroment--面向使用者.提供了 JAVA 的运行环境</p>
</li>
<li><p>JVM:Java virtual machine--是我们常说的 Java 虚拟机</p>
</li>
</ul>
</li>
<li><p>== 和 equals 的区别是什么？</p>
<ul>
<li>==：比较的是两个字符串内存地址(堆内存)的数值是否相等,属于数值比较；</li>
<li>equals()：比较的是两个字符串的内容,属于内容比较.</li>
</ul>
</li>
<li><p>两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？</p>
<ul>
<li>对于 Object 类来说,equals()方法在对象上实现的是差别可能性最大的等价关系,即,对于任意非 null 的引用值 x 和 y,当且仅当 x 和 y 引用的是同一个对象,该方法才会返回 true.</li>
<li>需要注意的是当 equals()方法被 override 时,hashCode()也要被 override.按照一般 hashCode()方法的实现来说,相等的对象,它们的 hash code 一定相等.</li>
<li>并不要求根据 equals(java.lang.Object)方法不相等的两个对象,调用二者各自的 hashCode()方法必须产生不同的 integer 结果.</li>
<li>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<ol>
<li>相等(相同)的对象必须具有相等的哈希码(或者散列码).</li>
<li>如果两个对象的 hashCode 相同,它们并不一定相同.</li>
</ol>
</li>
</ul>
</li>
<li><p>final 在 java 中有什么作用？</p>
<ul>
<li>一旦你将引用声明作 final,你将不能改变这个引用了</li>
<li>可以用来生命：可以声明成员变量、方法、类以及本地变量.</li>
<li>final 关键字提高了性能.JVM 和 Java 应用都会缓存 final 变量.</li>
<li>final 变量可以安全的在多线程环境下进行共享,而不需要额外的同步开销.</li>
<li>使用 final 关键字,JVM 会对方法、变量及类进行优化.</li>
</ul>
</li>
<li><p>java 中的 Math.round(-1.5) 等于多少？</p>
<ul>
<li>Math.round(11.5)的返回值是 12,Math.round(-11.5)的返回值是-11.四舍五入的原理是在参数上加 0.5 然后进行下取整.</li>
<li>规则： 加 0.5,进行下取整;</li>
</ul>
</li>
<li><p>String 属于基础的数据类型吗？</p>
<ul>
<li>基础数据类型 8 种：byte、short、int、long、float、double、char、boolean</li>
<li>String 是对象,是引用类型.</li>
</ul>
</li>
<li><p>java 中操作字符串都有哪些类？它们之间有什么区别？</p>
<ul>
<li><a href="https://blog.csdn.net/qq_35246620/article/details/56024465" target="_blank" rel="noopener">链接</a></li>
<li>对于操作效率而言,一般来说,StringBuilder &gt; StringBuffer &gt; String；</li>
<li>对于线程安全而言,StringBuffer 是线程安全的,可用于多线程；而 StringBuilder 是非线程安全的,用于单线程；</li>
<li>对于频繁的字符串操作而言,无论是 StringBuffer 还是 StringBuilder,都优于 String.</li>
<li>String: 在 java.lang 下不可被继承的 final 类</li>
<li>StringBuffer:区别在于修改对象本身,线程安全可以用于多线程</li>
<li>StringBuilder: 脱胎于 StringBuffer,允许多线程方法添加或者删除,线程不安全,一般用于单线程.</li>
</ul>
</li>
<li><p>String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</p>
<blockquote>
<p><a href="https://www.cnblogs.com/bluestorm/p/3296897.html" target="_blank" rel="noopener">答案链接</a></p>
</blockquote>
<ul>
<li><p>String str = &quot;a&quot;; 这个只是一个引用,内存中如果有“a&quot;的话,str 就指向它；如果没有,才创建它;</p>
</li>
<li><p>如果你以后还用到&quot;a&quot;这个字符串的话并且是这样:String str1 = &quot;a&quot;; String str2 = &quot;a&quot;; String str2 = &quot;a&quot;; 这 4 个变量都共享一个字符串&quot;a&quot;.而 String str = new String(&quot;a&quot;);是根据&quot;a&quot;这个 String 对象再次构造一个 String 对象,将新构造出来的 String 对象的引用赋给 str.</p>
<blockquote>
<p><a href="https://www.cnblogs.com/aspirant/p/9193112.html" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>如何将字符串反转？</p>
</li>
</ol>
<ul>
<li>String reverse = new StringBuffer(string).reverse().toString();</li>
</ul>
<ol start="10">
<li>String 类的常用方法都有那些？</li>
</ol>
<ul>
<li><blockquote>
<p><a href="https://www.cnblogs.com/ABook/p/5527341.html" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
<li>public int length()</li>
<li>public char charAt(int index)</li>
<li>public String substring(int beginIndex, int endIndex)</li>
<li>public boolean equals(Object anotherObject)</li>
<li>public String concat(String str)//&quot;aa&quot;+&quot;bb&quot;+&quot;cc&quot;;</li>
<li>public int indexOf(int ch/String str)</li>
<li>public String toLowerCase()/public String toUpperCase()</li>
<li>public String replace(char oldChar, char newChar)</li>
<li>public String String trim()</li>
<li>public String[] split(String str)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求长度</span></span><br><span class="line"><span class="comment">// public int length();</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asdfgz"</span>);</span><br><span class="line"><span class="keyword">int</span> strlength = str.length();        <span class="comment">//strlength = 7</span></span><br><span class="line"><span class="comment">// 求某个字符串的某一位字符</span></span><br><span class="line"><span class="comment">// public char charAt(int index);</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asdfz"</span>);</span><br><span class="line"><span class="keyword">char</span> ch = str.charAt(<span class="number">4</span>);             <span class="comment">//ch=z</span></span><br><span class="line"><span class="comment">// 提取子串</span></span><br><span class="line"><span class="comment">// 1)public String substring(int beginIndex)</span></span><br><span class="line"><span class="comment">// 2)public String substring(int beginIndex,int endIndex);</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"asdfgxz"</span>);</span><br><span class="line">Stirng str2 = str1.substring(<span class="number">2</span>);     <span class="comment">// str2 = "dfzxc"</span></span><br><span class="line">String str3 = str1.substring(<span class="number">2</span>,<span class="number">5</span>);   <span class="comment">// str3 = "dfz"</span></span><br><span class="line"><span class="comment">// 字符串比较</span></span><br><span class="line"><span class="comment">// 1)public int compareTo(String anotherString);//该方法是对字符串内容按字典顺序进行大小比较,通过返回的整数值指明当前字符串与参数字符串的大小关系.若当前对象比参数大则返回正整数,反之返回负整数,相等返回0.</span></span><br><span class="line"><span class="comment">// 2)public int compareToIgnore(String anotherString)//与compareTo方法相似,但忽略大小写.</span></span><br><span class="line"><span class="comment">// 3)public boolean equals(Object anotherObject)//比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.</span></span><br><span class="line"><span class="comment">// 4)public boolean equalsIgnoreCase(String anotherString)//与equals方法相似,但忽略大小写.</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line"><span class="keyword">int</span> a = str1.compareTo(str2);<span class="comment">//a&gt;0</span></span><br><span class="line"><span class="keyword">int</span> b = str1.compareToIgnoreCase(str2);<span class="comment">//b=0</span></span><br><span class="line"><span class="keyword">boolean</span> c = str1.equals(str2);<span class="comment">//c=false</span></span><br><span class="line"><span class="keyword">boolean</span> d = str1.equalsIgnoreCase(str2);<span class="comment">//d=true</span></span><br><span class="line"><span class="comment">// 字符串连接</span></span><br><span class="line"><span class="comment">// public String concat(String str)//将参数中的字符串str连接到当前字符串的后面,效果等价于"+".</span></span><br><span class="line">String str = <span class="string">"aa"</span>.concat(<span class="string">"bb"</span>).concat(<span class="string">"cc"</span>); <span class="comment">//相当于String str = "aa"+"bb"+"cc";</span></span><br><span class="line"><span class="comment">// 字符串中单个字符查找</span></span><br><span class="line"><span class="comment">// 1)public int indexOf(int ch/String str)//用于查找当前字符串中字符或子串,返回字符或子串在当前字符串中从左边起首次出现的位置,若没有出现则返回-1.</span></span><br><span class="line"><span class="comment">// 2)public int indexOf(int ch/String str, int fromIndex)//改方法与第一种类似,区别在于该方法从fromIndex位置向后查找.</span></span><br><span class="line"><span class="comment">// 3)public int lastIndexOf(int ch/String str)//该方法与第一种类似,区别在于该方法从字符串的末尾位置向前查找.</span></span><br><span class="line"><span class="comment">// 4)public int lastIndexOf(int ch/String str, int fromIndex)//该方法与第二种方法类似,区别于该方法从fromIndex位置向前查找.</span></span><br><span class="line">String str = <span class="string">"I am a good student"</span>;</span><br><span class="line"><span class="keyword">int</span> a = str.indexOf(<span class="string">'a'</span>);<span class="comment">//a = 2</span></span><br><span class="line"><span class="keyword">int</span> b = str.indexOf(<span class="string">"good"</span>);<span class="comment">//b = 7</span></span><br><span class="line"><span class="keyword">int</span> c = str.indexOf(<span class="string">"w"</span>,<span class="number">2</span>);<span class="comment">//c = -1</span></span><br><span class="line"><span class="keyword">int</span> d = str.lastIndexOf(<span class="string">"a"</span>);<span class="comment">//d = 5</span></span><br><span class="line"><span class="keyword">int</span> e = str.lastIndexOf(<span class="string">"a"</span>,<span class="number">3</span>);<span class="comment">//e = 2</span></span><br><span class="line"><span class="comment">// 字符串中字符的大小写转换</span></span><br><span class="line"><span class="comment">// 1)public String toLowerCase()//返回将当前字符串中所有字符转换成小写后的新串</span></span><br><span class="line"><span class="comment">// 2)public String toUpperCase()//返回将当前字符串中所有字符转换成大写后的新串</span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"asDF"</span>);</span><br><span class="line">String str1 = str.toLowerCase();<span class="comment">//str1 = "asdf"</span></span><br><span class="line">String str2 = str.toUpperCase();<span class="comment">//str2 = "ASDF"</span></span><br><span class="line"><span class="comment">// 字符串中字符的替换</span></span><br><span class="line"><span class="comment">// 1)public String replace(char oldChar, char newChar)//用字符newChar替换当前字符串中所有的oldChar字符,并返回一个新的字符串.</span></span><br><span class="line"><span class="comment">// 2)public String replaceFirst(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的第一个和字符串regex相匹配的子串,应将新的字符串返回.</span></span><br><span class="line"><span class="comment">// 3)public String replaceAll(String regex, String replacement)//该方法用字符replacement的内容替换当前字符串中遇到的所有和字符串regex相匹配的子串,应将新的字符串返回.</span></span><br><span class="line">String str = <span class="string">"asdzxcasd"</span>;</span><br><span class="line">String str1 = str.replace(<span class="string">'a'</span>,<span class="string">'g'</span>);<span class="comment">//str1 = "gsdzxcgsd"</span></span><br><span class="line">String str2 = str.replace(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str2 = "fghzxcfgh"</span></span><br><span class="line">String str3 = str.replaceFirst(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str3 = "fghzxcasd"</span></span><br><span class="line">String str4 = str.replaceAll(<span class="string">"asd"</span>,<span class="string">"fgh"</span>);<span class="comment">//str4 = "fghzxcfgh"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="11">
<li><p>抽象类必须要有抽象方法吗？</p>
<ul>
<li>用 abstract 修饰的类就是抽象类,并不是说抽象类中必须有抽象方法,即使一个类中的方法全部实现过,也可以用 abstract 修饰为抽象类,所以抽象类不一定都有抽象方法.</li>
<li>延伸：因为真有一种情况可以将类定义为 static 类型的,那就是内部类.</li>
</ul>
</li>
<li><p>普通类和抽象类有哪些区别？</p>
<ul>
<li><p>1、普通类可以去实例化调用；抽象类不能被实例化,因为它是存在于一种概念而不非具体.</p>
</li>
<li><p>2、普通类和抽象类都可以被继承,但是抽象类被继承后子类必须重写继承的方法,除非自类也是抽象类.</p>
</li>
<li><p>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法.注意,抽象类和普通类的主要有三点区别：</p>
<ul>
<li>1)抽象方法必须为 public 或者 protected(因为如果为 private,则不能被子类继承,子类便无法实现该方法),缺省情况下默认为 public.</li>
<li>2)抽象类不能用来创建对象；</li>
<li>3)如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法.如果子类没有实现父类的抽象方法,则必须将子类也定义为为 abstract 类.</li>
</ul>
</li>
<li><p>在其他方面,抽象类和普通的类并没有区别</p>
</li>
</ul>
</li>
<li><p>抽象类能使用 final 修饰吗？</p>
<ul>
<li>不能,抽象方法是为了继承之后重写方法的,而用 final 修饰的类,无法继承</li>
</ul>
</li>
<li><p>接口和抽象类有什么区别？</p>
<ul>
<li><blockquote>
<p><a href="https://www.jianshu.com/p/038f0b356e9a" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
<li>抽象类(abstract class):一个抽象类不能实例化,依然可以在类的实体(直白点就是能在｛｝里面)定义成员变量,成员方法,构造方法等.一个类中含有抽象方法(被 abstract 修饰),那么这个类必须被声明为抽象类(被 abstract 修饰).</li>
<li>接口(interface):接口在 java 中是一个抽象类型,是抽象方法的集合.一个类通过继承接口的方式,从而继承接口的抽象方法.</li>
</ul>
</li>
<li><p>java 中 IO 流分为几种？</p>
<ul>
<li>两种：输入流与输出流</li>
</ul>
</li>
<li><p>BIO、NIO、AIO 有什么区别？</p>
<ul>
<li>IO 的方式通常分为几种，同步阻塞的 BIO、同步非阻塞的 NIO、异步非阻塞的 AIO。</li>
<li><blockquote>
<p><a href="https://blog.csdn.net/skiof007/article/details/52873421" target="_blank" rel="noopener">链接</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>Files 的常用方法都有哪些？</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>判断 File 对象对应的文件或者目录是否存在若存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除 File 对象对应的文件或者目录若成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>当 File 对象对应的文件不存在时，该方法将新建一个此 File 对象所指定的新文件若创建成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回 File 对象表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>String getPath()</td>
<td>返回 File 对象对应的路径</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>返回 File 对象对应的绝对路径（在 UNIX/Linux 等系统上，如果路径是以正斜线 / 开始的，则这个路径是绝对路径；在 Windows 等系统上，如果路径是从盘符开始的，则这个路径是绝对路径）</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回 File 对象对应目录的父目录，（即返回的目录不包含最后一级子目录）</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断 File 对象对应的文件或者目录是否可读若可读则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断 File 对象对应的文件或者目录是否可写。若可写则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断 File 对象对应的是否是文件（不是目录）若是文件则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断 File 对象对应的是否是目录（不是文件）若是目录则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断 File 对象对应的文件或者目录是否是绝对路径</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>返回 1970 年 1 月 1 日 0 时 0 分 0 秒到文件最好修改时间的毫秒值</td>
</tr>
<tr>
<td>long length()</td>
<td>返回文件内容长度</td>
</tr>
<tr>
<td>String [ ]list()</td>
<td>返回指定目录的全部内容，只列出名称</td>
</tr>
<tr>
<td>File[ ] listFiles()</td>
<td>返回一个包含了 File 对象所有子文件和子目录的 File 数组</td>
</tr>
</tbody></table>
</li>
<li><p>java 如何解决的多重继承</p>
<ul>
<li><a href="https://www.cnblogs.com/chenssy/p/3389027.html" target="_blank" rel="noopener">链接</a> - 1. 接口 - 2. 内部类</li>
</ul>
</li>
</ol>
<h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><ul>
<li><a href="https://blog.csdn.net/dengpeng0419/article/details/47983033" target="_blank" rel="noopener">链接</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院的 java 集合</a></li>
</ul>
<ol>
<li><p>java 容器都有哪些？</p>
<blockquote>
<p>Java 容器类类库的用途是“持有对象”，并将其划分为两个不同的概念：</p>
<p>1）Collection：一个独立元素的序列，这些元素都服从一条或者多条规则。 List 必须按照插入的顺序保存元素，而 set 不能有重复的元素。Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p>
<p>2）Map：一组成对的“键值对”对象，允许你使用键来查找值。</p>
</blockquote>
<pre><code>├Collection
│├List
││├LinkedList
││├ArrayList
││└Vector
││ └Stack
│└Set
│ ├HashSet
│ ├TreeSet
│ └LinkedSet
│
└Map
 ├Hashtable
 ├HashMap
 └WeakHashMap</code></pre></li>
<li><p>Collection 和 Collections 有什么区别？</p>
<ol>
<li><p>java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection 接口在 Java 类库中有很多具体的实现。Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</p>
<blockquote>
<p>Collection</p>
</blockquote>
<pre><code>├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set</code></pre></li>
<li><p>java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</p>
</li>
</ol>
</li>
<li><p>List、Set、Map 之间的区别是什么？<br><a href="https://blog.csdn.net/SpeedMe/article/details/22398395" target="_blank" rel="noopener">链接 1</a></p>
<p><a href="https://blog.csdn.net/u012102104/article/details/79235938" target="_blank" rel="noopener">链接 2</a></p>
<p>数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型），而<strong>JAVA 集合可以存储和操作数目不固定的一组数据</strong>。</p>
<blockquote>
<p>java 集合的三个主要类型：</p>
<ul>
<li><p>Set (集)</p>
</li>
<li><p>List (列表)</p>
</li>
<li><p>Map(序列)</p>
</li>
</ul>
</blockquote>
<p><em>Java 所有“存储及随机访问一连串对象”的做法，array 是最有效率的一种。</em></p>
<blockquote>
<p>效率高，但容量固定且无法动态改变。<br>array 还有一个缺点是，无法判断其中实际存有多少元素，length 只是告诉我们 array 的容量。</p>
<p>Java 中有一个<strong>Arrays 类，专门用来操作 array</strong>。</p>
</blockquote>
<p>若撰写程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array 不适用。所以就要用到集合。</p>
<blockquote>
<p>集合分类：</p>
<p>Collection：List、Set<br>Map：HashMap、HashTable</p>
</blockquote>
<table>
<thead>
<tr>
<th>比较</th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td align="center">collection</td>
<td align="center">collection</td>
<td align="center"></td>
</tr>
<tr>
<td>常见实现类</td>
<td align="center">AbstractList(其常用子类有 ArrayList、LinkedList、Vector)</td>
<td align="center">AbstractSet(其常用子类有 HashSet、LinkedHashSet、TreeSet)</td>
<td align="center">HashMap、HashTable、TreeMap</td>
</tr>
<tr>
<td>常见方法</td>
<td align="center">add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td align="center">add( )、remove( )、clear( )、contains( )、size( )</td>
<td align="center">put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td align="center">可重复</td>
<td align="center">不可重复(用<code>equals()</code>判断)</td>
<td align="center">不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td align="center">有序</td>
<td align="center">无序(实际上由 HashCode 决定)</td>
<td align="center"></td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">Vector 线程安全</td>
<td align="center"></td>
<td align="center">Hashtable 线程安全</td>
</tr>
</tbody></table>
</li>
<li><p>HashMap 和 Hashtable 有什么区别？</p>
<p><a href="https://www.jianshu.com/p/5c34133ed372" target="_blank" rel="noopener">链接</a></p>
<ul>
<li>HashMap 不是线程安全的：hashmap 是 map 的接口实现类，是将键映射到值得对象，其中键与值都是对象，并不能包含重复键，但可以包含重复值。HashMap 允许 null key 和 null value，而 HashTable 不允许。</li>
<li>HashTable 是线程安全 Collection：HashMap 是 HashTable 的轻量级实现，他们都完成了 Map 接口，主要区别在于 HashMap 允许 null key 和 null value,由于非线程安全，效率上可能高于 Hashtable。</li>
<li><strong>区别如下：</strong><ul>
<li>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。</li>
<li><del>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。</del></li>
<li>HashTable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。</li>
<li>HashTable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。</li>
<li><del>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</del></li>
</ul>
</li>
</ul>
</li>
<li><p>如何决定使用 HashMap 还是 TreeMap？</p>
<ul>
<li>TreeMap&lt;K,V&gt;的 Key 值是要求实现 java.lang.Comparable，所以迭代的时候 TreeMap 默认是按照 Key 值升序排序的；TreeMap 的实现也是基于红黑树结构。</li>
<li>HashMap&lt;K,V&gt;的 Key 值实现散列 hashCode(),分布是散列的均匀的，不支持排序；数据结构主要是桶(数组),链表或红黑树。</li>
<li>大多情况下 HashMap 有更好的性能，所以大多不需要排序的时候我们会使用 HashMap.</li>
<li>数组：数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为 O(1)；数组的特点是：寻址容易，插入和删除困难。</li>
<li>链表：链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达 O（N）。链表的特点是：寻址困难，插入和删除容易。</li>
<li>哈希表：做出一种寻址容易，插入删除也容易的数据结构，哈希表是由数组+链表组成的</li>
</ul>
</li>
<li><p>说一下 HashMap 的实现原理？</p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院</a><br>数组+链表</p>
<blockquote>
<p>创建一个 entry 的数组，其中单个元素是 entry（以键值对的形式存储，而且存储了下个 entry 的地址）</p>
</blockquote>
<ul>
<li>存储:<ul>
<li>当我们 put 的时候，如果 key 存在了，那么新的 value 会代替旧的 value，并且如果 key 存在的情况下，该方法返回的是旧的 value，如果 key 不存在，那么返回 null。</li>
<li>从上面的源代码中可以看出：当我们往 HashMap 中 put 元素的时候，先根据 key 的 hashCode 重新计算 hash 值，根据 hash 值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>说一下 HashSet 的实现原理？</p>
<p><a href="http://wiki.jikexueyuan.com/project/java-collection/hashset.html" target="_blank" rel="noopener">极客学院</a></p>
</li>
<li><p>ArrayList 和 LinkedList 的区别是什么？</p>
<p><a href="https://www.jianshu.com/p/e591690afacb" target="_blank" rel="noopener">简书</a></p>
<ul>
<li>ArrayList 是实现了基于动态数组的结构，而 LinkedList 则是基于实现链表的数据结构。而两种数据结构在程序上体现出来的优缺点在于增删和改查的速率。</li>
</ul>
</li>
<li><p>如何实现数组和 List 之间的转换？</p>
<p>​ <a href="https://blog.csdn.net/zjx2016/article/details/78273192" target="_blank" rel="noopener">csdn</a></p>
<ul>
<li>list 转数组：for，.toArray()</li>
<li>数组转 list：<ul>
<li><code>for(String str : arrays){ list.add(str); }</code></li>
<li><code>ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arrays));</code></li>
<li><code>List&lt;String&gt; list = Arrays.asList(arrays);</code></li>
<li><code>List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(arrays.length); Collections.addAll(list2, arrays);</code></li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList 和 Vector 的区别是什么？</p>
<ol>
<li>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。</li>
</ol>
</li>
<li><p>Array 和 ArrayList 有何区别？</p>
<ul>
<li>存储内容比较：<ul>
<li>​ Array 数组可以包含基本类型和对象类型，</li>
<li>​ ArrayList 却只能包含对象类型。</li>
</ul>
</li>
</ul>
<blockquote>
<p>但是需要注意的是：Array 数组在存放的时候一定是同种类型的元素。ArrayList 就不一定了，因为 ArrayList 可以存储 Object。</p>
</blockquote>
<ul>
<li>空间大小比较：<ul>
<li>它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。</li>
<li>​ ArrayList 的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。</li>
</ul>
</li>
</ul>
</li>
<li><p>在 Queue 中 poll()和 remove()有什么区别？</p>
<p><a href="https://www.cnblogs.com/lemon-flm/p/7877898.html" target="_blank" rel="noopener">比较全的</a></p>
<p><strong>Queue： 基本上，一个队列就是一个先入先出（FIFO）的数据结构</strong></p>
<p><strong>remove</strong> 移除并返回队列头部的元素 如果队列为空，则抛出一个 NoSuchElementException 异常</p>
<p><strong>poll</strong> 移除并返问队列头部的元素 如果队列为空，则返回 null</p>
</li>
<li><p>哪些集合类是线程安全的？</p>
<p><a href="https://blog.csdn.net/laowang2915/article/details/73648208" target="_blank" rel="noopener">链接</a></p>
<p><a href="https://blog.csdn.net/lixiaobuaa/article/details/79689338" target="_blank" rel="noopener">链接 2</a></p>
<p>Vector：就比 Arraylist 多了个同步化机制（线程安全）。</p>
<p>Hashtable：就比 Hashmap 多了个线程安全。</p>
<p>ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<p>Stack：栈，也是线程安全的，继承于 Vector。</p>
</li>
<li><p>迭代器 Iterator 是什么？</p>
<ul>
<li>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<a href="https://www.nowcoder.com/questionTerminal/8863f297b1fc4bbca6de95528b6051e1" target="_blank" rel="noopener">链接</a></li>
<li>对 Collection 进行迭代的类，称其为迭代器。还是面向对象的思想，专业对象做专业的事情，迭代器就是专门取出集合元素的对象。但是该对象比较特殊，不能直接创建对象（通过new），该对象是以内部类的形式存在于每个集合类的内部。<a href="https://blog.csdn.net/qq_33642117/article/details/52039691" target="_blank" rel="noopener">链接</a></li>
</ul>
</li>
<li><p>Iterator 怎么使用？有什么特点？<a href="https://blog.csdn.net/qq_20916555/article/details/51292063" target="_blank" rel="noopener">链接</a></p>
<ul>
<li>Java 中使用 Iterator 来遍历集合元素，Iterator 遍历集合元素有以下几个特点:<ul>
<li>Iterator 遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出 ConcurrentModificationEception 的异常。</li>
<li>Iterator 遍历集合元素的过程中可以通过 remove 方法来移除集合中的元素。</li>
<li>Iterator 必须依附某个 Collection 对象而存在，Iterator 本身不具有装载数据对象的功能。</li>
<li>Iterator.remove 方法删除的是上一次 Iterator.next()方法返回的对象。</li>
<li>强调以下 next（）方法，该方法通过游标指向的形式返回 Iterator 下一个元素。</li>
</ul>
</li>
<li><strong>Iterator 的常用方法</strong>:<ul>
<li>boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回 true</li>
<li>Object next(); 返回迭代器中下一个元素</li>
<li>void remove() ; 删除集合里上一个 next 方法调用的时候返回的对象元素</li>
<li>void forEachRemaining(Consumer action) ;使用 Lambdda 表达式的形式输出 Iterator 中所以的元素。注意该方法其实是间接调用 next()方法进行遍历，所以再次是 next（）方法的时候 Iterator 中的对象已经被遍历完了。</li>
</ul>
</li>
</ul>
</li>
<li><p>Iterator 和 ListIterator 有什么区别？<a href="https://blog.csdn.net/longshengguoji/article/details/41551491" target="_blank" rel="noopener">link</a></p>
<p>一．相同点</p>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。</li>
</ul>
<p>二．不同点</p>
<ol>
<li><p>使用范围不同，Iterator 可以应用于所有的集合，Set、List 和 Map 和这些集合的子类型。而 ListIterator 只能用于 List 及其子类型。</p>
</li>
<li><p>ListIterator 有 add 方法，可以向 List 中添加对象，而 Iterator 不能。</p>
</li>
<li><p>ListIterator 和 Iterator 都有 hasNext()和 next()方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious()和 previous()方法，可以实现逆向（顺序向前）遍历。Iterator 不可以。</p>
</li>
<li><p>ListIterator 可以定位当前索引的位置，nextIndex()和 previousIndex()可以实现。Iterator 没有此功能。</p>
</li>
<li><p>都可实现删除操作，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iterator 仅能遍历，不能修改。</p>
</li>
</ol>
</li>
<li><p>怎么确保一个集合不能被修改？<a href="https://blog.csdn.net/syilt/article/details/90548237" target="_blank" rel="noopener">link</a></p>
<ul>
<li><strong>利用 Collections 和 Guava 提供的类可实现的不可变对象</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collections</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">    map  = Collections.unmodifiableMap(map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Guava</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 这样被初始化之后 list是不能被改变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list); <span class="comment">// 这样被初始化之后set是不能被改变的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="number">222</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//guava中的map的写法有点不一样如下：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder().put(<span class="number">1</span>,<span class="number">2</span>).put(<span class="number">3</span>,<span class="number">4</span>).put(<span class="number">5</span>,<span class="number">6</span>).build();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h2><ol>
<li><p>并行和并发有什么区别？<a href="https://www.jianshu.com/p/b11e251d3dc7" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>并发:一个处理器同时处理多个任务。</p>
</li>
<li><p>并行:多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生</p>
</blockquote>
</li>
</ul>
</li>
<li><p>线程和进程的区别？<a href="https://www.cnblogs.com/WuXuanKun/p/6259965.html" target="_blank" rel="noopener">link</a></p>
<ul>
<li>进程代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个进程可以包括多个线程。</li>
<li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存.</li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述。</strong></li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong></li>
<li>几乎任何的操作系统都支持运行多个任务，通常一个任务就是一个程序，而一个程序就是一个进程。当一个进程运行时，内部可能包括多个顺序执行流，每个顺序执行流就是一个线程。</li>
<li>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。</li>
</ul>
</li>
<li><p>守护线程是什么？<a href="https://blog.csdn.net/shimiso/article/details/8964414" target="_blank" rel="noopener">link</a></p>
<ul>
<li>在 Java 中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程)</li>
<li>任何一个守护线程都是整个 JVM 中所有非守护线程的保姆：<ul>
<li>只要当前 JVM 实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着 JVM 一同结束工作。</li>
</ul>
</li>
<li>User 和 Daemon 两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread 已经全部退出运行了，只剩下 Daemon Thread 存在了，虚拟机也就退出了。</li>
</ul>
</li>
<li><p>创建线程有哪几种方式？<a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>三种：继承 Thread 类创建线程类/通过 Runnable 接口创建线程类/通过 Callable 和 Future 创建线程</p>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一、继承Thread类创建线程类</span></span><br><span class="line"><span class="comment">//（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</span></span><br><span class="line"><span class="comment">//（2）创建Thread子类的实例，即创建了线程对象。</span></span><br><span class="line"><span class="comment">//（3）调用线程对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//重写run方法，run方法的方法体就是现场执行体</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		System.out.println(getName()+<span class="string">"  "</span>+i);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">"  : "</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">				<span class="keyword">new</span> FirstThreadTest().start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二、通过Runnable接口创建线程类</span></span><br><span class="line"><span class="comment">//（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</span></span><br><span class="line"><span class="comment">//（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</span></span><br><span class="line"><span class="comment">//（3）调用线程对象的start()方法来启动该线程。</span></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				RunnableThreadTest rtt = <span class="keyword">new</span> RunnableThreadTest();</span><br><span class="line">				<span class="keyword">new</span> Thread(rtt,<span class="string">"新线程1"</span>).start();</span><br><span class="line">				<span class="keyword">new</span> Thread(rtt,<span class="string">"新线程2"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//三、通过Callable和Future创建线程</span></span><br><span class="line"><span class="comment">//（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</span></span><br><span class="line"><span class="comment">//（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</span></span><br><span class="line"><span class="comment">//（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</span></span><br><span class="line"><span class="comment">//（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThreadTest</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		CallableThreadTest ctt = <span class="keyword">new</span> CallableThreadTest();</span><br><span class="line">		FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(ctt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" 的循环变量i的值"</span>+i);</span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">20</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">new</span> Thread(ft,<span class="string">"有返回值的线程"</span>).start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"子线程的返回值："</span>+ft.get());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e)</span><br><span class="line">		&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建线程的三种方式的对比:</p>
<ul>
<li>采用实现 Runnable、Callable 接口的方式创见多线程时<ul>
<li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法</li>
</ul>
</li>
<li>使用继承 Thread 类的方式创建多线程时<ul>
<li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li>
<li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>说一下 runnable 和 callable 有什么区别？<a href="https://blog.csdn.net/longshengguoji/article/details/41126119" target="_blank" rel="noopener">link</a></p>
<ul>
<li>Callable 规定的方法是 call(),Runnable 规定的方法是 run()</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值(是 void)</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。<br>Callable 接口也是位于 java.util.concurrent 包中。</li>
</ul>
</li>
<li><p>线程有哪些状态？</p>
<ul>
<li>在 Java 当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</li>
<li>第一是创建状态。在生成线程对象，并没有调用该对象的 start 方法，这是线程处于创建状态；</li>
<li>第二是就绪状态。当调用了线程对象的 start 方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态</li>
<li>第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。</li>
<li>第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend 等方法都可以导致线程阻塞。</li>
<li>第五是死亡状态。如果一个线程的 run 方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪状态。</li>
</ul>
</li>
<li><p>sleep() 和 wait() 有什么区别？<a href="https://www.zhihu.com/question/23328075" target="_blank" rel="noopener">link</a></p>
<ul>
<li>“sleep 是 Thread 类的方法,wait 是 Object 类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
</li>
<li><p>notify()和 notifyAll()有什么区别？<a href="https://www.zhihu.com/question/37601861" target="_blank" rel="noopener">link</a></p>
<ul>
<li>所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify 只会唤醒一个线程。</li>
</ul>
</li>
<li><p>线程的 run()和 start()有什么区别？</p>
<ol>
<li>start() 可以启动一个新线程，run()不能</li>
<li>start()不能被重复调用，run()可以</li>
<li>start()中的 run 代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用 run 方法必须等待其代码全部执行完才能继续执行下面的代码。</li>
<li>start() 实现了多线程，run()没有实现多线程。</li>
</ol>
</li>
<li><p>创建线程池有哪几种方式？<a href="https://blog.csdn.net/u011974987/article/details/51027795" target="_blank" rel="noopener">link</a></p>
<ul>
<li>newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ul>
</li>
<li><p>线程池都有哪些状态？<a href="https://blog.csdn.net/L_kanglin/article/details/57411851" target="_blank" rel="noopener">link</a></p>
</li>
</ol>
<pre><code>![线程池的状态.jpg](..\pic\java的运行流程.jpg)

pic\java的运行流程.jpg

1、RUNNING

​    (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
​    (2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

2、 SHUTDOWN

​    (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
​    (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。

3、STOP

​    1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
​    (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。

4、TIDYING

​    (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
​    (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。
​    当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -&gt; TIDYING。

5、 TERMINATED

​    (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。

​    (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -&gt; TERMINATED。</code></pre><ol start="12">
<li><p>线程池中 submit()和 execute()方法有什么区别？<a href="https://blog.csdn.net/guhong5153/article/details/71247266" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>execute 提交的方式只能提交一个 Runnable 的对象，且该方法的返回值是 void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过 ThreadFactory 主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</p>
</li>
<li><p>submit 提交的方式</p>
<ul>
<li><p><t> Future<t> submit(Callable<t> task);而 Callable 接口中是一个有返回值的 call 方法。如果在线程的执行过程中发生了异常，get 会获取到异常的信息。</t></t></t></p>
</li>
<li><p>Future&lt;?&gt; submit(Runnable task);也可以提交一个 Runable 接口的对象，这样当调用 get 方法的时候，如果线程执行成功会直接返回 null，如果线程执行异常会返回异常的信息</p>
</li>
<li><p><t> Future<t> submit(Runnable task, T result);除了 task 之外还有一个 result 对象，</t></t></p>
<p>当线程正常结束的时候调用 Future 的 get 方法会返回 result 对象，当线程抛出异常的时候会获取到对应的异常的信息。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在 java 程序中怎么保证多线程的运行安全？</p>
</li>
<li><p>多线程锁的升级原理是什么？</p>
</li>
<li><p>什么是死锁？</p>
</li>
<li><p>怎么防止死锁？</p>
</li>
<li><p>ThreadLocal 是什么？有哪些使用场景？</p>
</li>
<li><p>说一下 synchronized 底层实现原理？</p>
</li>
<li><p>synchronized 和 volatile 的区别是什么？</p>
</li>
<li><p>synchronized 和 Lock 有什么区别？</p>
</li>
<li><p>synchronized 和 ReentrantLock 区别是什么？</p>
</li>
<li><p>说一下 atomic 的原理？</p>
</li>
</ol>
<h2 id="四、反射"><a href="#四、反射" class="headerlink" title="四、反射"></a>四、反射</h2><ol>
<li><p>什么是反射？<a href="<https://www.zhihu.com/question/24304289>">link</a></p>
<p><img src="..%5Cpic%5Cjava%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="java的运行流程.jpg"></p>
<p><strong><a href="[https://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F](https://www.sczyh30.com/posts/Java/java-reflection-1/#一、回顾：什么是反射？)">深入解析 Java 反射（1） - 基础</a></strong></p>
<ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
</ul>
</li>
<li><p>什么是 java 序列化？什么情况下需要序列化？<a href="https://blog.csdn.net/fan2012huan/article/details/49871163" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>序列化简单来说就<strong>保存对象在内存中的状态</strong>也可以说是<strong>实例化变量</strong>。这是 Java 提供的用来<strong>保存 Object state</strong>，一种保存对象状态的机制。只有实现了 serializable 接口的类的对象才能被实例化。</p>
</li>
<li><p>1 当你想把内存中的对象写入到硬盘时</p>
<p>​ 2 当你想用套接字在网络上传输对象时</p>
<p>​ 3 当你想通过 RMI 调用对象时</p>
<p>​ （RMI 是什么东西？）：RMI 总结来说就是远程调用对象，在一个 jvm 上调用另一个 jvm 的对象。</p>
</li>
</ul>
</li>
<li><p>动态代理是什么？有哪些应用？</p>
</li>
<li><p>怎么实现动态代理？</p>
</li>
</ol>
<h2 id="五、对象拷贝link"><a href="#五、对象拷贝link" class="headerlink" title="五、对象拷贝link"></a>五、对象拷贝<a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">link</a></h2><ol>
<li><p>为什么要使用克隆？</p>
<p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了</p>
</li>
<li><p>如何实现对象克隆？</p>
<p><strong>浅克隆(ShallowClone)</strong>和<strong>深克隆(DeepClone)</strong></p>
</li>
<li><p>深拷贝和浅拷贝区别是什么？</p>
<ul>
<li>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。(在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。)</li>
<li>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。(在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。)</li>
</ul>
</li>
</ol>
<h2 id="六、Java-Web"><a href="#六、Java-Web" class="headerlink" title="六、Java Web"></a>六、Java Web</h2><ol>
<li>jsp 和 servlet 有什么区别？</li>
<li>jsp 有哪些内置对象？作用分别是什么？</li>
<li>说一下 jsp 的 4 种作用域？</li>
<li>session 和 cookie 有什么区别？</li>
<li>说一下 session 的工作原理？</li>
<li>如果客户端禁止 cookie 能实现 session 还能用吗？</li>
<li>spring mvc 和 struts 的区别是什么？</li>
<li>如何避免 sql 注入？</li>
<li>什么是 XSS 攻击,如何避免？</li>
<li>什么是 CSRF 攻击,如何避免？</li>
</ol>
<h2 id="七、异常"><a href="#七、异常" class="headerlink" title="七、异常"></a>七、异常</h2><blockquote>
<p>Java 的异常处理是通过 5 个关键字来实现的：try，catch，throw，throws，finally。</p>
</blockquote>
<ol>
<li>throw 和 throws 的区别？</li>
<li>final、finally、finalize 有什么区别？</li>
<li>try-catch-finally 中哪个部分可以省略？</li>
<li>try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？</li>
<li>常见的异常类有哪些？</li>
</ol>
<h2 id="八、网络"><a href="#八、网络" class="headerlink" title="八、网络"></a>八、网络</h2><ol>
<li>http 响应码 301 和 302 代表的是什么？有什么区别？</li>
<li>forward 和 redirect 的区别？</li>
<li>简述 tcp 和 udp 的区别？</li>
<li>tcp 为什么要三次握手,两次不行吗？为什么？</li>
<li>说一下 tcp 粘包是怎么产生的？</li>
<li>OSI 的七层模型都有哪些？</li>
<li>get 和 post 请求有哪些区别？</li>
<li>如何实现跨域？</li>
<li>说一下 JSONP 实现原理？</li>
</ol>
<h2 id="九、设计模式"><a href="#九、设计模式" class="headerlink" title="九、设计模式"></a>九、设计模式</h2><ol>
<li>说一下你熟悉的设计模式？</li>
<li>简单工厂和抽象工厂有什么区别？</li>
</ol>
<h2 id="十、Spring-Spring-MVC"><a href="#十、Spring-Spring-MVC" class="headerlink" title="十、Spring/Spring MVC"></a>十、Spring/Spring MVC</h2><ol>
<li>为什么要使用 spring？</li>
<li>解释一下什么是 aop？</li>
<li>解释一下什么是 ioc？</li>
<li>spring 有哪些主要模块？</li>
<li>spring 常用的注入方式有哪些？</li>
<li>spring 中的 bean 是线程安全的吗？</li>
<li>spring 支持几种 bean 的作用域？</li>
<li>spring 自动装配 bean 有哪些方式？</li>
<li>spring 事务实现方式有哪些？</li>
<li>说一下 spring 的事务隔离？</li>
<li>说一下 spring mvc 运行流程？</li>
<li>spring mvc 有哪些组件？</li>
<li>@RequestMapping 的作用是什么？</li>
<li>@Autowired 的作用是什么？</li>
</ol>
<h2 id="十一、Spring-Boot-Spring-Cloud"><a href="#十一、Spring-Boot-Spring-Cloud" class="headerlink" title="十一、Spring Boot/Spring Cloud"></a>十一、Spring Boot/Spring Cloud</h2><ol>
<li>什么是 spring boot？</li>
<li>为什么要用 spring boot？</li>
<li>spring boot 核心配置文件是什么？</li>
<li>spring boot 配置文件有哪几种类型？它们有什么区别？</li>
<li>spring boot 有哪些方式可以实现热部署？</li>
<li>jpa 和 hibernate 有什么区别？</li>
<li>什么是 spring cloud？</li>
<li>spring cloud 断路器的作用是什么？</li>
<li>spring cloud 的核心组件有哪些？</li>
</ol>
<h2 id="十二、Hibernate"><a href="#十二、Hibernate" class="headerlink" title="十二、Hibernate"></a>十二、Hibernate</h2><ol>
<li>为什么要使用 hibernate？</li>
<li>什么是 ORM 框架？</li>
<li>hibernate 中如何在控制台查看打印的 sql 语句？</li>
<li>hibernate 有几种查询方式？</li>
<li>hibernate 实体类可以被定义为 final 吗？</li>
<li>在 hibernate 中使用 Integer 和 int 做映射有什么区别？</li>
<li>hibernate 是如何工作的？</li>
<li>get()和 load()的区别？</li>
<li>说一下 hibernate 的缓存机制？</li>
<li>hibernate 对象有哪些状态？</li>
<li>在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</li>
<li>hibernate 实体类必须要有无参构造函数吗？为什么？</li>
</ol>
<h2 id="十三、Mybatis"><a href="#十三、Mybatis" class="headerlink" title="十三、Mybatis"></a>十三、Mybatis</h2><ol>
<li>mybatis 中 #{}和 ${}的区别是什么？</li>
<li>mybatis 有几种分页方式？</li>
<li>RowBounds 是一次性查询全部结果吗？为什么？</li>
<li>mybatis 逻辑分页和物理分页的区别是什么？</li>
<li>mybatis 是否支持延迟加载？延迟加载的原理是什么？</li>
<li>说一下 mybatis 的一级缓存和二级缓存？</li>
<li>mybatis 和 hibernate 的区别有哪些？</li>
<li>mybatis 有哪些执行器(Executor)？</li>
<li>mybatis 分页插件的实现原理是什么？</li>
<li>mybatis 如何编写一个自定义插件？</li>
</ol>
<h2 id="十四、RabbitMQ"><a href="#十四、RabbitMQ" class="headerlink" title="十四、RabbitMQ"></a>十四、RabbitMQ</h2><ol>
<li>rabbitmq 的使用场景有哪些？</li>
<li>rabbitmq 有哪些重要的角色？</li>
<li>rabbitmq 有哪些重要的组件？</li>
<li>rabbitmq 中 vhost 的作用是什么？</li>
<li>rabbitmq 的消息是怎么发送的？</li>
<li>rabbitmq 怎么保证消息的稳定性？</li>
<li>rabbitmq 怎么避免消息丢失？</li>
<li>要保证消息持久化成功的条件有哪些？</li>
<li>rabbitmq 持久化有什么缺点？</li>
<li>rabbitmq 有几种广播类型？</li>
<li>rabbitmq 怎么实现延迟消息队列？</li>
<li>rabbitmq 集群有什么用？</li>
<li>rabbitmq 节点的类型有哪些？</li>
<li>rabbitmq 集群搭建需要注意哪些问题？</li>
<li>rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</li>
<li>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</li>
<li>rabbitmq 对集群节点停止顺序有要求吗？</li>
</ol>
<h2 id="十五、Kafka"><a href="#十五、Kafka" class="headerlink" title="十五、Kafka"></a>十五、Kafka</h2><ol>
<li>kafka 可以脱离 zookeeper 单独使用吗？为什么？</li>
<li>kafka 有几种数据保留的策略？</li>
<li>kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？</li>
<li>什么情况会导致 kafka 运行变慢？</li>
<li>使用 kafka 集群需要注意什么？</li>
</ol>
<h2 id="十六、Zookeeper"><a href="#十六、Zookeeper" class="headerlink" title="十六、Zookeeper"></a>十六、Zookeeper</h2><ol>
<li>zookeeper 是什么？</li>
<li>zookeeper 都有哪些功能？</li>
<li>zookeeper 有几种部署模式？</li>
<li>zookeeper 怎么保证主从节点的状态同步？</li>
<li>集群中为什么要有主节点？</li>
<li>集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？</li>
<li>说一下 zookeeper 的通知机制？</li>
</ol>
<h2 id="十七、MySql"><a href="#十七、MySql" class="headerlink" title="十七、MySql"></a>十七、MySql</h2><ol>
<li>数据库的三范式是什么？</li>
<li>一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？</li>
<li>如何获取当前数据库版本？</li>
<li>说一下 ACID 是什么？</li>
<li>char 和 varchar 的区别是什么？</li>
<li>float 和 double 的区别是什么？</li>
<li>mysql 的内连接、左连接、右连接有什么区别？</li>
<li>mysql 索引是怎么实现的？</li>
<li>怎么验证 mysql 的索引是否满足需求？</li>
<li>说一下数据库的事务隔离？</li>
<li>说一下 mysql 常用的引擎？</li>
<li>说一下 mysql 的行锁和表锁？</li>
<li>说一下乐观锁和悲观锁？</li>
<li>mysql 问题排查都有哪些手段？</li>
<li>如何做 mysql 的性能优化？</li>
</ol>
<h2 id="十八、Redis"><a href="#十八、Redis" class="headerlink" title="十八、Redis"></a>十八、Redis</h2><ol>
<li>redis 是什么？都有哪些使用场景？</li>
<li>redis 有哪些功能？</li>
<li>redis 和 memecache 有什么区别？</li>
<li>redis 为什么是单线程的？</li>
<li>什么是缓存穿透？怎么解决？</li>
<li>redis 支持的数据类型有哪些？</li>
<li>redis 支持的 java 客户端都有哪些？</li>
<li>jedis 和 redisson 有哪些区别？</li>
<li>怎么保证缓存和数据库数据的一致性？</li>
<li>redis 持久化有几种方式？<br>189.redis 怎么实现分布式锁？</li>
<li>redis 分布式锁有什么缺陷？</li>
<li>redis 如何做内存优化？</li>
<li>redis 淘汰策略有哪些？</li>
<li>redis 常见的性能问题有哪些？该如何解决？</li>
</ol>
<h2 id="十九、JVM"><a href="#十九、JVM" class="headerlink" title="十九、JVM"></a>十九、JVM</h2><ol>
<li>说一下 jvm 的主要组成部分？及其作用？</li>
<li>说一下 jvm 运行时数据区？</li>
<li>说一下堆栈的区别？</li>
<li>队列和栈是什么？有什么区别？</li>
<li>什么是双亲委派模型？</li>
<li>说一下类加载的执行过程？</li>
<li>怎么判断对象是否可以被回收？</li>
<li>java 中都有哪些引用类型？</li>
<li>说一下 jvm 有哪些垃圾回收算法？</li>
<li>说一下 jvm 有哪些垃圾回收器？</li>
<li>详细介绍一下 CMS 垃圾回收器？</li>
<li>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</li>
<li>简述分代垃圾回收器是怎么工作的？</li>
<li>说一下 jvm 调优的工具？</li>
<li>常用的 jvm 调优的参数都有哪些？</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/blog/post/66c016fb.html</url>
    <content><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="1-说一下-jvm-的主要组成部分？及其作用？"><a href="#1-说一下-jvm-的主要组成部分？及其作用？" class="headerlink" title="1. 说一下 jvm 的主要组成部分？及其作用？"></a>1. 说一下 jvm 的主要组成部分？及其作用？</h2><ul>
<li><p>jvm的主要组成有，类加载器子系统，运行时数据区，执行引擎，本地库接口，垃圾收集模块；</p>
</li>
<li><p>首先通过类加载器（ClassLoader）会把 Java 字节码加载到内存中，</p>
</li>
<li><p>运行时数据区（Runtime Data Area）存储被加载的字节码，</p>
</li>
<li><p>而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，</p>
</li>
<li><p>而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>
</li>
<li><p>垃圾收集模块，清除内存中多余的内容，回收可重复使用的内存空间。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-说一下-jvm-运行时数据区？"><a href="#2-说一下-jvm-运行时数据区？" class="headerlink" title="2. 说一下 jvm 运行时数据区？"></a>2. 说一下 jvm 运行时数据区？</h2><ul>
<li><p>运行时数据区，是Java程序运行时数据存储的区域，主要包括方法区、Java堆、虚拟机栈、本地方法栈、程序计数器、直接内存等；</p>
</li>
<li><p>方法区，存储运行时的常量池，已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的；</p>
</li>
<li><p>Java堆，存储对象实例，被所有线程共享的；</p>
</li>
<li><p>虚拟机栈，存放方法运行时所需的数据，称为栈帧；</p>
</li>
<li><p>本地方法栈，存储Java调用本地方法所需的数据；</p>
</li>
<li><p>程序计数器，记录当前线程所执行到的字节码的行号；</p>
</li>
</ul>
<h2 id="3-说一下堆栈的区别？"><a href="#3-说一下堆栈的区别？" class="headerlink" title="3. 说一下堆栈的区别？"></a>3. 说一下堆栈的区别？</h2><ul>
<li><p>功能方面：堆是用来存放对象的，栈是用来执行程序的。 </p>
</li>
<li><p>共享性：堆是线程共享的，栈是线程私有的。 </p>
</li>
<li><p>空间大小：堆大小远远大于栈。</p>
</li>
</ul>
<h2 id="4-队列和栈是什么？有什么区别？"><a href="#4-队列和栈是什么？有什么区别？" class="headerlink" title="4. 队列和栈是什么？有什么区别？"></a>4. 队列和栈是什么？有什么区别？</h2><ul>
<li><p>队列和栈都是被用来预存储数据的。</p>
</li>
<li><p>队列允许先进先出检索元素，但也有例外的情况。</p>
</li>
<li><p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>
</li>
</ul>
<h2 id="5-什么是双亲委派模型？"><a href="#5-什么是双亲委派模型？" class="headerlink" title="5. 什么是双亲委派模型？"></a>5. 什么是双亲委派模型？</h2><ul>
<li><p>在介绍双亲委派模型之前先说下类加载器。<br>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。<br>类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>
</li>
<li><p>类加载器分类</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库； </li>
<li>扩展类加载器（Extension ClassLoader），负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li>
<li>应用程序类加载器（Application ClassLoader），负责加载用户类路径（classpath）上的指定类库；</li>
<li>自定义类加载器；</li>
</ul>
</li>
<li><p>双亲委派模型：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，<br>而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，<br>这样所有的加载请求都会被传送到顶层的启动类加载器中，<br>只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，<br>子加载器才会尝试去加载类。</p>
</li>
</ul>
<h2 id="6-说一下类加载的执行过程？"><a href="#6-说一下类加载的执行过程？" class="headerlink" title="6. 说一下类加载的执行过程？"></a>6. 说一下类加载的执行过程？</h2><ul>
<li><p>类装载分为以下 5 个步骤，加载、检查、准备、解析、初始化；</p>
</li>
<li><p>加载：根据查找路径找到相应的 class 文件然后导入；</p>
</li>
<li><p>检查：检查加载的 class 文件的正确性；</p>
</li>
<li><p>准备：给类中的静态变量分配内存空间；</p>
</li>
<li><p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</p>
</li>
<li><p>初始化：对静态变量和静态代码块执行初始化工作。</p>
</li>
</ul>
<h2 id="7-怎么判断对象是否可以被回收？"><a href="#7-怎么判断对象是否可以被回收？" class="headerlink" title="7. 怎么判断对象是否可以被回收？"></a>7. 怎么判断对象是否可以被回收？</h2><ul>
<li><p>主要有两种方法，引用计数法和可达性分析；</p>
</li>
<li><p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p>
</li>
<li><p>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>
</li>
</ul>
<h2 id="8-java-中都有哪些引用类型？"><a href="#8-java-中都有哪些引用类型？" class="headerlink" title="8. java 中都有哪些引用类型？"></a>8. java 中都有哪些引用类型？</h2><ul>
<li><p>强引用：发生 gc 的时候不会被回收。</p>
</li>
<li><p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p>
</li>
<li><p>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</p>
</li>
<li><p>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p>
</li>
</ul>
<h2 id="9-说一下-jvm-有哪些垃圾回收算法？"><a href="#9-说一下-jvm-有哪些垃圾回收算法？" class="headerlink" title="9. 说一下 jvm 有哪些垃圾回收算法？"></a>9. 说一下 jvm 有哪些垃圾回收算法？</h2><ul>
<li><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片;</p>
</li>
<li><p>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存;</p>
</li>
<li><p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半;</p>
</li>
<li><p>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p>
</li>
</ul>
<h2 id="10-说一下-jvm-有哪些垃圾回收器？"><a href="#10-说一下-jvm-有哪些垃圾回收器？" class="headerlink" title="10. 说一下 jvm 有哪些垃圾回收器？"></a>10. 说一下 jvm 有哪些垃圾回收器？</h2><ul>
<li><p>Serial：最早的单线程串行垃圾回收器;</p>
</li>
<li><p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案;</p>
</li>
<li><p>ParNew：是 Serial 的多线程版本;</p>
</li>
<li><p>Parallel: 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量;</p>
</li>
<li><p>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法;</p>
</li>
<li><p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统;</p>
</li>
<li><p>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>
</li>
</ul>
<h2 id="11-详细介绍一下-CMS-垃圾回收器？"><a href="#11-详细介绍一下-CMS-垃圾回收器？" class="headerlink" title="11. 详细介绍一下 CMS 垃圾回收器？"></a>11. 详细介绍一下 CMS 垃圾回收器？</h2><ul>
<li><p>CMS 是英文 Concurrent Mark-Sweep 的简称，</p>
</li>
<li><p>是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。</p>
</li>
<li><p>对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。</p>
</li>
<li><p>在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>
</li>
<li><p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，</p>
</li>
<li><p>当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>
</li>
</ul>
<h2 id="12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"><a href="#12-新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？"></a>12. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2><ul>
<li><p>回收器</p>
<ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge </li>
<li>老年代回收器：Serial Old、Parallel Old、CMS </li>
<li>整堆回收器：G1 </li>
</ul>
</li>
<li><p>两者的区别</p>
<ul>
<li>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；</li>
<li>老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</li>
</ul>
</li>
</ul>
<h2 id="13-简述分代垃圾回收器是怎么工作的？"><a href="#13-简述分代垃圾回收器是怎么工作的？" class="headerlink" title="13. 简述分代垃圾回收器是怎么工作的？"></a>13. 简述分代垃圾回收器是怎么工作的？</h2><ul>
<li><p>分代回收器有两个分区：老年代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>
</li>
<li><p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
</li>
<li><p>把 Eden + From Survivor 存活的对象放入 To Survivor 区； 清空 Eden 和 From Survivor 分区； From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>
</li>
<li><p>老年代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
</li>
</ul>
<h2 id="14-说一下-jvm-调优的工具？"><a href="#14-说一下-jvm-调优的工具？" class="headerlink" title="14. 说一下 jvm 调优的工具？"></a>14. 说一下 jvm 调优的工具？</h2><ul>
<li><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下；</p>
</li>
<li><p>window下常用的是 jconsole 和 jvisualvm 这两款视图监控工具；</p>
<ul>
<li>jconsole：用于对 JVM 中的内存、线程和类等进行监控； </li>
<li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li>
</ul>
</li>
<li><p>Linux下常用的有jps，jstat，jmap，jhat，jstack，jinfo；</p>
<ul>
<li>jps：虚拟机进程状况工具；</li>
<li>jstat：虚拟机统计信息监视工具；</li>
<li>jmap：Java内存印象工具；</li>
<li>jhat：虚拟机堆转储快照分析工具；</li>
<li>jstack：Java堆栈跟踪工具；</li>
<li>jinfo：Java配置信息工具。</li>
</ul>
</li>
</ul>
<h2 id="15-常用的-jvm-调优的参数都有哪些？"><a href="#15-常用的-jvm-调优的参数都有哪些？" class="headerlink" title="15. 常用的 jvm 调优的参数都有哪些？"></a>15. 常用的 jvm 调优的参数都有哪些？</h2><ul>
<li><p>-Xms2g：初始化推大小为 2g； -Xmx2g：堆最大内存为 2g；</p>
</li>
<li><p>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p>
</li>
<li><p>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p>
</li>
<li><p>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p>
</li>
<li><p>-XX:+PrintGC：开启打印 gc 信息；</p>
</li>
<li><p>-XX:+PrintGCDetails：打印 gc 详细信息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/blog/post/bae4ff13.html</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-redis-是什么？都有哪些使用场景？"><a href="#1-redis-是什么？都有哪些使用场景？" class="headerlink" title="1. redis 是什么？都有哪些使用场景？"></a>1. redis 是什么？都有哪些使用场景？</h2><ul>
<li><p>redis 是一个开源的，使用 C 语言编写，支持网络，可基于内存，可持久化的日志型、键值对数据库，并提供多种语言的API接口；</p>
</li>
<li><p>redis 使用场景主要有三种</p>
<ul>
<li>高并发的数据读写</li>
<li>海量数据的读写</li>
<li>对扩展性要求的高的数据</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="2-redis-有哪些功能？"><a href="#2-redis-有哪些功能？" class="headerlink" title="2. redis 有哪些功能？"></a>2. redis 有哪些功能？</h2><ul>
<li>数据缓存</li>
<li>分布式锁</li>
<li>支持数据持久化</li>
<li>支持事物</li>
<li>支持消息队列</li>
</ul>
<h2 id="3-redis-和-memcache-有什么区别？"><a href="#3-redis-和-memcache-有什么区别？" class="headerlink" title="3. redis 和 memcache 有什么区别？"></a>3. redis 和 memcache 有什么区别？</h2><ul>
<li>存储数据类型，memcahe 存储的所有数据均为字符串，redis 支持更丰富的数据类型；</li>
<li>响应速度，redis 快于 memcache；</li>
<li>数据持久化， redis 支持，而 memcache 不支持；</li>
<li>redis 是单进程单线程的，memcache 是单进程多线程的。</li>
</ul>
<h2 id="4-redis-为什么是单线程的？"><a href="#4-redis-为什么是单线程的？" class="headerlink" title="4. redis 为什么是单线程的？"></a>4. redis 为什么是单线程的？</h2><ul>
<li>redis 处理用户的网络请求是单线程处理，在执行数据持久化时就不是单线程了，并且从 redis4.0 开始某些操作支持多线程；</li>
<li>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽；</li>
<li>既然单线程容易实现，而且CPU不会成为瓶颈，多线程方案会加重系统的复杂性，因此采用单线程方案。</li>
</ul>
<h2 id="5-什么是缓存穿透？怎么解决？"><a href="#5-什么是缓存穿透？怎么解决？" class="headerlink" title="5. 什么是缓存穿透？怎么解决？"></a>5. 什么是缓存穿透？怎么解决？</h2><ul>
<li><p>缓存穿透，</p>
<ul>
<li>查询一个一定不存在的数据，由于缓存不命中时需要从数据库中查询，查不到数据就不写入缓存；</li>
<li>这将导致这个不存在的数据，每次请求都要到数据库去查询，造成缓存穿透。</li>
</ul>
</li>
<li><p>解决方案，</p>
<ul>
<li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，</li>
<li>设置它的过期时间很短，最长不超过五分钟。</li>
</ul>
</li>
</ul>
<h2 id="6-redis-支持的数据类型有哪些？"><a href="#6-redis-支持的数据类型有哪些？" class="headerlink" title="6. redis 支持的数据类型有哪些？"></a>6. redis 支持的数据类型有哪些？</h2><ul>
<li><p>redis 支持五种数据类型，string 字符串， list 列表， hash 哈希， set 集合， zset 有序集合；</p>
</li>
<li><p>String，</p>
<ul>
<li>一个 key 对应一个 value；</li>
<li>是二进制安全的，可以包含任何数据；</li>
<li>string 类型的值最大能存储 512MB；</li>
</ul>
</li>
<li><p>List，</p>
<ul>
<li>简单的字符串列表，按照插入顺序排序；</li>
<li>可以在列表的头部或尾部插入数据；</li>
</ul>
</li>
<li><p>Hash，</p>
<ul>
<li>一个 key 对应一个 键值对集合；</li>
<li>集合是 string 类型的 field 和 value 的映射表，可以存储对象；</li>
</ul>
</li>
<li><p>Set，</p>
<ul>
<li>string 的无序集合；</li>
<li>通过哈希表实现，因此增删改查时间复杂度是O(1);</li>
</ul>
</li>
<li><p>Zset</p>
<ul>
<li>string 类型的数据集合，但是不允许重复的值；</li>
<li>每个元素都关联一个 double 类型的分数，根据分数来排序，元素不能有重复值，但是分数可以重复。</li>
</ul>
</li>
</ul>
<h2 id="7-redis-支持的-java-客户端都有哪些？"><a href="#7-redis-支持的-java-客户端都有哪些？" class="headerlink" title="7. redis 支持的 java 客户端都有哪些？"></a>7. redis 支持的 java 客户端都有哪些？</h2><ul>
<li>Redisson、Jedis、lettuce</li>
</ul>
<h2 id="8-jedis-和-redisson-有哪些区别？"><a href="#8-jedis-和-redisson-有哪些区别？" class="headerlink" title="8. jedis 和 redisson 有哪些区别？"></a>8. jedis 和 redisson 有哪些区别？</h2><ul>
<li><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p>
</li>
<li><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。</p>
</li>
<li><p>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</li>
</ul>
<h2 id="9-怎么保证缓存和数据库数据的一致性？"><a href="#9-怎么保证缓存和数据库数据的一致性？" class="headerlink" title="9. 怎么保证缓存和数据库数据的一致性？"></a>9. 怎么保证缓存和数据库数据的一致性？</h2><ul>
<li><p>合理设置缓存的过期时间，保证最终一致性；</p>
<ul>
<li>我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可；</li>
<li>也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存；</li>
</ul>
</li>
<li><p>先删除缓存，再更新数据库，延时一定时间再次删除缓存；</p>
</li>
<li><p>先更新数据库，再删缓存；</p>
</li>
<li><p>针对删除缓存失败的情况，增加重试机制；</p>
<ul>
<li>（1）更新数据库数据</li>
<li>（2）数据库会将操作信息写入binlog日志当中</li>
<li>（3）订阅程序提取出所需要的数据以及key</li>
<li>（4）另起一段非业务代码，获得该信息</li>
<li>（5）尝试删除缓存操作，发现删除失败</li>
<li>（6）将这些信息发送至消息队列</li>
<li>（7）重新从消息队列中获得该数据，重试操作。</li>
</ul>
</li>
</ul>
<h2 id="10-redis-持久化有几种方式？"><a href="#10-redis-持久化有几种方式？" class="headerlink" title="10. redis 持久化有几种方式？"></a>10. redis 持久化有几种方式？</h2><ul>
<li><p>Redis 的持久化有两种方式；</p>
</li>
<li><p>RDB（Redis Database），指定的时间间隔能对你的数据进行快照存储；</p>
</li>
<li><p>AOF（Append Only File），每一个收到的写命令都通过write函数追加到文件中。</p>
</li>
</ul>
<h2 id="11-redis-怎么实现分布式锁？"><a href="#11-redis-怎么实现分布式锁？" class="headerlink" title="11. redis 怎么实现分布式锁？"></a>11. redis 怎么实现分布式锁？</h2><ul>
<li><p>Redis 分布式锁，就是获取锁的时候在 redis 里设置一个值，释放锁的时候删除 redis 里的这个值；</p>
</li>
<li><p>其他程序要获取锁的时候，查询值是否存在，</p>
</li>
<li><p>若不存在则设置值，成功获取锁，就可以继续执行，</p>
</li>
<li><p>若存在则获取锁失败，就只能放弃或稍后重试。</p>
</li>
</ul>
<h2 id="12-redis-分布式锁有什么缺陷？"><a href="#12-redis-分布式锁有什么缺陷？" class="headerlink" title="12. redis 分布式锁有什么缺陷？"></a>12. redis 分布式锁有什么缺陷？</h2><ul>
<li>Redis 分布式锁不能解决超时的问题，</li>
<li>分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</li>
</ul>
<h2 id="13-redis-如何做内存优化？"><a href="#13-redis-如何做内存优化？" class="headerlink" title="13. redis 如何做内存优化？"></a>13. redis 如何做内存优化？</h2><ul>
<li><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p>
</li>
<li><p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
</li>
</ul>
<h2 id="14-redis-淘汰策略有哪些？"><a href="#14-redis-淘汰策略有哪些？" class="headerlink" title="14. redis 淘汰策略有哪些？"></a>14. redis 淘汰策略有哪些？</h2><ul>
<li>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</li>
<li>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</li>
<li>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</li>
<li>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</li>
<li>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<h2 id="15-redis-常见的性能问题有哪些？该如何解决？"><a href="#15-redis-常见的性能问题有哪些？该如何解决？" class="headerlink" title="15. redis 常见的性能问题有哪些？该如何解决？"></a>15. redis 常见的性能问题有哪些？该如何解决？</h2><ul>
<li><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。</p>
</li>
<li><p>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/blog/post/54e1373e.html</url>
    <content><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><h2 id="数据库的三范式是什么？"><a href="#数据库的三范式是什么？" class="headerlink" title="数据库的三范式是什么？"></a>数据库的三范式是什么？</h2><ul>
<li><p>第一范式，关系表中的每列都是原子不可分的项，即每个属性都是最基本的项；</p>
</li>
<li><p>第二范式，在满足第一范式的前提下，关系表的所有非主属性完全依赖于每一个候选关键属性；</p>
</li>
<li><p>第三范式，在满足第二范式的前提下，关系表的所有非主属性由主键直接决定。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几？"><a href="#一张自增表里面总共有-7-条数据-删除了最后-2-条数据-重启-mysql-数据库-又插入了一条数据-此时-id-是几？" class="headerlink" title="一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？"></a>一张自增表里面总共有 7 条数据,删除了最后 2 条数据,重启 mysql 数据库,又插入了一条数据,此时 id 是几？</h2><ul>
<li>表引擎 MyISAM， id 为 8；</li>
<li>表引擎 InnoDB， id 为 6；</li>
<li>InnoDB 把表自增主键的最大 id 记录在内存里， 所有重启后会丢失最大 id。</li>
</ul>
<h2 id="如何获取当前数据库版本？"><a href="#如何获取当前数据库版本？" class="headerlink" title="如何获取当前数据库版本？"></a>如何获取当前数据库版本？</h2><ul>
<li>select version()</li>
</ul>
<h2 id="说一下-ACID-是什么？"><a href="#说一下-ACID-是什么？" class="headerlink" title="说一下 ACID 是什么？"></a>说一下 ACID 是什么？</h2><ul>
<li>ACID，事务的四大特性，原子性(Atomicity)，一致性(Consistency)，隔离性(Isolation)，持久性(Durability)；</li>
<li>A，原子性，事务是一个不可分割的工作单位，要么都发生，要么都不发生；</li>
<li>C，事务必须使数据库，从一个一致性状态变换到另一个一致性状态；</li>
<li>I，事务的隔离性是指，多个用户并发访问数据库时，数据库为每个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务间相互隔离；</li>
<li>D，持久性要求，一个事务一旦被提交，它对数据库中数据的修改是永久性的，即使数据库发生故障也不会丢失。</li>
</ul>
<h2 id="说一下数据库的事务隔离？"><a href="#说一下数据库的事务隔离？" class="headerlink" title="说一下数据库的事务隔离？"></a>说一下数据库的事务隔离？</h2><ul>
<li>MySql的事务隔离是在 MySql.ini 配置文件里添加的，在文件的最后添加：transaction-isolation=REPEATABLE-READ</li>
<li>READ-UNCOMMITTED：读未提交，最低的隔离级别，事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）</li>
<li>READ-COMMITTED：读已提交，一个事务提交后才能被其他事务读取到（oracle默认级别，会出现幻读、不重复读）</li>
<li>REPEATABLE-READ：可重复读，就是在开始读取数据时，不再允许修改操作（mysql默认级别，会造成幻读）</li>
<li>SERIALIZABLE：序列化，代价最高最可靠的隔离级别 脏读：表示一个事务能读取另一个事务中还未提交的数据 不可重复读：指在一个事务内，多次读取同一数据 幻读：指同一个事务内多次查询返回的结果集不一样</li>
</ul>
<h2 id="char-和-varchar-的区别是什么？"><a href="#char-和-varchar-的区别是什么？" class="headerlink" title="char 和 varchar 的区别是什么？"></a>char 和 varchar 的区别是什么？</h2><ul>
<li><p>数据库中 char 固定长度，</p>
<ul>
<li>优点是效率高，缺点是占用多余空间，</li>
<li>适用场景为存储定长数据；</li>
</ul>
</li>
<li><p>数据库中 varchar 可变长度，</p>
<ul>
<li>存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度；</li>
</ul>
</li>
<li><p>空间上考虑适用 varchar， 效率上适用 char。</p>
</li>
</ul>
<h2 id="float-和-double-的区别是什么？"><a href="#float-和-double-的区别是什么？" class="headerlink" title="float 和 double 的区别是什么？"></a>float 和 double 的区别是什么？</h2><ul>
<li><p>mysql 数据库的 float 最多可以存储 8 位十进制数， 占 4 个字节；</p>
</li>
<li><p>double 最多可以存储 16 位十进制数，占 8 个字节。</p>
</li>
</ul>
<h2 id="mysql-的内连接、左连接、右连接有什么区别？"><a href="#mysql-的内连接、左连接、右连接有什么区别？" class="headerlink" title="mysql 的内连接、左连接、右连接有什么区别？"></a>mysql 的内连接、左连接、右连接有什么区别？</h2><ul>
<li><p>内连接关键字：inner join；左连接：left join；右连接：right join；</p>
</li>
<li><p>内连接是把匹配的关联数据显示出来；</p>
</li>
<li><p>左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；</p>
</li>
<li><p>右连接是右边的表全部显示出来，左边的表显示出符合条件的数据；。</p>
</li>
</ul>
<h2 id="mysql-索引是怎么实现的？"><a href="#mysql-索引是怎么实现的？" class="headerlink" title="mysql 索引是怎么实现的？"></a>mysql 索引是怎么实现的？</h2><ul>
<li>常见的主要有两种结构：Hash索引和B+树索引，InnoDB引擎默认是B+树；</li>
<li>哈希索引适合等值查询，但是不无法进行范围查询，哈希索引没办法利用索引完成排序，也不支持多列联合索引的最左匹配原则，如果有大量重复键值的情况下，效率会很低，因此存在哈希碰撞的问题；</li>
<li>而B+树是一种多路平衡查询树，他的节点是天然有序的，对于范围查询的时候不需要做全表扫描。</li>
</ul>
<h2 id="怎么验证-mysql-的索引是否满足需求？"><a href="#怎么验证-mysql-的索引是否满足需求？" class="headerlink" title="怎么验证 mysql 的索引是否满足需求？"></a>怎么验证 mysql 的索引是否满足需求？</h2><ul>
<li>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求；</li>
<li>在正常的 sql 语句前加 explain 关键字。</li>
</ul>
<h2 id="说一下-mysql-常用的引擎？"><a href="#说一下-mysql-常用的引擎？" class="headerlink" title="说一下 mysql 常用的引擎？"></a>说一下 mysql 常用的引擎？</h2><ul>
<li><p>InnoDB 引擎：</p>
<ul>
<li>mysql 5.1 后默认的数据库引擎，</li>
<li>提供了对数据库 acid 事务的支持，</li>
<li>并且还提供了行级锁和外键的约束，</li>
<li>它的设计的目标就是处理大数据容量的数据库系统。</li>
<li>MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。</li>
<li>但是该引擎是不支持全文搜索，同时启动也比较的慢，</li>
<li>它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。</li>
<li>由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</li>
</ul>
</li>
<li><p>MyIASM 引擎：</p>
<ul>
<li>不提供事务的支持，也不支持行级锁和外键。</li>
<li>因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。</li>
<li>不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。</li>
<li>所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</li>
</ul>
</li>
</ul>
<h2 id="说一下-mysql-的行锁和表锁？"><a href="#说一下-mysql-的行锁和表锁？" class="headerlink" title="说一下 mysql 的行锁和表锁？"></a>说一下 mysql 的行锁和表锁？</h2><ul>
<li>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁；</li>
<li>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。</li>
<li>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</li>
</ul>
<h2 id="说一下乐观锁和悲观锁？"><a href="#说一下乐观锁和悲观锁？" class="headerlink" title="说一下乐观锁和悲观锁？"></a>说一下乐观锁和悲观锁？</h2><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</li>
<li>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</li>
</ul>
<h2 id="mysql-问题排查都有哪些手段？"><a href="#mysql-问题排查都有哪些手段？" class="headerlink" title="mysql 问题排查都有哪些手段？"></a>mysql 问题排查都有哪些手段？</h2><ul>
<li>使用 show processlist 命令查看当前所有连接信息；</li>
<li>使用 explain 命令查询 SQL 语句执行计划；</li>
<li>开启慢查询日志，查看慢查询的 SQL。</li>
</ul>
<h2 id="如何做-mysql-的性能优化？"><a href="#如何做-mysql-的性能优化？" class="headerlink" title="如何做 mysql 的性能优化？"></a>如何做 mysql 的性能优化？</h2><ul>
<li>为搜索字段创建索引；</li>
<li>避免sql语句不当使索引无效的情况</li>
<li>避免使用 select *，列出需要查询的字段，返回更少的数据，只返回需要的字段；</li>
<li>避免在where子句中使用!=，in，or；</li>
<li>使用连接查询代替子查询；</li>
<li>垂直分割分表；</li>
<li>选择正确的存储引擎。</li>
</ul>
<h2 id="一条sql执行时间过长，如何优化，从哪些方面？"><a href="#一条sql执行时间过长，如何优化，从哪些方面？" class="headerlink" title="一条sql执行时间过长，如何优化，从哪些方面？"></a>一条sql执行时间过长，如何优化，从哪些方面？</h2><ul>
<li>查看sql是否涉及多表的链表或者子查询，如果有，看看能否进行业务拆分，或者相关字段合并成临时表；</li>
<li>涉及链表的查询，是否能进行分表查询，查询之后进行字段整合；</li>
<li>是否可以对相应的字段做索引，加快查询速度；</li>
<li>针对数据量大的表进行历史表分离；</li>
<li>数据库主从分离，读写分离，降低读写对数据库同时操作的压力。MySQL自带binlog实现主从同步；</li>
<li>explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等；</li>
<li>查看MySQL日志，是否有其他问题。</li>
</ul>
<h2 id="当数据库中A-B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？"><a href="#当数据库中A-B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？" class="headerlink" title="当数据库中A,B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？"></a>当数据库中A,B字段做了组合索引，那么单独使用A或者单独使用B会有索引效果吗？</h2><ul>
<li>当A，B字段做了组合索引的时候，如果A在前，那么单独使用A会有索引效果，单独使用B则没有。</li>
</ul>
<h2 id="使用like查询是否走索引"><a href="#使用like查询是否走索引" class="headerlink" title="使用like查询是否走索引"></a>使用like查询是否走索引</h2><ul>
<li>后通配，走索引；</li>
<li>前通配，走全表。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DB</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/blog/post/b829b66a.html</url>
    <content><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="1-zookeeper-是什么？"><a href="#1-zookeeper-是什么？" class="headerlink" title="1. zookeeper 是什么？"></a>1. zookeeper 是什么？</h2><ul>
<li>zookeeper 是一个开源的分布式应用程序协调服务。</li>
<li>为分布式应用提供数据一致性服务，</li>
<li>功能包括，配置维护、域名服务、分布式同步、组服务。</li>
</ul>
<a id="more"></a>

<h2 id="2-zookeeper-都有哪些功能？"><a href="#2-zookeeper-都有哪些功能？" class="headerlink" title="2. zookeeper 都有哪些功能？"></a>2. zookeeper 都有哪些功能？</h2><ul>
<li>集群管理：监控节点存活状态、运行请求等；</li>
<li>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选举主节点，使用 zookeeper 可以协助完成这个过程；</li>
<li>分布式锁：zookeeper 提供两种锁：独占锁、共享锁，<ul>
<li>独占锁即一次只能有一个线程使用资源，</li>
<li>共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用；</li>
</ul>
</li>
<li>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</li>
</ul>
<h2 id="3-zookeeper-有几种部署模式？"><a href="#3-zookeeper-有几种部署模式？" class="headerlink" title="3. zookeeper 有几种部署模式？"></a>3. zookeeper 有几种部署模式？</h2><p>主要有三种：</p>
<ul>
<li>单机部署：一台服务器上运行；</li>
<li>集群部署：多台服务器构成集群运行；</li>
<li>伪集群部署：一台启动多个 zookeeper 实例构成集群运行。</li>
</ul>
<h2 id="4-zookeeper-怎么保证主从节点的状态同步？"><a href="#4-zookeeper-怎么保证主从节点的状态同步？" class="headerlink" title="4. zookeeper 怎么保证主从节点的状态同步？"></a>4. zookeeper 怎么保证主从节点的状态同步？</h2><ul>
<li>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。</li>
<li>实现这个机制的协议叫做 zab 协议。 </li>
<li>zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。</li>
<li>当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。</li>
<li>状态同步保证了 leader 和 server 具有相同的系统状态。</li>
</ul>
<h2 id="5-集群中为什么要有主节点？"><a href="#5-集群中为什么要有主节点？" class="headerlink" title="5. 集群中为什么要有主节点？"></a>5. 集群中为什么要有主节点？</h2><ul>
<li>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，</li>
<li>这样可以大大减少重复计算，提高性能，所以就需要主节点。</li>
</ul>
<h2 id="6-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗？"><a href="#6-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗？" class="headerlink" title="6. 集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？"></a>6. 集群中有 3 台服务器,其中一个节点宕机,这个时候 zookeeper 还可以使用吗？</h2><ul>
<li>可以继续使用，</li>
<li>单数服务器只要没超过一半的服务器宕机就可以继续使用。</li>
</ul>
<h2 id="7-说一下-zookeeper-的通知机制？"><a href="#7-说一下-zookeeper-的通知机制？" class="headerlink" title="7. 说一下 zookeeper 的通知机制？"></a>7. 说一下 zookeeper 的通知机制？</h2><ul>
<li>客户端端会对某个 znode 建立一个 watcher 事件，</li>
<li>当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，</li>
<li>然后客户端可以根据 znode 变化来做出业务上的改变。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka</title>
    <url>/blog/post/9a7d5a13.html</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="1-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#1-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="1. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>1. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h2><ul>
<li>kafka 不能脱离 zookeeper 单独使用，</li>
<li>因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</li>
</ul>
<a id="more"></a>

<h2 id="2-kafka-有几种数据保留的策略？"><a href="#2-kafka-有几种数据保留的策略？" class="headerlink" title="2. kafka 有几种数据保留的策略？"></a>2. kafka 有几种数据保留的策略？</h2><ul>
<li>kafka 有两种数据保存策略：<ul>
<li>按照过期时间保留,</li>
<li>按照存储的消息大小保留。</li>
</ul>
</li>
</ul>
<h2 id="3-kafka-同时设置了-7-天和-10G-清除数据-到第五天的时候消息达到了-10G-这个时候-kafka-将如何处理？"><a href="#3-kafka-同时设置了-7-天和-10G-清除数据-到第五天的时候消息达到了-10G-这个时候-kafka-将如何处理？" class="headerlink" title="3. kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？"></a>3. kafka 同时设置了 7 天和 10G 清除数据,到第五天的时候消息达到了 10G,这个时候 kafka 将如何处理？</h2><ul>
<li>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</li>
</ul>
<h2 id="4-什么情况会导致-kafka-运行变慢？"><a href="#4-什么情况会导致-kafka-运行变慢？" class="headerlink" title="4. 什么情况会导致 kafka 运行变慢？"></a>4. 什么情况会导致 kafka 运行变慢？</h2><ul>
<li>cpu 性能瓶颈</li>
<li>磁盘读写瓶颈</li>
<li>网络瓶颈</li>
</ul>
<h2 id="5-使用-kafka-集群需要注意什么？"><a href="#5-使用-kafka-集群需要注意什么？" class="headerlink" title="5. 使用 kafka 集群需要注意什么？"></a>5. 使用 kafka 集群需要注意什么？</h2><ul>
<li>集群的数量不是越多越好，最好不要超过 7 个，因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</li>
<li>集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/blog/post/b543ced0.html</url>
    <content><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="1-rabbitmq-的使用场景有哪些？"><a href="#1-rabbitmq-的使用场景有哪些？" class="headerlink" title="1. rabbitmq 的使用场景有哪些？"></a>1. rabbitmq 的使用场景有哪些？</h2><ul>
<li>跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。</p>
</li>
<li><p>应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。</p>
</li>
<li><p>消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。</p>
</li>
<li><p>应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。</p>
</li>
<li><p>跨局域网，甚至跨城市的通讯（CDN行业），比如北京机房与广州机房的应用程序的通信。</p>
</li>
</ul>
<h2 id="2-rabbitmq-有哪些重要的角色？"><a href="#2-rabbitmq-有哪些重要的角色？" class="headerlink" title="2. rabbitmq 有哪些重要的角色？"></a>2. rabbitmq 有哪些重要的角色？</h2><ul>
<li>RabbitMQ 中重要的角色有：生产者、消费者和代理：</li>
<li>生产者：消息的创建者，负责创建和推送数据到消息服务器；</li>
<li>消费者：消息的接收方，用于处理数据和确认消息；</li>
<li>代理：就是 RabbitMQ 本身，用于扮演“快递”的角色，本身不生产消息，只是扮演“快递”的角色。</li>
</ul>
<h2 id="3-rabbitmq-有哪些重要的组件？"><a href="#3-rabbitmq-有哪些重要的组件？" class="headerlink" title="3. rabbitmq 有哪些重要的组件？"></a>3. rabbitmq 有哪些重要的组件？</h2><ul>
<li>ConnectionFactory（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用。</li>
<li>Channel（信道）：消息推送使用的通道。</li>
<li>Exchange（交换器）：用于接受、分配消息。</li>
<li>Queue（队列）：用于存储生产者的消息。</li>
<li>RoutingKey（路由键）：用于把生成者的数据分配到交换器上。</li>
<li>BindingKey（绑定键）：用于把交换器的消息绑定到队列上。</li>
</ul>
<h2 id="4-rabbitmq-中-vhost-的作用是什么？"><a href="#4-rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="4. rabbitmq 中 vhost 的作用是什么？"></a>4. rabbitmq 中 vhost 的作用是什么？</h2><ul>
<li>vhost 可以理解为虚拟 broker ，即 mini-RabbitMQ server。</li>
<li>其内部均含有独立的 queue、exchange 和 binding 等，</li>
<li>但最最重要的是，其拥有独立的权限系统，</li>
<li>可以做到 vhost 范围的用户控制。</li>
<li>当然，从 RabbitMQ 的全局角度，vhost 可以作为不同权限隔离的手段</li>
<li>一个典型的例子就是不同的应用可以跑在不同的 vhost 中。</li>
</ul>
<h2 id="5-rabbitmq-的消息是怎么发送的？"><a href="#5-rabbitmq-的消息是怎么发送的？" class="headerlink" title="5. rabbitmq 的消息是怎么发送的？"></a>5. rabbitmq 的消息是怎么发送的？</h2><ul>
<li>首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，</li>
<li>客户端和 rabbit server 之间会创建一个 tcp 连接，</li>
<li>一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），</li>
<li>你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），</li>
<li>信道是创建在“真实” tcp 上的虚拟连接，</li>
<li>amqp 命令都是通过信道发送出去的，</li>
<li>每个信道都会有一个唯一的 id，</li>
<li>不论是发布消息，订阅队列都是通过这个信道完成的。</li>
</ul>
<h2 id="6-rabbitmq-怎么保证消息的稳定性？"><a href="#6-rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="6. rabbitmq 怎么保证消息的稳定性？"></a>6. rabbitmq 怎么保证消息的稳定性？</h2><ul>
<li>提供了事务的功能。</li>
<li>通过将 channel 设置为 confirm（确认）模式。</li>
</ul>
<h2 id="7-rabbitmq-怎么避免消息丢失？"><a href="#7-rabbitmq-怎么避免消息丢失？" class="headerlink" title="7. rabbitmq 怎么避免消息丢失？"></a>7. rabbitmq 怎么避免消息丢失？</h2><ul>
<li><p>消息持久化</p>
</li>
<li><p>ACK确认机制</p>
</li>
<li><p>设置集群镜像模式</p>
</li>
<li><p>消息补偿机制</p>
</li>
</ul>
<h2 id="8-要保证消息持久化成功的条件有哪些？"><a href="#8-要保证消息持久化成功的条件有哪些？" class="headerlink" title="8. 要保证消息持久化成功的条件有哪些？"></a>8. 要保证消息持久化成功的条件有哪些？</h2><p>四个条件都满足才能保证消息持久化成功</p>
<ul>
<li>消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。</li>
<li>声明队列必须设置持久化 durable 设置为 true.</li>
<li>消息已经到达持久化交换器。</li>
<li>消息已经到达持久化队列。</li>
</ul>
<h2 id="9-rabbitmq-持久化有什么缺点？"><a href="#9-rabbitmq-持久化有什么缺点？" class="headerlink" title="9. rabbitmq 持久化有什么缺点？"></a>9. rabbitmq 持久化有什么缺点？</h2><ul>
<li>持久化的缺地就是降低了服务器的吞吐量，</li>
<li>因为使用的是磁盘而非内存存储，从而降低了吞吐量。</li>
<li>可尽量使用 ssd 硬盘来缓解吞吐量的问题。</li>
</ul>
<h2 id="10-rabbitmq-有几种广播类型？"><a href="#10-rabbitmq-有几种广播类型？" class="headerlink" title="10. rabbitmq 有几种广播类型？"></a>10. rabbitmq 有几种广播类型？</h2><p>三种广播模式：</p>
<ul>
<li>fanout: 所有bind到此exchange的queue都可以接收消息（纯广播，绑定到RabbitMQ的接受者都能收到消息）；</li>
<li>direct: 通过routingKey和exchange决定的那个唯一的queue可以接收消息；</li>
<li>topic:所有符合routingKey(此时可以是一个表达式)的routingKey所bind的queue可以接收消息。</li>
</ul>
<h2 id="11-rabbitmq-怎么实现延迟消息队列？"><a href="#11-rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="11. rabbitmq 怎么实现延迟消息队列？"></a>11. rabbitmq 怎么实现延迟消息队列？</h2><ul>
<li>通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能；</li>
<li>使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。</li>
</ul>
<h2 id="12-rabbitmq-集群有什么用？"><a href="#12-rabbitmq-集群有什么用？" class="headerlink" title="12. rabbitmq 集群有什么用？"></a>12. rabbitmq 集群有什么用？</h2><p>集群主要有以下两个用途：</p>
<ul>
<li>高可用：某个服务器出现问题，整个 RabbitMQ 还可以继续使用；</li>
<li>高容量：集群可以承载更多的消息量。</li>
</ul>
<h2 id="13-rabbitmq-节点的类型有哪些？"><a href="#13-rabbitmq-节点的类型有哪些？" class="headerlink" title="13. rabbitmq 节点的类型有哪些？"></a>13. rabbitmq 节点的类型有哪些？</h2><ul>
<li>磁盘节点：消息会存储到磁盘。</li>
<li>内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。</li>
</ul>
<h2 id="14-rabbitmq-集群搭建需要注意哪些问题？"><a href="#14-rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="14. rabbitmq 集群搭建需要注意哪些问题？"></a>14. rabbitmq 集群搭建需要注意哪些问题？</h2><ul>
<li>各节点之间使用“--link”连接，此属性不能忽略。</li>
<li>各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。</li>
<li>整个集群中必须包含一个磁盘节点。</li>
</ul>
<h2 id="15-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#15-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="15. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>15. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h2><p>不是，原因有以下两个：</p>
<ul>
<li>存储空间的考虑：如果每个节点都拥有所有队列的完全拷贝，这样新增节点不但没有新增存储空间，反而增加了更多的冗余数据；</li>
<li>性能的考虑：如果每条消息都需要完整拷贝到每一个集群节点，那新增节点并没有提升处理消息的能力，最多是保持和单节点相同的性能甚至是更糟。</li>
</ul>
<h2 id="16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？"><a href="#16-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况？" class="headerlink" title="16. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？"></a>16. rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2><p>唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。</p>
<ul>
<li>不能创建队列</li>
<li>不能创建交换器</li>
<li>不能创建绑定</li>
<li>不能添加用户</li>
<li>不能更改权限</li>
<li>不能添加和删除集群节点</li>
</ul>
<h2 id="17-rabbitmq-对集群节点停止顺序有要求吗？"><a href="#17-rabbitmq-对集群节点停止顺序有要求吗？" class="headerlink" title="17. rabbitmq 对集群节点停止顺序有要求吗？"></a>17. rabbitmq 对集群节点停止顺序有要求吗？</h2><ul>
<li>RabbitMQ 对集群的停止的顺序是有要求的，</li>
<li>应该先关闭内存节点，最后再关闭磁盘节点。</li>
<li>如果顺序恰好相反的话，可能会造成消息的丢失。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis</title>
    <url>/blog/post/da3e1361.html</url>
    <content><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-mybatis-中-和-的区别是什么？"><a href="#1-mybatis-中-和-的区别是什么？" class="headerlink" title="1. mybatis 中 #{}和 ${}的区别是什么？"></a>1. mybatis 中 #{}和 ${}的区别是什么？</h2><ul>
<li>#{}是预编译处理，${}是字符串替换；</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理${}时，就是把${}替换成变量的值；</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ul>
<a id="more"></a>

<h2 id="2-mybatis-有几种分页方式？"><a href="#2-mybatis-有几种分页方式？" class="headerlink" title="2. mybatis 有几种分页方式？"></a>2. mybatis 有几种分页方式？</h2><ul>
<li>数组分页</li>
<li>sql分页</li>
<li>拦截器分页</li>
<li>RowBounds分页</li>
</ul>
<h2 id="3-RowBounds-是一次性查询全部结果吗？为什么？"><a href="#3-RowBounds-是一次性查询全部结果吗？为什么？" class="headerlink" title="3. RowBounds 是一次性查询全部结果吗？为什么？"></a>3. RowBounds 是一次性查询全部结果吗？为什么？</h2><ul>
<li>是一次性查询全部结果，只不过会根据参数丢掉一部分</li>
</ul>
<h2 id="4-mybatis-逻辑分页和物理分页的区别是什么？"><a href="#4-mybatis-逻辑分页和物理分页的区别是什么？" class="headerlink" title="4. mybatis 逻辑分页和物理分页的区别是什么？"></a>4. mybatis 逻辑分页和物理分页的区别是什么？</h2><ul>
<li>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。</li>
<li>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</li>
</ul>
<h2 id="5-mybatis-是否支持延迟加载？延迟加载的原理是什么？"><a href="#5-mybatis-是否支持延迟加载？延迟加载的原理是什么？" class="headerlink" title="5. mybatis 是否支持延迟加载？延迟加载的原理是什么？"></a>5. mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2><ul>
<li><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，</p>
<ul>
<li>association指的就是一对一，collection指的就是一对多查询。</li>
<li>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li>
</ul>
</li>
<li><p>它的原理是，使用CGLIB创建目标对象的代理对象，</p>
<ul>
<li>当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，</li>
<li>拦截器invoke()方法发现a.getB()是null值，</li>
<li>那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，</li>
<li>然后调用a.setB(b)，于是a的对象b属性就有值了，</li>
<li>接着完成a.getB().getName()方法的调用。</li>
</ul>
</li>
</ul>
<h2 id="6-说一下-mybatis-的一级缓存和二级缓存？"><a href="#6-说一下-mybatis-的一级缓存和二级缓存？" class="headerlink" title="6. 说一下 mybatis 的一级缓存和二级缓存？"></a>6. 说一下 mybatis 的一级缓存和二级缓存？</h2><ul>
<li><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
</li>
<li><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置 ；</p>
</li>
<li><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
</li>
</ul>
<h2 id="7-mybatis-和-hibernate-的区别有哪些？"><a href="#7-mybatis-和-hibernate-的区别有哪些？" class="headerlink" title="7. mybatis 和 hibernate 的区别有哪些？"></a>7. mybatis 和 hibernate 的区别有哪些？</h2><ul>
<li><p>Hibernate是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p>
</li>
<li><p>Mybatis是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p>
</li>
<li><p>开发方面</p>
<ul>
<li>hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</li>
<li>Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</li>
<li>但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，发杂语句较多，选择hibernate 就不是一个好方案。</li>
</ul>
</li>
<li><p>sql优化方面</p>
<ul>
<li>Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</li>
<li>Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</li>
</ul>
</li>
<li><p>对象管理比对</p>
<ul>
<li>Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</li>
<li>Mybatis 需要自行管理 映射关系；</li>
</ul>
</li>
<li><p>缓存方面 </p>
<ul>
<li>相同点：Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓存方案，创建适配器来完全覆盖缓存行为。</li>
<li>不同点：</li>
<li>Hibernate的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</li>
<li>MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</li>
</ul>
</li>
<li><p>比较：</p>
<ul>
<li>Hibernate 具有良好的管理机制，用户不需要关注SQL，如果二级缓存出现脏数据，系统会保存，；</li>
<li>Mybatis 在使用的时候要谨慎，避免缓存Cache 的使用。</li>
</ul>
</li>
<li><p>Hibernate优势</p>
<ul>
<li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li>
<li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li>
<li>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</li>
</ul>
</li>
<li><p>Mybatis优势</p>
<ul>
<li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。</li>
<li>MyBatis容易掌握，而Hibernate门槛较高。</li>
</ul>
</li>
<li><p>一句话总结</p>
<ul>
<li>Mybatis：小巧、方便、高效、简单、直接、半自动化</li>
<li>Hibernate：强大、方便、高效、复杂、间接、全自动化</li>
</ul>
</li>
</ul>
<h2 id="8-mybatis-有哪些执行器-Executor-？"><a href="#8-mybatis-有哪些执行器-Executor-？" class="headerlink" title="8. mybatis 有哪些执行器(Executor)？"></a>8. mybatis 有哪些执行器(Executor)？</h2><p>Mybatis有三种基本的执行器（Executor）：</p>
<ul>
<li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li>
<li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。</li>
<li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li>
</ul>
<h2 id="9-mybatis-分页插件的实现原理是什么？"><a href="#9-mybatis-分页插件的实现原理是什么？" class="headerlink" title="9. mybatis 分页插件的实现原理是什么？"></a>9. mybatis 分页插件的实现原理是什么？</h2><ul>
<li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，</li>
<li>在插件的拦截方法内拦截待执行的sql，然后重写sql，</li>
<li>根据dialect方言，添加对应的物理分页语句和物理分页参数。</li>
</ul>
<h2 id="10-mybatis-如何编写一个自定义插件？"><a href="#10-mybatis-如何编写一个自定义插件？" class="headerlink" title="10. mybatis 如何编写一个自定义插件？"></a>10. mybatis 如何编写一个自定义插件？</h2><p>Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>
<ul>
<li>Executor：拦截执行器的方法(log记录)</li>
<li>StatementHandler ：拦截Sql语法构建的处理</li>
<li>ParameterHandler ：拦截参数的处理</li>
<li>ResultSetHandler ：拦截结果集的处理</li>
<li>Mybatis自定义插件必须实现Interceptor接口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Interceptor &#123;</span><br><span class="line">    Object intercept(Invocation invocation) throws Throwable;</span><br><span class="line">    Object plugin(Object target);</span><br><span class="line">    void setProperties(Properties properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>intercept方法：拦截器具体处理逻辑方法</p>
</blockquote>
<blockquote>
<p>plugin方法：根据签名signatureMap生成动态代理对象</p>
</blockquote>
<blockquote>
<p>setProperties方法：设置Properties属性</p>
</blockquote>
<p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下：</p>
<ul>
<li>type：表示拦截的类，这里是Executor的实现类；</li>
<li>method：表示拦截的方法，这里是拦截Executor的update方法；</li>
<li>args：表示方法参数。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate</title>
    <url>/blog/post/6f8276a9.html</url>
    <content><![CDATA[<h1 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h1><h2 id="1-为什么要使用-hibernate？"><a href="#1-为什么要使用-hibernate？" class="headerlink" title="1. 为什么要使用 hibernate？"></a>1. 为什么要使用 hibernate？</h2><ul>
<li>对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li>
<li>hibernate 是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li>
<li>hibernate 使用 Java 反射机制，而不是字节码增强程序来实现透明性。</li>
<li>hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。</li>
</ul>
<a id="more"></a>

<h2 id="2-什么是-ORM-框架？"><a href="#2-什么是-ORM-框架？" class="headerlink" title="2. 什么是 ORM 框架？"></a>2. 什么是 ORM 框架？</h2><ul>
<li>对象-关系映射（Object-Relational Mapping，简称ORM），</li>
<li>面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，</li>
<li>关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。</li>
<li>对象和关系数据是业务实体的两种表现形式，<ul>
<li>业务实体在内存中表现为对象，</li>
<li>在数据库中表现为关系数据。</li>
</ul>
</li>
<li>内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。</li>
<li>因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。</li>
</ul>
<h2 id="3-hibernate-中如何在控制台查看打印的-sql-语句？"><a href="#3-hibernate-中如何在控制台查看打印的-sql-语句？" class="headerlink" title="3. hibernate 中如何在控制台查看打印的 sql 语句？"></a>3. hibernate 中如何在控制台查看打印的 sql 语句？</h2><ul>
<li>application.properties配置文件, spring.jpa.properties.hibernate.show_sql=true</li>
</ul>
<h2 id="4-hibernate-有几种查询方式？"><a href="#4-hibernate-有几种查询方式？" class="headerlink" title="4. hibernate 有几种查询方式？"></a>4. hibernate 有几种查询方式？</h2><p>主要有三种</p>
<ul>
<li>hql查询<ul>
<li>属性查询</li>
<li>参数查询、命名参数查询</li>
<li>关联查询</li>
<li>分页查询</li>
<li>统计函数</li>
</ul>
</li>
<li>sql查询</li>
<li>条件查询</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HQL:  Hibernate Query Language. 面向对象的写法:</span><br><span class="line">	Query query = session.createQuery(&quot;from Customer where name = ?&quot;);</span><br><span class="line">	query.setParameter(0, &quot;Good Luck&quot;);</span><br><span class="line">	Query.list();</span><br><span class="line"></span><br><span class="line">SQL:</span><br><span class="line">	SQLQuery query = session.createSQLQuery(&quot;select * from customer&quot;);</span><br><span class="line">	List&lt;Object[]&gt; list = query.list();</span><br><span class="line"></span><br><span class="line">	SQLQuery query = session.createSQLQuery(&quot;select * from customer&quot;);</span><br><span class="line">	query.addEntity(Customer.class);</span><br><span class="line">	List&lt;Customer&gt; list = query.list();</span><br><span class="line"></span><br><span class="line">QBC:  Query By Criteria.(条件查询):</span><br><span class="line">	Criteria criteria = session.createCriteria(Customer.class);</span><br><span class="line">	criteria.add(Restrictions.eq(&quot;name&quot;, &quot;大佬&quot;));</span><br><span class="line">	List&lt;Customer&gt; list = criteria.list();</span><br></pre></td></tr></table></figure>

<ul>
<li>HQL和SQL的区别<ul>
<li>HQL是面向对象查询操作的，</li>
<li>SQL是结构化查询语言 是面向数据库表结构的。</li>
</ul>
</li>
</ul>
<h2 id="5-hibernate-实体类可以被定义为-final-吗？"><a href="#5-hibernate-实体类可以被定义为-final-吗？" class="headerlink" title="5. hibernate 实体类可以被定义为 final 吗？"></a>5. hibernate 实体类可以被定义为 final 吗？</h2><ul>
<li>可以将Hibernate的实体类定义为final类，但这种做法并不好。</li>
<li>因为Hibernate会使用代理模式在延迟关联的情况下提高性能，</li>
<li>如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了，</li>
<li>如此一来就限制了使用可以提升性能的手段。</li>
<li>不过，如果你的持久化类实现了一个接口而且在该接口中声明了所有定义于实体类中的所有public的方法的话，</li>
<li>你就能够避免出现前面所说的不利后果。</li>
</ul>
<h2 id="6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？"><a href="#6-在-hibernate-中使用-Integer-和-int-做映射有什么区别？" class="headerlink" title="6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？"></a>6. 在 hibernate 中使用 Integer 和 int 做映射有什么区别？</h2><ul>
<li>在Hibernate中，如果将OID定义为Integer类型，那么Hibernate就可以根据其值是否为null而判断一个对象是否是临时的，</li>
<li>如果将OID定义为了int类型，还需要在hbm映射文件中设置其unsaved-value属性为0。</li>
</ul>
<h2 id="7-hibernate-是如何工作的？"><a href="#7-hibernate-是如何工作的？" class="headerlink" title="7. hibernate 是如何工作的？"></a>7. hibernate 是如何工作的？</h2><ul>
<li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li>
<li>由hibernate.cfg.xml中的读取并解析映射信息</li>
<li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li>
<li>Session session = sf.openSession();//打开Sesssion</li>
<li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li>
<li>persistent operate操作数据，持久化操作</li>
<li>tx.commit();//提交事务</li>
<li>关闭Session</li>
<li>关闭SesstionFactory</li>
</ul>
<h2 id="8-get-和-load-的区别？"><a href="#8-get-和-load-的区别？" class="headerlink" title="8. get()和 load()的区别？"></a>8. get()和 load()的区别？</h2><ul>
<li>load() 没有使用对象的其他属性的时候，没有 SQL， 延迟加载</li>
<li>get() 没有使用对象的其他属性的时候，也生成了 SQL， 立即加载</li>
</ul>
<h2 id="9-说一下-hibernate-的缓存机制？"><a href="#9-说一下-hibernate-的缓存机制？" class="headerlink" title="9. 说一下 hibernate 的缓存机制？"></a>9. 说一下 hibernate 的缓存机制？</h2><ul>
<li><p>Hibernate中的缓存分为一级缓存和二级缓存。</p>
<ul>
<li>一级缓存就是 Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。</li>
<li>二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。</li>
</ul>
</li>
<li><p>什么样的数据适合存放到第二级缓存中？</p>
<ul>
<li>很少被修改的数据 帖子的最后回复时间</li>
<li>经常被查询的数据 电商的地点</li>
<li>不是很重要的数据，允许出现偶尔并发的数据</li>
<li>不会被并发访问的数据</li>
<li>常量数据</li>
</ul>
</li>
<li><p>扩展：hibernate的二级缓存默认是不支持分布式缓存的。使用 memcahe,redis等中央缓存来代替二级缓存。</p>
</li>
</ul>
<h2 id="10-hibernate-对象有哪些状态？"><a href="#10-hibernate-对象有哪些状态？" class="headerlink" title="10. hibernate 对象有哪些状态？"></a>10. hibernate 对象有哪些状态？</h2><p>hibernate里对象有三种状态：</p>
<ul>
<li>Transient（瞬时）：对象刚new出来，还没设id，设了其他值。</li>
<li>Persistent（持久）：调用了save()、saveOrUpdate()，就变成Persistent，有id。</li>
<li>Detached（脱管）：当session close()完之后，变成Detached。</li>
</ul>
<h2 id="11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？"><a href="#11-在-hibernate-中-getCurrentSession-和-openSession-的区别是什么？" class="headerlink" title="11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？"></a>11. 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2><ul>
<li><p>openSession </p>
<ul>
<li>从字面上可以看得出来，是打开一个新的session对象，</li>
<li>而且每次使用都是打开一个新的session，</li>
<li>假如连续使用多次，则获得的session不是同一个对象，</li>
<li>并且使用完需要调用close方法关闭session。</li>
</ul>
</li>
<li><p>getCurrentSession ，</p>
<ul>
<li>从字面上可以看得出来，是获取当前上下文一个session对象，</li>
<li>当第一次使用此方法时，会自动产生一个session对象，</li>
<li>并且连续使用多次时，得到的session都是同一个对象，这就是与openSession的区别之一，</li>
<li>简单而言，getCurrentSession 就是：如果有已经使用的，用旧的，如果没有，建新的。</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>在实际开发中，往往使用getCurrentSession多，因为一般是处理同一个事务（即是使用一个数据库的情况），</li>
<li>所以在一般情况下比较少使用openSession或者说openSession是比较老旧的一套接口了。</li>
</ul>
</li>
</ul>
<h2 id="12-hibernate-实体类必须要有无参构造函数吗？为什么？"><a href="#12-hibernate-实体类必须要有无参构造函数吗？为什么？" class="headerlink" title="12. hibernate 实体类必须要有无参构造函数吗？为什么？"></a>12. hibernate 实体类必须要有无参构造函数吗？为什么？</h2><ul>
<li><p>必须，</p>
<ul>
<li>因为hibernate框架会调用这个默认构造方法来构造实例对象，即Class类的newInstance方法，</li>
<li>这个方法就是通过调用默认构造方法来创建实例对象的。</li>
</ul>
</li>
<li><p>另外再提醒一点，</p>
<ul>
<li>如果你没有提供任何构造方法，虚拟机会自动提供默认构造方法（无参构造器），</li>
<li>但是如果你提供了其他有参数的构造方法的话，虚拟机就不再为你提供默认构造方法，</li>
<li>这时必须手动把无参构造器写在代码里，否则new Xxxx()是会报错的，所以默认的构造方法不是必须的，</li>
<li>只在有多个构造方法时才是必须的，这里“必须”指的是“必须手动写出来”。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot/Spring Cloud</title>
    <url>/blog/post/b3383f7f.html</url>
    <content><![CDATA[<h1 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h1><h2 id="1-什么是-spring-boot？"><a href="#1-什么是-spring-boot？" class="headerlink" title="1. 什么是 spring boot？"></a>1. 什么是 spring boot？</h2><ul>
<li><p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMVC框架等，</p>
</li>
<li><p>Spring的核心内容在于控制反转(IOC)和依赖注入(DI),</p>
</li>
<li><p>在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
</li>
<li><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，</p>
</li>
<li><p>所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，</p>
</li>
<li><p>所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-为什么要用-spring-boot？"><a href="#2-为什么要用-spring-boot？" class="headerlink" title="2. 为什么要用 spring boot？"></a>2. 为什么要用 spring boot？</h2><ul>
<li>使编码变简单</li>
<li>使配置变简单</li>
<li>使部署变简单</li>
<li>使监控变简单</li>
<li>Spring的不足</li>
</ul>
<h2 id="3-spring-boot-核心配置文件是什么？"><a href="#3-spring-boot-核心配置文件是什么？" class="headerlink" title="3. spring boot 核心配置文件是什么？"></a>3. spring boot 核心配置文件是什么？</h2><p>Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h2 id="4-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#4-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="4. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>4. spring boot 配置文件有哪几种类型？它们有什么区别？</h2><ul>
<li>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</li>
<li>相对于properties文件而言，yml文件更年轻，也有很多的坑。</li>
<li>可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</li>
</ul>
<h2 id="5-spring-boot-有哪些方式可以实现热部署？"><a href="#5-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="5. spring boot 有哪些方式可以实现热部署？"></a>5. spring boot 有哪些方式可以实现热部署？</h2><ul>
<li><p>SpringBoot热部署实现有两种方式：</p>
</li>
<li><p>使用spring loaded</p>
</li>
<li><p>使用spring-boot-devtools</p>
</li>
</ul>
<h2 id="6-jpa-和-hibernate-有什么区别？"><a href="#6-jpa-和-hibernate-有什么区别？" class="headerlink" title="6. jpa 和 hibernate 有什么区别？"></a>6. jpa 和 hibernate 有什么区别？</h2><ul>
<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。</li>
<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>
<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>
<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>
<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>
<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>
</ul>
<h2 id="7-什么是-spring-cloud？"><a href="#7-什么是-spring-cloud？" class="headerlink" title="7. 什么是 spring cloud？"></a>7. 什么是 spring cloud？</h2><ul>
<li><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>
</li>
<li><p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>
</li>
<li><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
</ul>
</li>
<li><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>
</li>
</ul>
<h2 id="8-spring-cloud-断路器的作用是什么？"><a href="#8-spring-cloud-断路器的作用是什么？" class="headerlink" title="8. spring cloud 断路器的作用是什么？"></a>8. spring cloud 断路器的作用是什么？</h2><ul>
<li><p>在Spring Cloud中使用了 Hystrix 来实现断路器的功能，</p>
</li>
<li><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</p>
</li>
<li><p>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</p>
</li>
<li><p>断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
</li>
<li><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。</p>
</li>
<li><p>它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。</p>
</li>
<li><p>如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，</p>
</li>
<li><p>或以提醒管理员当断路器跳闸，以在打开状态。</p>
</li>
</ul>
<h2 id="9-spring-cloud-的核心组件有哪些？"><a href="#9-spring-cloud-的核心组件有哪些？" class="headerlink" title="9. spring cloud 的核心组件有哪些？"></a>9. spring cloud 的核心组件有哪些？</h2><ul>
<li><p>服务发现——Netflix Eureka</p>
<ul>
<li>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。</li>
<li>由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。</li>
<li>Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li>
<li>Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</li>
</ul>
</li>
<li><p>客服端负载均衡——Netflix Ribbon</p>
<ul>
<li>Ribbon，主要提供客户侧的软件负载均衡算法。</li>
<li>Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。</li>
<li>Ribbon内置可插拔、可定制的负载均衡组件。</li>
</ul>
</li>
<li><p>断路器——Netflix Hystrix</p>
<ul>
<li>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</li>
<li>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</li>
<li>断路器模式也使应用程序能够检测故障是否已经解决。</li>
<li>如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li>
</ul>
</li>
<li><p>服务网关——Netflix Zuul</p>
<ul>
<li>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</li>
</ul>
</li>
<li><p>分布式配置——Spring Cloud Config</p>
<ul>
<li>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring/Spring MVC</title>
    <url>/blog/post/ae9d29e2.html</url>
    <content><![CDATA[<h1 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h1><h2 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h2><ul>
<li>简介<ul>
<li>目的：解决企业应用开发的复杂性</li>
<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>
<li>范围：任何Java应用</li>
<li>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>轻量　　</p>
<ul>
<li>从大小与开销两方面而言Spring都是轻量的。</li>
<li>完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。</li>
<li>并且Spring所需的处理开销也是微不足道的。</li>
<li>此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
</ul>
</li>
<li><p>控制反转　　</p>
<ul>
<li>Sping通过一种称作控制反转（IoC）的技术促进了松耦合。</li>
<li>当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</li>
<li>你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
</ul>
</li>
<li><p>面向切面　　</p>
<ul>
<li>Spring提供了面向切面编程的丰富支持，</li>
<li>允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。</li>
<li>应用对象只实现它们应该做的——完成业务逻辑——仅此而已。</li>
<li>它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
</ul>
</li>
<li><p>容器</p>
<ul>
<li>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，</li>
<li>你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），</li>
<li>你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li>
<li>然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li>Spring可以将简单的组件配置、组合成为复杂的应用。</li>
<li>在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。</li>
<li>Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li>
</ul>
</li>
<li><p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
</li>
</ul>
<h2 id="Spring的设计模式有几种？"><a href="#Spring的设计模式有几种？" class="headerlink" title="Spring的设计模式有几种？"></a>Spring的设计模式有几种？</h2><ul>
<li><p>9种。</p>
</li>
<li><p>简单工厂：FactoryBean。</p>
</li>
<li><p>工厂方法：xml文件的factory-bean属性指定工厂方法。</p>
</li>
<li><p>单例模式：默认唯一的访问点是BeanFactory访问点。</p>
</li>
<li><p>适配器模式：HanderAdapter，AdvisorAdaptor。</p>
</li>
<li><p>装饰器模式：Wrapper，Decorator。</p>
</li>
<li><p>代理模式：AOP功能的原理就使用代理模式。</p>
</li>
<li><p>观察者模式：监听器。</p>
</li>
<li><p>策略模式：实例化对象的时候使用策略模式。</p>
</li>
<li><p>模板方法模式：JdbcTemplate。</p>
</li>
</ul>
<h2 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h2><ul>
<li><p>主要有七个模块；</p>
</li>
<li><p>核心容器（Spring Core）</p>
<ul>
<li>核心容器提供Spring框架的基本功能。</li>
<li>Spring以bean的方式组织和管理Java应用中的各个组件及其关系。</li>
<li>Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。</li>
<li>BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</li>
</ul>
</li>
<li><p>应用上下文（Spring Context）</p>
<ul>
<li>Spring上下文是一个配置文件，向Spring框架提供上下文信息。</li>
<li>Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
</ul>
</li>
<li><p>Spring面向切面编程（Spring AOP）</p>
<ul>
<li>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。</li>
<li>所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。</li>
<li>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</li>
<li>通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
</ul>
</li>
<li><p>JDBC和DAO模块（Spring DAO）</p>
<ul>
<li>JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。</li>
<li>异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</li>
</ul>
</li>
<li><p>对象实体映射（Spring ORM）</p>
<ul>
<li>Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，</li>
<li>其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</li>
</ul>
</li>
<li><p>Web模块（Spring Web）</p>
<ul>
<li>Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。</li>
<li>所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
</ul>
</li>
<li><p>MVC模块（Spring Web MVC）</p>
<ul>
<li>MVC框架是一个全功能的构建Web应用程序的MVC实现。</li>
<li>通过策略接口，MVC框架变成为高度可配置的。</li>
<li>MVC容纳了大量视图技术，其中包括JSP、POI等，</li>
<li>模型来有JavaBean来构成，存放于 model 当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码，由c的事情。</li>
<li>Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。</li>
<li>Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，</li>
<li>毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</li>
</ul>
</li>
</ul>
<h2 id="Spring容器有几种？"><a href="#Spring容器有几种？" class="headerlink" title="Spring容器有几种？"></a>Spring容器有几种？</h2><ul>
<li>BeanFactory是最简答的容器，提供了基本的DI支持。最常用的BeanFactory实现就是XmlBeanFactory类。</li>
<li>ApplicationContext扩展了BeanFactory的功能，提供面向应用的服务。</li>
<li>通过缓存在map中，实现了类的复用。</li>
</ul>
<h2 id="beanfactory和applicationcontext是什么关系，使用有什么区别。"><a href="#beanfactory和applicationcontext是什么关系，使用有什么区别。" class="headerlink" title="beanfactory和applicationcontext是什么关系，使用有什么区别。"></a>beanfactory和applicationcontext是什么关系，使用有什么区别。</h2><ul>
<li>ApplicationContex提供了一种解析文本消息的方法，一种加载文件资源（如图像）的通用方法，它们可以将事件发布到注册为侦听器的bean。</li>
<li>此外，可以在应用程序上下文中以声明方式处理容器中的容器或容器上的操作，这些操作必须以编程方式与Bean Factory一起处理。</li>
<li>ApplicationContex实现MessageSource，一个用于获取本地化消息的接口，实际的实现是可插入的。</li>
</ul>
<h2 id="FactoryBean如何使用？"><a href="#FactoryBean如何使用？" class="headerlink" title="FactoryBean如何使用？"></a>FactoryBean如何使用？</h2><ul>
<li>一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean. </li>
<li>如果类的配置复杂，那么就可以实现一个FactoryBean接口的工厂类，在getObject()方法中定制实例化逻辑。</li>
<li>当使用这个类的时候，Spring通过反射机制发现这个类实现了该工厂接口，就通过getObject()方法返回实例。</li>
<li>如果要获得工厂类本身的实例，则需要在beanName前面加&quot;&amp;&quot;。</li>
</ul>
<h1 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h1><h2 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h2><ul>
<li><p>面向方面的编程（AOP）是一种编程技术，它允许程序员模块化横切关注点或行为，这些问题或行为跨越典型的责任分工，例如日志记录和事务管理。</p>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</p>
</li>
<li><p>OOP（Object-Oriented Programing，面向对象编程）</p>
<ul>
<li>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。</li>
<li>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。</li>
<li>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。</li>
<li>例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</li>
<li>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。</li>
<li>这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
</ul>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程）</p>
<ul>
<li>它利用一种称为“横切”的技术，剖解开封装的对象内部，</li>
<li>并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。</li>
<li>所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，</li>
<li>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
<li>AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；</li>
<li>那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。</li>
<li>然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</li>
</ul>
</li>
<li><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。</p>
<ul>
<li>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</li>
<li>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。</li>
<li>比如权限认证、日志、事务处理。</li>
<li>AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
<li>AOP的核心思想就是，将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。</li>
</ul>
</li>
</ul>
<h2 id="Spring-AOP中的关注点和交叉关注点之间有什么区别？"><a href="#Spring-AOP中的关注点和交叉关注点之间有什么区别？" class="headerlink" title="Spring AOP中的关注点和交叉关注点之间有什么区别？"></a>Spring AOP中的关注点和交叉关注点之间有什么区别？</h2><ul>
<li><p>关注点是我们希望在应用程序模块中拥有的行为。关注点可以定义为我们想要实现的功能。</p>
</li>
<li><p>跨领域的关注点是一个适用于整个应用程序的问题，它会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要的问题，因此它们是跨领域的问题。</p>
</li>
</ul>
<h2 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h2><ul>
<li>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</li>
<li>把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</li>
</ul>
<h2 id="AOP和IOC的原理是什么？"><a href="#AOP和IOC的原理是什么？" class="headerlink" title="AOP和IOC的原理是什么？"></a>AOP和IOC的原理是什么？</h2><ul>
<li><p>ioc控制反转是由Spring容器负责创建对象，管理对象（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
</li>
<li><p>di依赖注入是spring容器根据描述配置将被依赖的类通过构造器或者setter方法注入正在被实例化的类。</p>
</li>
<li><p>aop切面编程是通过抽取公共的日志、权限、事务等切面逻辑，通过jdk或者cglib的动态代理生成代理类将增强代码织入原代码中。合并类的公共处理逻辑可以减少重复代码和耦合，侵入性小，便于容器测试。</p>
</li>
<li><p>AOP 和 IOC是Spring精华部分，AOP可以看做是对OOP的补充，对代码进行横向的扩展，通过代理模式实现，代理模式有静态代理，动态代理，Spring利用的是动态代理，在程序运行过程中将增强代码织入原代码中。</p>
</li>
</ul>
<h2 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h2><ul>
<li>set 注入</li>
<li>构造方法注入</li>
<li>接口注入</li>
</ul>
<h2 id="如何创建动态AOP代理？"><a href="#如何创建动态AOP代理？" class="headerlink" title="如何创建动态AOP代理？"></a>如何创建动态AOP代理？</h2><ul>
<li><p>创建代理的步骤：获取增强方法/增强器，根据增强方法/增强器进行代理。</p>
</li>
<li><p>目标对象如果实现了接口，默认通过JDK代理，也可以强制cglib代理。如果没有实现接口，就必须使用cglib库，Spring会自动实现jdk动态代理和cglib之间的转换。</p>
</li>
<li><p>加载时织入(LTW)是在虚拟机载入字节码文件是动态植入AspectJ切面。LTM参数在虚拟机层面的的设置不够具体，Spring的对LTW的设置可以在类加载器的粒度上打开，通过外部增强实现效果，就不必在工程内部修改代码。</p>
</li>
</ul>
<h2 id="如何创建静态AOP代理？"><a href="#如何创建静态AOP代理？" class="headerlink" title="如何创建静态AOP代理？"></a>如何创建静态AOP代理？</h2><ul>
<li>将动态代理改为静态代理，配置文件需要添加：<code>&lt;context:load-time-weaver /&gt;</code>，然后在META-INF文件夹下建立aop.xml：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;</span><br><span class="line">&lt;aspectj&gt;</span><br><span class="line">	&lt;weaver&gt;&lt;include within=&quot;xx.*&quot; /&gt;&lt;/weaver&gt;</span><br><span class="line">	&lt;aspects&gt;&lt;aspect name=&quot;xx.AspectConfig&quot; /&gt;&lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="Spring-bean的定义和作用域是什么？"><a href="#Spring-bean的定义和作用域是什么？" class="headerlink" title="Spring bean的定义和作用域是什么？"></a>Spring bean的定义和作用域是什么？</h2><ul>
<li><p>Spring Beans是构成Spring应用程序主干的Java对象。</p>
<ul>
<li>它们由Spring IoC容器实例化，组装和管理。</li>
<li>这些bean是使用提供给容器的配置元数据创建的，例如，以XML定义的形式。</li>
</ul>
</li>
<li><p>bean的作用域包括单例，原型，请求，回话，全局。</p>
</li>
</ul>
<h2 id="Bean的生命周期是什么？"><a href="#Bean的生命周期是什么？" class="headerlink" title="Bean的生命周期是什么？"></a>Bean的生命周期是什么？</h2><ul>
<li>创建Bean的实例；</li>
<li>按照配置注入属性；</li>
<li>调用可能实现的BeanNameAware接口方法，传参id。</li>
<li>调用可能实现的BeanFactoryAware接口方法，传参Spring工厂。</li>
<li>调用可能实现的ApplicationContextAware接口方法，传参Spring上下文。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化前方法。</li>
<li>调用可能配置的init-method初始化方法。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化后方法。开始使用。</li>
<li>销毁时，调用可能实现的DisposableBean的destroy方法。</li>
<li>最后，调用可能配置的destroy-method销毁方法。</li>
</ul>
<h2 id="bean的加载过程是什么？"><a href="#bean的加载过程是什么？" class="headerlink" title="bean的加载过程是什么？"></a>bean的加载过程是什么？</h2><ul>
<li>转换对应的beanName。</li>
<li>尝试从缓存中加载单例。</li>
<li>bean的实例化。</li>
<li>对原型模式检查类的依赖。</li>
<li>检查父类工厂。</li>
<li>转化bean的定义类。</li>
<li>寻找依赖。</li>
<li>针对不同的scope创建bean。</li>
<li>类型转换。</li>
</ul>
<h2 id="Spring中如何让A和B两个bean按顺序加载？"><a href="#Spring中如何让A和B两个bean按顺序加载？" class="headerlink" title="Spring中如何让A和B两个bean按顺序加载？"></a>Spring中如何让A和B两个bean按顺序加载？</h2><ul>
<li>用dependon注解依赖关系。</li>
</ul>
<h2 id="什么是循环依赖，Spring如何解决？"><a href="#什么是循环依赖，Spring如何解决？" class="headerlink" title="什么是循环依赖，Spring如何解决？"></a>什么是循环依赖，Spring如何解决？</h2><ul>
<li><p>循环依赖就是循环引用，方法之间的环调用，构成有向环。 </p>
<ul>
<li>Spring的构造器循环依赖将正在创建的 beanName(id) 标志符记录到“当前创建bean池”（构造状态表），</li>
<li>构造所需的类的beanName继续添加到表中，如果已有记录，就说明有环结构，抛出循环依赖的异常。</li>
</ul>
</li>
<li><p>Spring的setter注入的循环依赖是通过提前暴露刚构造完（尚未setter注入）的bean来完成的，且只能解决单例范围的依赖。</p>
<ul>
<li>通过提前暴露一个单例工厂方法，使其他bean能引用到该bean，把beanName标志符加入到“当前创建bean池”中，</li>
<li>然后setter注入后续类，后续类因此创建单例，加入自己的标志符。</li>
<li>当后续类检测到setter需要的类已经位于池中，就通过该标志符在另一个表中找到对应的ObjectFactory工厂，</li>
<li>进而返回工厂类创建的bean. 然后在第二个循环中依次setter注入工厂类创建的bean。</li>
</ul>
</li>
<li><p>Spring的prototype作用域的bean, Spring容器无法完成依赖注入，因为不缓存该作用域的bean,因此无法提前暴露。</p>
</li>
</ul>
<h2 id="如何获取单例？"><a href="#如何获取单例？" class="headerlink" title="如何获取单例？"></a>如何获取单例？</h2><ul>
<li>在全局变量加锁的情况下。</li>
<li>检查singletonObjects缓存类中是否已加载，</li>
<li>没有加载就把beanName记录到加载状态表，</li>
<li>通过ObjectFactory的方法得到实例化bean，</li>
<li>从加载状态表中移除这个beanName，</li>
<li>缓存实例并删除其他状态表的记录。</li>
</ul>
<h2 id="如何从缓存中获取单例bean？"><a href="#如何从缓存中获取单例bean？" class="headerlink" title="如何从缓存中获取单例bean？"></a>如何从缓存中获取单例bean？</h2><ul>
<li>创建单例的时候会存在依赖注入的情况，</li>
<li>而在创建依赖的时候为了避免循环依赖，</li>
<li>Spring创建Bean的原则是不等bean创建完成就会将创建bean的ObjectFactory加入到缓存，</li>
<li>一旦下一个bean创建时需要依赖上个bean，就直接使用ObjectFactory.</li>
</ul>
<h2 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="Bean 是线程安全的吗？"></a>Bean 是线程安全的吗？</h2><ul>
<li>单例的bean不安全，prototype和request作用域的，安全。</li>
<li>通过无状态的设计实现线程安全。</li>
</ul>
<h2 id="创建bean的实例"><a href="#创建bean的实例" class="headerlink" title="创建bean的实例"></a>创建bean的实例</h2><ul>
<li>初始化前先解析，如果已经创建了代理或者在初始化前的后处理器方法中改变了bean, 则直接返回就可以了。否则需要进行常规bean的创建。</li>
<li>创建过程包括：清除单例缓存，创建bean的实例(将BeanDefinition转换为BeanWrapper)，合并类定义的后处理器类解析父类和注解等，依赖处理，属性填充，检查循环依赖，注册DisposableBean, 完成创建并返回。</li>
<li>创建bean的实例，优先使用根定义类的工厂方法实例化，解析构造函数并构造实例。构造实例，要先检查缓存的构造器的唯一解析结果，没解析过的要重新先解析。然后对这个解析结果进行自动注入构造或者默认构造器构造(直接实例化)。</li>
<li>自动注入构造，初始化一个新的类包装器，依次从指定传参、根类定义缓存和配置中获取构造方法参数列表（并转换类型）和参数的个数，从指定传参或者反射获取构造器数组，按照构造器参数从多到少和公开优先的顺序排序，遍历解析构造器并加入缓存，参数类型转换，验证构造函数不是父类重写关系，根据实例化策略和构造函数与参数实例化bean.</li>
<li>实例化策略，如果没有使用replace(覆盖方法)或者lookup(动态替换)配置的方法，直接反射即可实例化。否则就需要使用cglib进行动态代理，将动态的拦截器增强切面方法织入类中，返回代理类。</li>
<li>记录创建bean的ObjectFactory。属性注入，包括根据根据名称、类型注入。</li>
<li>初始化bean，包括激活Aware三个方法，后处理器的前后使用，激活自定义的init方法。</li>
<li>ApplicationContext是对BeanFactory的功能扩展，详见refresh()函数对AC的初始化：</li>
<li>准备刷新上下文环境（准备并验证系统属性或者环境变量），初始化FactoryBean并读取xml，填充FB的功能(如自动注入的注解)，开发者定制的子类覆盖方法(postProcessBeanFactory)执行，FB的后处理器执行，注册拦截bean创建的bean处理器（获取bean时调用），为上下文初始化Message国际化语言源，初始化应用消息广播器并AEM中，留给子类来初始化其他的bean, 在注册的bean中查找监听器bean并注册，初始化剩下的单例，完成刷新过程后，通知生命周期处理器刷新过程，同时发出上下文刷新时间通知其他类。</li>
<li>开发者定制的工厂类后处理方法，为类的创建提供了灵活性。</li>
</ul>
<h2 id="Bean-的创建过程是什么？"><a href="#Bean-的创建过程是什么？" class="headerlink" title="Bean 的创建过程是什么？"></a>Bean 的创建过程是什么？</h2><ul>
<li><p>根据class属性或名称解析类，通过override属性的同名方法个数验证合理性或者标记为没有重载方法，然后进行初始化前的预处理，创建bean.</p>
</li>
<li><p>lookup-method和replace-method两个配置功能的加载就是设置到RootBeanDefinition的methodOverrides属性中。实现原理是在bean实例化时如果检测到存在methodOverrides属性，就会动态地为当前bean生成代理并使用对应的拦截器为bean作增强处理。</p>
</li>
<li><p>实例化的前置处理过程的bean经短路判断非空，则直接返回这个bean，忽略后续bean的创建。AOP功能就是基于这种判断。</p>
</li>
</ul>
<h2 id="如何从bean的实例中获取对象？"><a href="#如何从bean的实例中获取对象？" class="headerlink" title="如何从bean的实例中获取对象？"></a>如何从bean的实例中获取对象？</h2><ul>
<li>加载bean后通过getObjectForBeanInstance方法检测当前bean是否是FactoryBean类型，</li>
<li>是则调用该类型的工厂方法返回真正需要的bean实例，并进行后处理。</li>
</ul>
<h2 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h2><ul>
<li>spring 支持 5 种作用域，如下：<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：</li>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>
</ul>
</li>
<li>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li>
</ul>
<h2 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h2><ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h2><ul>
<li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li>
<li>程序化事务：提供编码的形式管理和维护事务。</li>
</ul>
<h2 id="哪种事务管理类型更可取？"><a href="#哪种事务管理类型更可取？" class="headerlink" title="哪种事务管理类型更可取？"></a>哪种事务管理类型更可取？</h2><ul>
<li>Spring Framework的大多数用户选择声明式事务管理，因为它是对应用程序代码影响最小的选项，因此最符合非侵入式轻量级容器的理想。</li>
<li>声明式事务管理优于程序化事务管理，但它不如程序化事务管理灵活，后者允许您通过代码控制事务。</li>
</ul>
<h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><ul>
<li><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
</li>
<li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
</li>
<li><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
<li><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
</li>
<li><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
</li>
<li><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
</li>
</ul>
<h2 id="Spring-Framework的事务管理有哪些好处？"><a href="#Spring-Framework的事务管理有哪些好处？" class="headerlink" title="Spring Framework的事务管理有哪些好处？"></a>Spring Framework的事务管理有哪些好处？</h2><ul>
<li>它在不同的事务API（如JTA，JDBC，Hibernate，JPA和JDO）之间提供了一致的编程模型。 </li>
<li>与许多复杂的事务API（如JTA）相比，它为程序化事务管理提供了更简单的API。 </li>
<li>它支持声明式事务管理。 </li>
<li>它与Spring的各种数据访问抽象集成得非常好。</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h2><ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h2 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h2><ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h2 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h2><ul>
<li>将 http 请求映射到相应的类/方法上。</li>
</ul>
<h2 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h2><ul>
<li>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，</li>
<li>通过@Autowired 的使用来消除 set/get 方法。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/blog/post/364ea8cc.html</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1. 说一下你熟悉的设计模式？"></a>1. 说一下你熟悉的设计模式？</h2><ul>
<li>根据目的来分可以可以分成3类，创建型、结构型、行为型；<ul>
<li>创建型有5种，工厂方法，抽象工厂，原型，单例，建造者；</li>
<li>结构型有7种，适配器，代理，桥接，装饰，外观，享元，组合；</li>
<li>行为型有11种，模板方法，解释器，策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录；</li>
</ul>
</li>
<li>根据作用范围来分，可以有两类，分别是类模式、对象模式；<ul>
<li>类模式主要有4种，工厂方法，类的适配器，模板方法，解释器；</li>
<li>对象模式有20种，单例，原型，抽象工厂，建造者，代理，对象的适配器，桥接，装饰，外观，享元，组合，策略，命令，责任链，状态，观察者，中介者，迭代器，访问者，备忘录；</li>
</ul>
</li>
</ul>
<a id="more"></a>

<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例，原型，抽象工厂，建造者</td>
<td>代理，(对象）适配器，桥接，装饰，外观，享元，组合</td>
<td>策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录</td>
</tr>
</tbody></table>
<h2 id="2-简单工厂和抽象工厂有什么区别？"><a href="#2-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2. 简单工厂和抽象工厂有什么区别？"></a>2. 简单工厂和抽象工厂有什么区别？</h2><ul>
<li>简单工厂，可以理解为专门生产某一个产品的工厂；</li>
<li>工厂方法，是生产某一类产品的工厂，是生产具体产品的工厂的父类；</li>
<li>抽象工厂，生产多类产品的工厂；</li>
</ul>
<h2 id="3-设计的基本原则有哪些？"><a href="#3-设计的基本原则有哪些？" class="headerlink" title="3. 设计的基本原则有哪些？"></a>3. 设计的基本原则有哪些？</h2><ul>
<li><p>设置模式的六大原则，开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特法则，合成复用原则；</p>
</li>
<li><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；</p>
</li>
<li><p>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现；</p>
</li>
<li><p>依赖倒转原则，针对接口编程，依赖于抽象而不依赖于具体；</p>
</li>
<li><p>接口隔离原则，使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度；</p>
</li>
<li><p>迪米特法则又称为，最少知道原则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立；</p>
</li>
<li><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</li>
</ul>
<h2 id="4-设计模式简介"><a href="#4-设计模式简介" class="headerlink" title="4. 设计模式简介"></a>4. 设计模式简介</h2><ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/blog/post/50daec4.html</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>1. http 响应码 301 和 302 代表的是什么？有什么区别？</h2><ul>
<li><p>301：永久重定向。</p>
</li>
<li><p>302：暂时重定向。</p>
</li>
<li><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2-forward-和-redirect-的区别？"><a href="#2-forward-和-redirect-的区别？" class="headerlink" title="2. forward 和 redirect 的区别？"></a>2. forward 和 redirect 的区别？</h2><ul>
<li>forward 是转发 和 redirect 是重定向：</li>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h2 id="3-简述-tcp-和-udp-的区别？"><a href="#3-简述-tcp-和-udp-的区别？" class="headerlink" title="3. 简述 tcp 和 udp 的区别？"></a>3. 简述 tcp 和 udp 的区别？</h2><ul>
<li><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
</li>
<li><p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
</li>
</ul>
<h2 id="4-tcp-为什么要三次握手-两次不行吗？为什么？"><a href="#4-tcp-为什么要三次握手-两次不行吗？为什么？" class="headerlink" title="4. tcp 为什么要三次握手,两次不行吗？为什么？"></a>4. tcp 为什么要三次握手,两次不行吗？为什么？</h2><ul>
<li>如果采用两次握手，<ul>
<li>那么只要服务器发出确认数据包就会建立连接，</li>
<li>但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，</li>
<li>这样服务器端就白白浪费了一定的资源。</li>
</ul>
</li>
<li>若采用三次握手，<ul>
<li>服务器端没有收到来自客户端的再此确认，</li>
<li>则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-tcp-粘包是怎么产生的？"><a href="#5-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="5. 说一下 tcp 粘包是怎么产生的？"></a>5. 说一下 tcp 粘包是怎么产生的？</h2><ul>
<li>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
</li>
</ul>
<h2 id="6-OSI-的七层模型都有哪些？"><a href="#6-OSI-的七层模型都有哪些？" class="headerlink" title="6. OSI 的七层模型都有哪些？"></a>6. OSI 的七层模型都有哪些？</h2><ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h2 id="7-get-和-post-请求有哪些区别？"><a href="#7-get-和-post-请求有哪些区别？" class="headerlink" title="7. get 和 post 请求有哪些区别？"></a>7. get 和 post 请求有哪些区别？</h2><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h2 id="8-如何实现跨域？"><a href="#8-如何实现跨域？" class="headerlink" title="8. 如何实现跨域？"></a>8. 如何实现跨域？</h2><ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
<h2 id="9-说一下-JSONP-实现原理？"><a href="#9-说一下-JSONP-实现原理？" class="headerlink" title="9. 说一下 JSONP 实现原理？"></a>9. 说一下 JSONP 实现原理？</h2><ul>
<li>jsonp：JSON with Padding，</li>
<li>它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>异常</title>
    <url>/blog/post/23a3bd72.html</url>
    <content><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><blockquote>
<p>Java 的异常处理是通过 5 个关键字来实现的：try，catch，throw，throws，finally。</p>
</blockquote>
<h2 id="1-throw-和-throws-的区别？"><a href="#1-throw-和-throws-的区别？" class="headerlink" title="1. throw 和 throws 的区别？"></a>1. throw 和 throws 的区别？</h2><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<a id="more"></a>

<h2 id="2-final、finally、finalize-有什么区别？"><a href="#2-final、finally、finalize-有什么区别？" class="headerlink" title="2. final、finally、finalize 有什么区别？"></a>2. final、finally、finalize 有什么区别？</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="3-try-catch-finally-中哪个部分可以省略？"><a href="#3-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3. try-catch-finally 中哪个部分可以省略？"></a>3. try-catch-finally 中哪个部分可以省略？</h2><ul>
<li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，</li>
<li>也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li>
</ul>
<h2 id="4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？"><a href="#4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？" class="headerlink" title="4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？"></a>4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？</h2><ul>
<li>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</li>
</ul>
<h2 id="5-常见的异常类有哪些？"><a href="#5-常见的异常类有哪些？" class="headerlink" title="5. 常见的异常类有哪些？"></a>5. 常见的异常类有哪些？</h2><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Web</title>
    <url>/blog/post/fb60fea1.html</url>
    <content><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="1-jsp-和-servlet-有什么区别？"><a href="#1-jsp-和-servlet-有什么区别？" class="headerlink" title="1. jsp 和 servlet 有什么区别？"></a>1. jsp 和 servlet 有什么区别？</h2><ul>
<li>JSP是servlet技术的扩展，本质上就是servlet的简易方式。</li>
<li>servlet和JSP最主要的不同点在于，<ul>
<li>servlet的应用逻辑是在Java文件中，并且完全从表示层中的html里分离开来，</li>
<li>而JSP的情况是Java和html可以组合成一个扩展名为JSP的文件。</li>
</ul>
</li>
<li>JSP侧重于视图，servlet主要用于控制逻辑。</li>
</ul>
<a id="more"></a>

<h2 id="2-jsp-有哪些内置对象？作用分别是什么？"><a href="#2-jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="2. jsp 有哪些内置对象？作用分别是什么？"></a>2. jsp 有哪些内置对象？作用分别是什么？</h2><ul>
<li>JSP有9大内置对象：<ul>
<li>request：封装客户端的请求，其中包含来自get或post请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面对象（相当于java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
</li>
</ul>
<h2 id="3-说一下-jsp-的-4-种作用域？"><a href="#3-说一下-jsp-的-4-种作用域？" class="headerlink" title="3. 说一下 jsp 的 4 种作用域？"></a>3. 说一下 jsp 的 4 种作用域？</h2><ul>
<li>page：代表与一个页面相关的对象和属性。</li>
<li>request：代表与客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li>session：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li>application：代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2 id="4-session-和-cookie-有什么区别？"><a href="#4-session-和-cookie-有什么区别？" class="headerlink" title="4. session 和 cookie 有什么区别？"></a>4. session 和 cookie 有什么区别？</h2><ul>
<li>存储位置不同：session存储在服务器端；cookie存储在浏览器端。</li>
<li>安全性不同：cookie安全性一般，在浏览器存储，可以被伪造和修改。</li>
<li>容量和个数限制：cookie有容量限制，每个站点下的cookie也有个数限制。</li>
<li>存储的多样性：session可以存储在Redis中、数据库中、应用程序中；而cookie只能存储在浏览器中。</li>
</ul>
<h2 id="5-说一下-session-的工作原理？"><a href="#5-说一下-session-的工作原理？" class="headerlink" title="5. 说一下 session 的工作原理？"></a>5. 说一下 session 的工作原理？</h2><ul>
<li>session的工作原理是客户端登录完成之后，服务器会创建对应的session，</li>
<li>session创建完之后，会把session的id发送给客户端，客户端再存储到浏览器中。</li>
<li>这样客户端每次访问服务器时，都会带着sessionid，服务器拿到sessionid之后，</li>
<li>在内存找到与之对应的session这样就可以正常工作了。</li>
</ul>
<h2 id="6-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#6-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="6. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</h2><ul>
<li>可以用，session只是依赖cookie存储sessionid，如果cookie被禁用了，</li>
<li>可以使用url中添加sessionid的方式保证session能正常使用。</li>
</ul>
<h2 id="7-spring-mvc-和-struts-的区别是什么？"><a href="#7-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="7. spring mvc 和 struts 的区别是什么？"></a>7. spring mvc 和 struts 的区别是什么？</h2><ul>
<li>拦截级别：struts2是类级别的拦截；spring mvc是方法级别的拦截。</li>
<li>数据独立性：spring mvc的方法之间基本上独立的，独享request和response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量；而struts2虽然方法之间也是独立的，但其所有action变量是共享的，这不会影响程序运行，却给我们编码和读程序时带来了一定的麻烦。</li>
<li>拦截机制：struts2有以自己的interceptor机制，spring mvc用的是独立的aop方式，这样导致struts2的配置文件量比spring mvc大。</li>
<li>对ajax的支持：spring mvc集成了ajax，所有ajax使用很方便，只需要一个注解@ResponseBody就可以实现了；而struts2一般需要安装插件或者自己写代码才行。</li>
</ul>
<h2 id="8-如何避免-sql-注入？"><a href="#8-如何避免-sql-注入？" class="headerlink" title="8. 如何避免 sql 注入？"></a>8. 如何避免 sql 注入？</h2><ul>
<li>使用预处理PreparedStatement。</li>
<li>使用正则表达式过滤掉字符中的特殊字符。</li>
</ul>
<h2 id="9-什么是-XSS-攻击-如何避免？"><a href="#9-什么是-XSS-攻击-如何避免？" class="headerlink" title="9. 什么是 XSS 攻击,如何避免？"></a>9. 什么是 XSS 攻击,如何避免？</h2><ul>
<li><p>XSS攻击：即跨站脚本攻击，它是Web程序中常见的漏洞。</p>
<ul>
<li>原理是攻击者往Web页面里插入恶意的脚本代码（css代码、JavaScript代码等），</li>
<li>当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的，</li>
<li>如盗取用户cookie、破坏页面结构、重定向到其他网站等。</li>
</ul>
</li>
<li><p>预防XSS的核心是必须对输入的数据做过滤处理。</p>
</li>
</ul>
<h2 id="10-什么是-CSRF-攻击-如何避免？"><a href="#10-什么是-CSRF-攻击-如何避免？" class="headerlink" title="10. 什么是 CSRF 攻击,如何避免？"></a>10. 什么是 CSRF 攻击,如何避免？</h2><ul>
<li>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的名义发送恶意请求，比如：以你名义发送邮件、发消息、购买商品、虚拟货币转账等。</li>
<li>防御手段：<ul>
<li>验证请求来源地址；</li>
<li>关键操作添加验证码；</li>
<li>在请求地址添加token并验证。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>对象拷贝</title>
    <url>/blog/post/ee837b98.html</url>
    <content><![CDATA[<h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><h2 id="1-为什么要使用克隆？"><a href="#1-为什么要使用克隆？" class="headerlink" title="1. 为什么要使用克隆？"></a>1. 为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了</p>
<a id="more"></a>

<h2 id="2-如何实现对象克隆？"><a href="#2-如何实现对象克隆？" class="headerlink" title="2. 如何实现对象克隆？"></a>2. 如何实现对象克隆？</h2><ul>
<li><p>实现Cloneable接口并重写Object类中的clone()方法。</p>
</li>
<li><p>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。</p>
</li>
</ul>
<h2 id="3-深拷贝和浅拷贝区别是什么？"><a href="#3-深拷贝和浅拷贝区别是什么？" class="headerlink" title="3. 深拷贝和浅拷贝区别是什么？"></a>3. 深拷贝和浅拷贝区别是什么？</h2><ul>
<li>在浅克隆中，<ul>
<li>如果原型对象的成员变量是值类型，将复制一份给克隆对象；</li>
<li>如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，</li>
<li>也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</li>
<li>(在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。)</li>
</ul>
</li>
<li>在深克隆中，<ul>
<li>无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，</li>
<li>深克隆将原型对象的所有引用对象也复制一份给克隆对象。</li>
<li>(在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/blog/post/7af799fd.html</url>
    <content><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h2><ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
</ul>
<a id="more"></a>

<h2 id="2-什么是-java-序列化？什么情况下需要序列化？"><a href="#2-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="2. 什么是 java 序列化？什么情况下需要序列化？"></a>2. 什么是 java 序列化？什么情况下需要序列化？</h2><ul>
<li><p>序列化简单来说就<strong>保存对象在内存中的状态</strong>也可以说是<strong>实例化变量</strong>。这是 Java 提供的用来<strong>保存 Object state</strong>，一种保存对象状态的机制。只有实现了 serializable 接口的类的对象才能被实例化。</p>
<ul>
<li>1 当你想把内存中的对象写入到硬盘时</li>
<li>2 当你想用套接字在网络上传输对象时</li>
<li>3 当你想通过 RMI （远程方法调用） 调用对象时</li>
</ul>
<p>​ （RMI 是什么东西？）：RMI 总结来说就是远程调用对象，在一个 jvm 上调用另一个 jvm 的对象。</p>
</li>
</ul>
<h2 id="3-动态代理是什么？有哪些应用？"><a href="#3-动态代理是什么？有哪些应用？" class="headerlink" title="3. 动态代理是什么？有哪些应用？"></a>3. 动态代理是什么？有哪些应用？</h2><ul>
<li>动态代理是运行时动态生成的代理类。</li>
<li>动态代理的应用有spring aop、hibernate数据查询、测试框架的后端mock、rpc、Java注解对象获取等。</li>
</ul>
<h2 id="4-怎么实现动态代理？"><a href="#4-怎么实现动态代理？" class="headerlink" title="4. 怎么实现动态代理？"></a>4. 怎么实现动态代理？</h2><ul>
<li>JDK原生态代理和cglib动态代理。</li>
<li>JDK原生动态代理是基于接口实现的，</li>
<li>cglib是基于继承当前类的子类实现的。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/blog/post/5729df21.html</url>
    <content><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1. 并行和并发有什么区别？"></a>1. 并行和并发有什么区别？</h2><ul>
<li><p>并发:一个处理器同时处理多个任务；</p>
</li>
<li><p>并行:多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
</ul>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生</p>
</blockquote>
<a id="more"></a>

<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2. 线程和进程的区别？"></a>2. 线程和进程的区别？</h2><ul>
<li>操作系统都支持运行多个任务，通常一个任务就是一个程序，而一个程序就是一个进程。当一个进程运行时，内部可能包括多个顺序执行流，每个顺序执行流就是一个线程。</li>
<li>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。</li>
<li>进程代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个进程可以包括多个线程。</li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong></li>
</ul>
<h2 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3. 守护线程是什么？"></a>3. 守护线程是什么？</h2><ul>
<li>在 Java 中有三类线程：主线程、User Thread(用户线程)、Daemon Thread(守护线程)；</li>
<li>守护线程指程序运行的时候在后台提供一种通用服务的线程，比如gc；</li>
<li>主线程和守护线程一起销毁，与用户线程互不影响。</li>
</ul>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4. 创建线程有哪几种方式？"></a>4. 创建线程有哪几种方式？</h2><ul>
<li><p>三种：继承 Thread 类创建线程类/通过 Runnable 接口创建线程类/通过 Callable 和 Future 创建线程</p>
</li>
<li><p>一、继承Thread类创建线程类</p>
<ol>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>二、通过Runnable接口创建线程类</p>
<ol>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>三、通过Callable和Future创建线程</p>
<ol>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</li>
</ol>
</li>
<li><p>采用实现 Runnable、Callable 接口的方式创建多线程时</p>
<ul>
<li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法</li>
</ul>
</li>
<li><p>使用继承 Thread 类的方式创建多线程时</p>
<ul>
<li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li>
<li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-runnable-和-callable-有什么区别？"><a href="#5-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="5. 说一下 runnable 和 callable 有什么区别？"></a>5. 说一下 runnable 和 callable 有什么区别？</h2><ul>
<li>Callable 规定的方法是 call(), Runnable 规定的方法是 run()</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。<br>Callable 接口也是位于 java.util.concurrent 包中。</li>
</ul>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6. 线程有哪些状态？"></a>6. 线程有哪些状态？</h2><p>在 Java 当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>第一是创建状态。在生成线程对象，并没有调用该对象的 start 方法，这是线程处于创建状态；</li>
<li>第二是就绪状态。当调用了线程对象的 start 方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态</li>
<li>第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。</li>
<li>第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend 等方法都可以导致线程阻塞。</li>
<li>第五是死亡状态。如果一个线程的 run 方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪状态。</li>
</ul>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7. sleep() 和 wait() 有什么区别？"></a>7. sleep() 和 wait() 有什么区别？</h2><ul>
<li>sleep 是 Thread 类的方法,wait 是 Object 类中定义的方法。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
<h2 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8. notify()和 notifyAll()有什么区别？"></a>8. notify()和 notifyAll()有什么区别？</h2><ul>
<li>唤醒线程，是将线程由等待池移动到锁池，</li>
<li>notifyAll 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。</li>
<li>notify 只会唤醒一个线程。</li>
</ul>
<h2 id="9-线程的-run-和-start-有什么区别？"><a href="#9-线程的-run-和-start-有什么区别？" class="headerlink" title="9. 线程的 run()和 start()有什么区别？"></a>9. 线程的 run()和 start()有什么区别？</h2><ol>
<li>start() 是启动一个新线程执行 run 代码，run() 是当前线程执行 run 代码；</li>
<li>start() 不能被重复调用，run() 可以</li>
<li>start() 中的 run 代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用 run() 必须等待其代码全部执行完才能继续执行下面的代码。</li>
<li>start() 实现了多线程，run() 没有实现多线程。</li>
</ol>
<h2 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10. 创建线程池有哪几种方式？"></a>10. 创建线程池有哪几种方式？</h2><ol>
<li>使用 ThreadPoolExecutor 的构造方法</li>
<li>Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执</li>
<li>Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ol>
<h2 id="11-线程池都有哪些状态？"><a href="#11-线程池都有哪些状态？" class="headerlink" title="11. 线程池都有哪些状态？"></a>11. 线程池都有哪些状态？</h2><p><img src="..%5Cpic%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="线程池的状态.jpg"></p>
<p>1、RUNNING<br>(1) 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(2) 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态，并且线程池中的任务数为 0！</p>
<p>2、 SHUTDOWN<br>(1) 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的 shutdown()接口时，线程池由 RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP<br>(1) 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的 shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING<br>(1) 状态说明：当所有的任务已终止，ctl 记录的”任务数量”为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 terminated()。terminated()在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated()函数来实现。<br>(2) 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。<br>当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED<br>(1) 状态说明：线程池彻底终止，就变成 TERMINATED 状态。<br>(2) 状态切换：线程池处在 TIDYING 状态时，执行完 terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<h2 id="12-线程池中-submit-和-execute-方法有什么区别？"><a href="#12-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="12. 线程池中 submit()和 execute()方法有什么区别？"></a>12. 线程池中 submit()和 execute()方法有什么区别？</h2><ul>
<li><p>execute 提交的方式只能提交一个 Runnable 的对象，且该方法的返回值是 void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过 ThreadFactory 主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</p>
</li>
<li><p>submit 提交的方式</p>
</li>
<li><p><t> Future<t> submit(Callable<t> task);而 Callable 接口中是一个有返回值的 call 方法。如果在线程的执行过程中发生了异常，get 会获取到异常的信息。</t></t></t></p>
</li>
<li><p>Future&lt;?&gt; submit(Runnable task);也可以提交一个 Runable 接口的对象，这样当调用 get 方法的时候，如果线程执行成功会直接返回 null，如果线程执行异常会返回异常的信息</p>
</li>
<li><p><t> Future<t> submit(Runnable task, T result);除了 task 之外还有一个 result 对象，</t></t></p>
<p>当线程正常结束的时候调用 Future 的 get 方法会返回 result 对象，当线程抛出异常的时候会获取到对应的异常的信息。</p>
</li>
</ul>
<h2 id="13-在-java-程序中怎么保证多线程的运行安全？"><a href="#13-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="13. 在 java 程序中怎么保证多线程的运行安全？"></a>13. 在 java 程序中怎么保证多线程的运行安全？</h2><ol>
<li>使用安全类，比如 Java. util. concurrent 下的类;</li>
<li>使用自动锁 synchronized;</li>
<li>使用手动锁 Lock.</li>
</ol>
<p>1、互斥同步<br>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<br>此外，ReentrantLock也是通过互斥来实现同步。在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。<br>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p>
<p>2、非阻塞同步<br>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。<br>非阻塞的实现CAS（CompareAndSwap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p>
<p>CAS缺点：<br>ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<br>ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>3、无需同步方案<br>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<p>1）可重入代码<br>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。<br>可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。<br>（类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）</p>
<p>2）线程本地存储 ThreadLocal<br>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。</p>
<h2 id="14-多线程-synchronized-锁的升级原理是什么？"><a href="#14-多线程-synchronized-锁的升级原理是什么？" class="headerlink" title="14. 多线程 synchronized 锁的升级原理是什么？"></a>14. 多线程 <strong>synchronized</strong> 锁的升级原理是什么？</h2><ul>
<li>synchronized 锁升级原理：<ul>
<li>在锁对象的对象头里面有一个 threadid 字段，</li>
<li>在第一次访问的时候 threadid 为空，</li>
<li>jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，</li>
<li>再次进入的时候会先判断 threadid 是否与其线程 id 一致，</li>
<li>如果一致, 则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，</li>
<li>通过自旋循环一定次数来获取锁，</li>
<li>执行一定次数之后，如果还没有正常获取到要使用的对象，</li>
<li>此时就会把锁从轻量级升级为重量级锁，</li>
<li>此过程就构成了 synchronized 锁的升级。</li>
</ul>
</li>
</ul>
<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h2 id="15-什么是死锁？"><a href="#15-什么是死锁？" class="headerlink" title="15. 什么是死锁？"></a>15. 什么是死锁？</h2><p>如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。<br>举例来说：有两个进程A和B,A持有资源a等待b资源，B持有资源b等待a资源，两个进程都在等待另一个资源的同时不释放资源，就形成死锁。<br>死锁的发生必须具备以下四个必要条件。</p>
<p>1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p>2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p>4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<h2 id="16-怎么防止死锁？"><a href="#16-怎么防止死锁？" class="headerlink" title="16. 怎么防止死锁？"></a>16. 怎么防止死锁？</h2><blockquote>
<p>处理死锁的思路如下：</p>
</blockquote>
<p>预防死锁：<br>破坏四个必要件中的一个或多个来预防死锁</p>
<p>避免死锁：<br>在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。</p>
<p>检测死锁：<br>运行时产生死锁，及时发现思索，将程序解脱出来。</p>
<p>解除死锁：<br>发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程</p>
<blockquote>
<p>预防死锁的办法：</p>
</blockquote>
<p>破坏请求和保持条件：</p>
<ol>
<li>一次性的申请所有资源。之后不在申请资源，如果不满足资源条件则得不到资源分配。</li>
<li>只获得初期资源运行，之后将运行完的资源释放，请求新的资源。</li>
</ol>
<blockquote>
<p>破坏不可抢占条件：</p>
</blockquote>
<p>当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。</p>
<blockquote>
<p>死锁的解除办法：</p>
<ol>
<li>抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li>
<li>终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。</li>
</ol>
</blockquote>
<h2 id="17-ThreadLocal-是什么？有哪些使用场景？"><a href="#17-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="17. ThreadLocal 是什么？有哪些使用场景？"></a>17. ThreadLocal 是什么？有哪些使用场景？</h2><ul>
<li><p>ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
</li>
<li><p>ThreadLocal 的经典使用场景是数据库连接和 session 管理等。</p>
</li>
</ul>
<h2 id="18-说一下-synchronized-底层实现原理？"><a href="#18-说一下-synchronized-底层实现原理？" class="headerlink" title="18. 说一下 synchronized 底层实现原理？"></a>18. 说一下 synchronized 底层实现原理？</h2><ul>
<li>synchronized 是由一对 monitorenter/monitorexit 指令实现的，</li>
<li>monitor 对象是同步的基本实现单元。</li>
<li>在 Java 6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，</li>
<li>因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。</li>
<li>但在 Java 6 的时候，Java 虚拟机 对此进行了大刀阔斧地改进，提供了三种不同的 monitor 实现，</li>
<li>也就是常说的三种不同的锁：偏向锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</li>
</ul>
<h2 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h2><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="20-synchronized-和-Lock-有什么区别？"><a href="#20-synchronized-和-Lock-有什么区别？" class="headerlink" title="20. synchronized 和 Lock 有什么区别？"></a>20. synchronized 和 Lock 有什么区别？</h2><ul>
<li><p>synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p>
</li>
<li><p>Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p>
</li>
</ul>
<blockquote>
<p>synchronized和Lock比较</p>
</blockquote>
<ul>
<li>synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="21-synchronized-和-ReentrantLock-区别是什么？"><a href="#21-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="21. synchronized 和 ReentrantLock 区别是什么？"></a>21. synchronized 和 ReentrantLock 区别是什么？</h2><blockquote>
<p>两者的共同点：</p>
</blockquote>
<p>1）协调多线程对共享对象、变量的访问</p>
<p>2）可重入，同一线程可以多次获得同一个锁</p>
<p>3）都保证了可见性和互斥性</p>
<blockquote>
<p>两者的不同点：</p>
</blockquote>
<p>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁</p>
<p>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</p>
<p>3）ReentrantLock是API级别的，synchronized是JVM级别的</p>
<p>4）ReentrantLock可以实现公平锁</p>
<p>5）ReentrantLock通过Condition可以绑定多个条件</p>
<p>6）底层实现不一样 synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>
<h2 id="22-说一下-atomic-的原理？"><a href="#22-说一下-atomic-的原理？" class="headerlink" title="22. 说一下 atomic 的原理？"></a>22. 说一下 atomic 的原理？</h2><ul>
<li>atomic 主要利用 CAS (Compare And Swap) 和 volatile 和 native 方法来保证原子操作，</li>
<li>从而避免 synchronized 的高开销，执行效率大为提升。</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>容器</title>
    <url>/blog/post/8f8103b7.html</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul>
<li><a href="https://blog.csdn.net/dengpeng0419/article/details/47983033" target="_blank" rel="noopener">链接</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院的 java 集合</a></li>
</ul>
<a id="more"></a>

<h2 id="1-java-容器都有哪些？"><a href="#1-java-容器都有哪些？" class="headerlink" title="1. java 容器都有哪些？"></a>1. java 容器都有哪些？</h2><blockquote>
<p>Java 容器类类库的用途是“持有对象”，并将其划分为两个不同的概念：</p>
<p>1）Collection集合接口，<br>List 必须按照插入的顺序保存元素，<br>Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p>
<p>2）Map是用来存储成对的“键值”组合容器，允许你使用键来查找值。</p>
</blockquote>
<pre><code>├Collection
│├List
││├LinkedList
││├ArrayList
││└Vector
││ └Stack
│└Set
│ ├HashSet
│ ├TreeSet
│ └LinkedSet
│
└Map
 ├Hashtable
 ├HashMap
 └WeakHashMap</code></pre><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol>
<li>java.util.Collection 是一个集合接口。<ul>
<li>提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collection 接口在 Java 类库中有很多具体的实现。</li>
<li>Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Collection</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├List</span><br><span class="line">│├LinkedList</span><br><span class="line">│├ArrayList</span><br><span class="line">│└Vector</span><br><span class="line">│　└Stack</span><br><span class="line">└Set</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>java.util.Collections 是一个包装类。<ul>
<li>包含有各种有关集合操作的静态多态方法。</li>
<li>此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</li>
</ul>
</li>
</ol>
<h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><table>
<thead>
<tr>
<th>比较</th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td align="center">collection</td>
<td align="center">collection</td>
<td align="center"></td>
</tr>
<tr>
<td>常见实现类</td>
<td align="center">AbstractList(其常用子类有 ArrayList、LinkedList、Vector)</td>
<td align="center">AbstractSet(其常用子类有 HashSet、LinkedHashSet、TreeSet)</td>
<td align="center">HashMap、HashTable、TreeMap</td>
</tr>
<tr>
<td>常见方法</td>
<td align="center">add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td align="center">add( )、remove( )、clear( )、contains( )、size( )</td>
<td align="center">put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td align="center">可重复</td>
<td align="center">不可重复(用<code>equals()</code>判断)</td>
<td align="center">不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td align="center">有序</td>
<td align="center">无序(实际上由 HashCode 决定)</td>
<td align="center"></td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">Vector 线程安全</td>
<td align="center"></td>
<td align="center">Hashtable 线程安全</td>
</tr>
</tbody></table>
<h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><blockquote>
<p><strong>相同点：</strong></p>
<ul>
<li>HashMap 和 Hashtable 都实现了接口 Map, Cloneable, Serializable；</li>
<li>都是将键映射到值的集合对象，其中键与值都是对象，不能包含重复键，但可以包含重复值。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>区别如下：</strong></p>
<ul>
<li>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许；</li>
<li>HashTable 继承自 Dictionary 类，而 HashMap 继承自 AbstractMap 类；</li>
<li>HashTable 的方法使用 synchronized 修饰，是线程安全的， HashMap 线程不安全。</li>
</ul>
</blockquote>
<h2 id="5-如何决定使用-HashMap-还是-TreeMap？"><a href="#5-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使用 HashMap 还是 TreeMap？"></a>5. 如何决定使用 HashMap 还是 TreeMap？</h2><ul>
<li>TreeMap&lt;K,V&gt; 内存储的 Key 是有序的，其 Key 值是要求实现 java.lang.Comparable，所以迭代的时候 TreeMap 默认是按照 Key 值升序排序的；TreeMap 的实现也是基于红黑树结构。</li>
<li>HashMap&lt;K,V&gt;的 Key 值实现散列 hashCode(),分布是散列的均匀的，不支持排序；数据结构主要是桶(数组),链表或红黑树。</li>
<li>大多情况下 HashMap 有更好的性能，所以大多不需要排序的时候我们会使用 HashMap.</li>
</ul>
<h2 id="6-说一下-HashMap-的实现原理？"><a href="#6-说一下-HashMap-的实现原理？" class="headerlink" title="6. 说一下 HashMap 的实现原理？"></a>6. 说一下 HashMap 的实现原理？</h2><ul>
<li>底层实现是数组+链表，JDK8 以后是数组+链表+红黑树；</li>
<li>当我们往 HashMap 中 put 元素的时候，会将新元素存进去，如果存在相等的 Key 则会替换原先的值；</li>
<li>根据 Key的 hash 值得到这个元素在数组中的位置（即下标），</li>
<li>如果数组该位置上已经存放有其他元素了，</li>
<li>那么在这个位置上的元素将以链表的形式存放，</li>
<li>新加入的放在链头，最先加入的放在链尾；</li>
<li>如果链表长度大于等于7 ，则会将链表转换成红黑树；</li>
<li>如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li>
</ul>
<h2 id="7-说一下-HashSet-的实现原理？"><a href="#7-说一下-HashSet-的实现原理？" class="headerlink" title="7. 说一下 HashSet 的实现原理？"></a>7. 说一下 HashSet 的实现原理？</h2><p>底层使用HashMap实现</p>
<h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul>
<li>ArrayList 是实现了基于动态数组的结构；</li>
<li>LinkedList 则是基于实现链表的数据结构；</li>
<li>数据的更新和查找，ArrayList 效率高于 LinkedList，ArrayList 可以根据下标快速定位， LinkedList 只能从头依次查询；</li>
<li>数据的增加和删除，LinkedList效率更高一些，ArrayList 需要同时变更其后的数据下标， LinkedList只需变更前后节点的下一步引用。</li>
</ul>
<h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul>
<li>list 转数组， List 的方法 toArray;</li>
<li>数组转 list， Arrays 的方法 asList.</li>
</ul>
<h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul>
<li>ArrayList 和 Vector 都继承了 AbstractList，都实现了接口List, RandomAccess, Cloneable, Serializable；</li>
<li>Vector 中的方法大多使用 synchronized 关键字修饰，是线程安全的， ArrayList 是线程不安全的。</li>
</ul>
<h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><blockquote>
<p>存储内容比较：</p>
<ul>
<li>​ Array 数组可以包含基本类型和对象类型，</li>
<li>​ ArrayList 却只能包含对象类型。</li>
</ul>
</blockquote>
<blockquote>
<p>空间大小比较：</p>
<ul>
<li>它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。</li>
<li>ArrayList 的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。</li>
</ul>
</blockquote>
<h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul>
<li>Queue 队列是一个先入先出（FIFO）的数据结构;</li>
<li><strong>remove</strong> 移除并返回队列头部的元素如果队列为空，则抛出一个 NoSuchElementException 异常;</li>
<li><strong>poll</strong> 移除并返问队列头部的元素如果队列为空，则返回 null.</li>
</ul>
<h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Hashtable, ConcurrentHashMap, Vector, Stack</p>
<h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><ul>
<li>Iterator接口提供遍历任何Collection的接口；</li>
<li>Collection的实现类使用迭代器方法来获取迭代器实例；</li>
<li>迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<h2 id="15-Iterator-怎么使用？有什么特点？"><a href="#15-Iterator-怎么使用？有什么特点？" class="headerlink" title="15. Iterator 怎么使用？有什么特点？"></a>15. Iterator 怎么使用？有什么特点？</h2><ul>
<li>Java 中使用 Iterator 来遍历集合元素，Iterator 遍历集合元素有以下几个特点:<ul>
<li>Iterator 遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出 ConcurrentModificationEception 的异常。</li>
<li>Iterator 遍历集合元素的过程中可以通过 remove 方法来移除集合中的元素。</li>
<li>Iterator 必须依附某个 Collection 对象而存在，Iterator 本身不具有装载数据对象的功能。</li>
<li>Iterator.remove 方法删除的是上一次 Iterator.next()方法返回的对象。</li>
<li>强调以下 next（）方法，该方法通过游标指向的形式返回 Iterator 下一个元素。</li>
</ul>
</li>
<li><strong>Iterator 的常用方法</strong>:<ul>
<li>boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回 true</li>
<li>Object next(); 返回迭代器中下一个元素</li>
<li>void remove() ; 删除集合里上一个 next 方法调用的时候返回的对象元素</li>
<li>void forEachRemaining(Consumer action) ;使用 Lambdda 表达式的形式输出 Iterator 中所以的元素。注意该方法其实是间接调用 next()方法进行遍历，所以再次是 next（）方法的时候 Iterator 中的对象已经被遍历完了。</li>
</ul>
</li>
</ul>
<h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><p>一．相同点</p>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。</li>
</ul>
<p>二．不同点</p>
<ol>
<li>使用范围不同，Iterator 可以应用于所有的集合，Set、List 和 Map 和这些集合的子类型。而 ListIterator 只能用于 List 及其子类型。</li>
<li>ListIterator 有 add 方法，可以向 List 中添加对象，而 Iterator 不能。</li>
<li>ListIterator 和 Iterator 都有 hasNext()和 next()方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious()和 previous()方法，可以实现逆向（顺序向前）遍历。Iterator 不可以。</li>
<li>ListIterator 可以定位当前索引的位置，nextIndex()和 previousIndex()可以实现。Iterator 没有此功能。</li>
<li>都可实现删除操作，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iterator 仅能遍历，不能修改。</li>
</ol>
<h2 id="17-怎么确保一个集合不能被修改？"><a href="#17-怎么确保一个集合不能被修改？" class="headerlink" title="17. 怎么确保一个集合不能被修改？"></a>17. 怎么确保一个集合不能被修改？</h2><ul>
<li>利用 Collections 提供的 unmodifiableCollection 方法</li>
</ul>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/blog/post/f7ede91d.html</url>
    <content><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="1-JDK-和-JRE-有什么区别？"><a href="#1-JDK-和-JRE-有什么区别？" class="headerlink" title="1. JDK 和 JRE 有什么区别？"></a>1. JDK 和 JRE 有什么区别？</h2><ul>
<li>JDK:Java Development Kit--面向开发人员的 SDK.它提供了 JAVA 的开发环境和运行环境<blockquote>
<p>SDK:Software Development Kit--软件开发包</p>
</blockquote>
</li>
<li>JRE:Java Runtime Environment--面向使用者.提供了 JAVA 的运行环境，包含JVM</li>
<li>JVM:Java Virtual Machine--是我们常说的 Java 虚拟机</li>
</ul>
<a id="more"></a>

<h2 id="2-和-equals-的区别是什么？"><a href="#2-和-equals-的区别是什么？" class="headerlink" title="2. == 和 equals 的区别是什么？"></a>2. == 和 equals 的区别是什么？</h2><ul>
<li>==：基本数据类型比较的是数值，引用类型比较的是内存地址是否相等；</li>
<li>equals：是调用equals方法来比较两个对象<ol>
<li>在没有重写equals方法的情况下，默认调用Object类的equals方法，实际上使用==来比较对象的内存地址；</li>
<li>字符串重写了equals方法，比较的是两个字符串的内容是否一致。</li>
</ol>
</li>
</ul>
<h2 id="3-两个对象的-hashCode-相同-则-equals-也一定为-true-对吗？"><a href="#3-两个对象的-hashCode-相同-则-equals-也一定为-true-对吗？" class="headerlink" title="3. 两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？"></a>3. 两个对象的 hashCode()相同,则 equals()也一定为 true,对吗？</h2><ul>
<li>不对。</li>
<li>需要注意的是当 equals 方法被重写时, hashCode 方法也要被重写.</li>
<li>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<ol>
<li>相等(相同)的对象必须具有相等的哈希码(或者散列码).</li>
<li>如果两个对象的 hashCode 相同,它们并不一定相同.</li>
</ol>
</li>
</ul>
<h2 id="4-final-在-java-中有什么作用？"><a href="#4-final-在-java-中有什么作用？" class="headerlink" title="4. final 在 java 中有什么作用？"></a>4. final 在 java 中有什么作用？</h2><ul>
<li>final 的作用是告诉编译器一块数据是恒定不变得；</li>
<li>final 修饰的类不能被集成，final 类的方法默认都是 final 修饰的，但 final 类的成员变量默认不是final的；</li>
<li>final 修饰方法不能被子类重写，但可以被子类继承；</li>
<li>final 修饰的成员变量表示常量，只能被赋值一次，初次赋值后值不能再被改变；</li>
<li>final 不能修饰构造方法。</li>
</ul>
<h2 id="5-java-中的-Math-round-1-5-等于多少？"><a href="#5-java-中的-Math-round-1-5-等于多少？" class="headerlink" title="5. java 中的 Math.round(-1.5) 等于多少？"></a>5. java 中的 Math.round(-1.5) 等于多少？</h2><ul>
<li>Math.round(11.5)的返回值是 12,Math.round(-11.5)的返回值是-11.</li>
<li>四舍五入的原理是在参数上加 0.5 然后进行下取整.</li>
</ul>
<h2 id="6-String-属于基础的数据类型吗？"><a href="#6-String-属于基础的数据类型吗？" class="headerlink" title="6. String 属于基础的数据类型吗？"></a>6. String 属于基础的数据类型吗？</h2><ul>
<li>基础数据类型 8 种：byte、short、int、long、float、double、char、boolean</li>
<li>String 是对象,是引用类型.</li>
</ul>
<h2 id="7-java-中操作字符串都有哪些类？它们之间有什么区别？"><a href="#7-java-中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="7. java 中操作字符串都有哪些类？它们之间有什么区别？"></a>7. java 中操作字符串都有哪些类？它们之间有什么区别？</h2><ul>
<li>主要有三种, String, StringBuffer, StringBuilder；</li>
<li>String使用final修饰，所用方法都是返回new String，因此对String对象的任何修改操作都会生成新对象，不会影响原对象；</li>
<li>StringBuffer对字符串操作的方法都加了synchronized关键字，保证线程安全；</li>
<li>StringBuilder不保证线程安全；</li>
<li>对于操作效率而言,一般来说,StringBuilder 大于 StringBuffer 大于 String；</li>
<li>对于线程安全而言,StringBuffer 是线程安全的；而 StringBuilder 是非线程安全的；</li>
<li>对于频繁的字符串操作而言,无论是 StringBuffer 还是 StringBuilder,都优于 String.</li>
</ul>
<h2 id="8-String-str-quot-i-quot-与-String-str-new-String-“i”-一样吗？"><a href="#8-String-str-quot-i-quot-与-String-str-new-String-“i”-一样吗？" class="headerlink" title="8. String str=&quot;i&quot;与 String str=new String(“i”)一样吗？"></a>8. String str=&quot;i&quot;与 String str=new String(“i”)一样吗？</h2><ul>
<li>String str = &quot;a&quot;, 内存中如果有“a&quot;,str 就指向它；如果没有,才创建“a”，str指向被创建的“a”;</li>
<li>String str = new String(&quot;a&quot;), 是构造一个 String 对象指向“a”,再将新对象的地址赋给 str.</li>
</ul>
<h2 id="9-如何将字符串反转？"><a href="#9-如何将字符串反转？" class="headerlink" title="9. 如何将字符串反转？"></a>9. 如何将字符串反转？</h2><ul>
<li>利用 StringBuffer 的 reverse 方法</li>
<li>将字符串，从后向前遍历一遍</li>
<li>将字符串，依次放入栈里，再从栈里读出</li>
<li>二分法，将字符串的前后一半分别翻转，再组合在一起</li>
</ul>
<h2 id="10-String-类的常用方法都有那些？"><a href="#10-String-类的常用方法都有那些？" class="headerlink" title="10. String 类的常用方法都有那些？"></a>10. String 类的常用方法都有那些？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回字符串是否长度为0</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回字符串某一位的字符 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 提取子串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串比较</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串是否相等</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anotherObject)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串拼接</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回特定字符在字符串中首次出现的位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch/String str)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 字符串转换成小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//字符串转换成大写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 替换特殊的子字符串成新的子字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 去除字符串两端的空格</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 根据特定表达式分割字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="11-抽象类必须要有抽象方法吗？"><a href="#11-抽象类必须要有抽象方法吗？" class="headerlink" title="11. 抽象类必须要有抽象方法吗？"></a>11. 抽象类必须要有抽象方法吗？</h2><ul>
<li>抽象类不一定要有抽象方法；</li>
<li>用 abstract 修饰的类就是抽象类,即使一个类中的方法全部实现过,也可以用 abstract 修饰为抽象类,所以抽象类不一定都有抽象方法.</li>
<li>延伸：因为真有一种情况可以将类定义为 static 类型的,那就是内部类.</li>
</ul>
<h2 id="12-普通类和抽象类有哪些区别？"><a href="#12-普通类和抽象类有哪些区别？" class="headerlink" title="12. 普通类和抽象类有哪些区别？"></a>12. 普通类和抽象类有哪些区别？</h2><ul>
<li>1、普通类可以去实例化调用；抽象类不能被实例化,因为它是存在于一种概念而不非具体.</li>
<li>2、普通类和抽象类都可以被继承,但是抽象类被继承后子类必须重写继承的抽象方法,除非自类也是抽象类.</li>
<li>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法.</li>
<li>注意,抽象类和普通类的主要有三点区别：<ul>
<li>1)抽象方法必须为 public 或者 protected,缺省情况下默认为 public.(因为如果为 private,则不能被子类继承,子类便无法实现该方法)</li>
<li>2)抽象类不能用来创建对象；</li>
<li>3)如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法.如果子类没有实现父类的抽象方法,则必须将子类也定义为为 abstract 类.</li>
</ul>
</li>
</ul>
<h2 id="13-抽象类能使用-final-修饰吗？"><a href="#13-抽象类能使用-final-修饰吗？" class="headerlink" title="13. 抽象类能使用 final 修饰吗？"></a>13. 抽象类能使用 final 修饰吗？</h2><ul>
<li>不能,抽象类是为了让子类继承之后重写其方法的,而用 final 修饰的类,无法被继承</li>
</ul>
<h2 id="14-接口和抽象类有什么区别？"><a href="#14-接口和抽象类有什么区别？" class="headerlink" title="14. 接口和抽象类有什么区别？"></a>14. 接口和抽象类有什么区别？</h2><table>
<thead>
<tr>
<th></th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认方法实现</td>
<td>抽象类可以有默认的方法实现</td>
<td>接口不能有默认的方法实现。java8以后有特别</td>
</tr>
<tr>
<td>实现</td>
<td>抽象类的子类使用 extends 来继承</td>
<td>接口必须使用 implements 来实现接口</td>
</tr>
<tr>
<td>构造函数</td>
<td>抽象类可以有构造函数</td>
<td>接口不能有</td>
</tr>
<tr>
<td>main 方法</td>
<td>抽象类可以有 main 方法，并且我们能运行它</td>
<td>接口不能有 main 方法</td>
</tr>
<tr>
<td>实现数量</td>
<td>类只能有一个抽象类</td>
<td>类可以有多个接口</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口中的方法默认使用 public 修饰</td>
</tr>
</tbody></table>
<h2 id="15-java-中-IO-流分为几种？"><a href="#15-java-中-IO-流分为几种？" class="headerlink" title="15. java 中 IO 流分为几种？"></a>15. java 中 IO 流分为几种？</h2><ul>
<li>按功能划分：输入流、输出流</li>
<li>按类型划分：字符流、字节流</li>
</ul>
<h2 id="16-BIO、NIO、AIO-有什么区别？"><a href="#16-BIO、NIO、AIO-有什么区别？" class="headerlink" title="16. BIO、NIO、AIO 有什么区别？"></a>16. BIO、NIO、AIO 有什么区别？</h2><ul>
<li>java支持方面<ul>
<li>同步阻塞的 BIO, 服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善;</li>
<li>同步非阻塞的 NIO, 服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理;</li>
<li>异步非阻塞的 AIO, 服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.</li>
</ul>
</li>
<li>适用场景<ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
</li>
</ul>
<h2 id="17-Files-的常用方法都有哪些？"><a href="#17-Files-的常用方法都有哪些？" class="headerlink" title="17. Files 的常用方法都有哪些？"></a>17. Files 的常用方法都有哪些？</h2><table>
<thead>
<tr>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists()</td>
<td>判断 File 对象对应的文件或者目录是否存在若存在则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean delete()</td>
<td>删除 File 对象对应的文件或者目录若成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>boolean createNewFile()</td>
<td>当 File 对象对应的文件不存在时，该方法将新建一个此 File 对象所指定的新文件若创建成功则返回 true，否则返回 false</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回 File 对象表示的文件或文件夹的名称</td>
</tr>
<tr>
<td>String getPath()</td>
<td>返回 File 对象对应的路径</td>
</tr>
<tr>
<td>String getAbsolutePath()</td>
<td>返回 File 对象对应的绝对路径（在 UNIX/Linux 等系统上，如果路径是以正斜线 / 开始的，则这个路径是绝对路径；在 Windows 等系统上，如果路径是从盘符开始的，则这个路径是绝对路径）</td>
</tr>
<tr>
<td>String getParent()</td>
<td>返回 File 对象对应目录的父目录，（即返回的目录不包含最后一级子目录）</td>
</tr>
<tr>
<td>boolean canRead()</td>
<td>判断 File 对象对应的文件或者目录是否可读若可读则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean canWrite()</td>
<td>判断 File 对象对应的文件或者目录是否可写。若可写则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isFile()</td>
<td>判断 File 对象对应的是否是文件（不是目录）若是文件则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isDirectory()</td>
<td>判断 File 对象对应的是否是目录（不是文件）若是目录则返回 true，反之返回 false</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断 File 对象对应的文件或者目录是否是绝对路径</td>
</tr>
<tr>
<td>long lastModified()</td>
<td>返回 1970 年 1 月 1 日 0 时 0 分 0 秒到文件最好修改时间的毫秒值</td>
</tr>
<tr>
<td>long length()</td>
<td>返回文件内容长度</td>
</tr>
<tr>
<td>String [ ]list()</td>
<td>返回指定目录的全部内容，只列出名称</td>
</tr>
<tr>
<td>File[ ] listFiles()</td>
<td>返回一个包含了 File 对象所有子文件和子目录的 File 数组</td>
</tr>
</tbody></table>
<h2 id="18-java-如何解决的多重继承"><a href="#18-java-如何解决的多重继承" class="headerlink" title="18. java 如何解决的多重继承"></a>18. java 如何解决的多重继承</h2><p>多重继承指的是一个类可以同时从多于一个的父类那里继承行为和特征</p>
<ol>
<li>接口，实现多个接口；</li>
<li>内部类，使用多个内部类分别继承不同的类，向外提供内部类的方法。</li>
</ol>
]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
