<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="32x32" href="http://sometwo.org/wp-content/themes/JieStyle-Two-master/images/icon_32.png?v=7.4.1">
  <link rel="icon" type="image/png" sizes="16x16" href="http://sometwo.org/wp-content/themes/JieStyle-Two-master/images/icon_32.png?v=7.4.1">
  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.4.1" color="#222">

<link rel="stylesheet" href="/blog/css/main.css?v=7.4.1">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Gemini',
    version: '7.4.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.json',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="一些学习笔记与人生的妄想。Nameless want to be someone,  but end to nobody.  Maybe sometwo this time.">
<meta name="keywords" content="blog, life, naive, sometwo">
<meta property="og:type" content="website">
<meta property="og:title" content="佚名">
<meta property="og:url" content="https://sometwo7.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="佚名">
<meta property="og:description" content="一些学习笔记与人生的妄想。Nameless want to be someone,  but end to nobody.  Maybe sometwo this time.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="佚名">
<meta name="twitter:description" content="一些学习笔记与人生的妄想。Nameless want to be someone,  but end to nobody.  Maybe sometwo this time.">
  <link rel="canonical" href="https://sometwo7.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>佚名</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">佚名</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">一生太短，请务必热情！(Life too short, just be active!)</p>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-tags">
      
    

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-categories">
      
    

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a href="javascript:;" class="popup-trigger">
        
          <i class="fa fa-search fa-fw"></i>搜索</a>
      </li>
    
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
            

          <div id="content" class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/11SpringBootSpringCloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/11SpringBootSpringCloud/" class="post-title-link" itemprop="url">Spring Boot/Spring Cloud</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:21" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:21+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Boot-Spring-Cloud"><a href="#Spring-Boot-Spring-Cloud" class="headerlink" title="Spring Boot/Spring Cloud"></a>Spring Boot/Spring Cloud</h1><h2 id="1-什么是-spring-boot？"><a href="#1-什么是-spring-boot？" class="headerlink" title="1. 什么是 spring boot？"></a>1. 什么是 spring boot？</h2><ul>
<li><p>在Spring框架这个大家族中，产生了很多衍生框架，比如 Spring、SpringMVC框架等，</p>
</li>
<li><p>Spring的核心内容在于控制反转(IOC)和依赖注入(DI),</p>
</li>
<li><p>在操作方面是指在spring配置文件中创建，依赖注入即为由spring容器为应用程序的某个对象提供资源，比如 引用对象、常量数据等。</p>
</li>
<li><p>SpringBoot是一个框架，一种全新的编程规范，他的产生简化了框架的使用，</p>
</li>
<li><p>所谓简化是指简化了Spring众多框架中所需的大量且繁琐的配置文件，</p>
</li>
<li><p>所以 SpringBoot是一个服务于框架的框架，服务范围是简化配置文件。</p>
</li>
</ul>
<h2 id="2-为什么要用-spring-boot？"><a href="#2-为什么要用-spring-boot？" class="headerlink" title="2. 为什么要用 spring boot？"></a>2. 为什么要用 spring boot？</h2><ul>
<li>使编码变简单</li>
<li>使配置变简单</li>
<li>使部署变简单</li>
<li>使监控变简单</li>
<li>Spring的不足</li>
</ul>
<h2 id="3-spring-boot-核心配置文件是什么？"><a href="#3-spring-boot-核心配置文件是什么？" class="headerlink" title="3. spring boot 核心配置文件是什么？"></a>3. spring boot 核心配置文件是什么？</h2><p>Spring Boot提供了两种常用的配置文件：</p>
<ul>
<li>properties文件</li>
<li>yml文件</li>
</ul>
<h2 id="4-spring-boot-配置文件有哪几种类型？它们有什么区别？"><a href="#4-spring-boot-配置文件有哪几种类型？它们有什么区别？" class="headerlink" title="4. spring boot 配置文件有哪几种类型？它们有什么区别？"></a>4. spring boot 配置文件有哪几种类型？它们有什么区别？</h2><ul>
<li>Spring Boot提供了两种常用的配置文件，分别是properties文件和yml文件。</li>
<li>相对于properties文件而言，yml文件更年轻，也有很多的坑。</li>
<li>可谓成也萧何败萧何，yml通过空格来确定层级关系，使配置文件结构跟清晰，但也会因为微不足道的空格而破坏了层级关系。</li>
</ul>
<h2 id="5-spring-boot-有哪些方式可以实现热部署？"><a href="#5-spring-boot-有哪些方式可以实现热部署？" class="headerlink" title="5. spring boot 有哪些方式可以实现热部署？"></a>5. spring boot 有哪些方式可以实现热部署？</h2><ul>
<li><p>SpringBoot热部署实现有两种方式：</p>
</li>
<li><p>使用spring loaded</p>
</li>
<li><p>使用spring-boot-devtools</p>
</li>
</ul>
<h2 id="6-jpa-和-hibernate-有什么区别？"><a href="#6-jpa-和-hibernate-有什么区别？" class="headerlink" title="6. jpa 和 hibernate 有什么区别？"></a>6. jpa 和 hibernate 有什么区别？</h2><ul>
<li>JPA Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。</li>
<li>Hibernate，当今很流行的ORM框架，是JPA的一个实现，但是其功能是JPA的超集。</li>
<li>JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。那么Hibernate是如何实现与JPA的这种关系的呢。Hibernate主要是通过三个组件来实现的，及hibernate-annotation、hibernate-entitymanager和hibernate-core。</li>
<li>hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。</li>
<li>hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。</li>
<li>hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。</li>
</ul>
<h2 id="7-什么是-spring-cloud？"><a href="#7-什么是-spring-cloud？" class="headerlink" title="7. 什么是 spring cloud？"></a>7. 什么是 spring cloud？</h2><ul>
<li><p>从字面理解，Spring Cloud 就是致力于分布式系统、云服务的框架。</p>
</li>
<li><p>Spring Cloud 是整个 Spring 家族中新的成员，是最近云服务火爆的必然产物。</p>
</li>
<li><p>Spring Cloud 为开发人员提供了快速构建分布式系统中一些常见模式的工具，例如：</p>
<ul>
<li>配置管理</li>
<li>服务注册与发现</li>
<li>断路器</li>
<li>智能路由</li>
<li>服务间调用</li>
<li>负载均衡</li>
<li>微代理</li>
<li>控制总线</li>
<li>一次性令牌</li>
<li>全局锁</li>
<li>领导选举</li>
<li>分布式会话</li>
<li>集群状态</li>
<li>分布式消息</li>
</ul>
</li>
<li><p>使用 Spring Cloud 开发人员可以开箱即用的实现这些模式的服务和应用程序。这些服务可以任何环境下运行，包括分布式环境，也包括开发人员自己的笔记本电脑以及各种托管平台。</p>
</li>
</ul>
<h2 id="8-spring-cloud-断路器的作用是什么？"><a href="#8-spring-cloud-断路器的作用是什么？" class="headerlink" title="8. spring cloud 断路器的作用是什么？"></a>8. spring cloud 断路器的作用是什么？</h2><ul>
<li><p>在Spring Cloud中使用了 Hystrix 来实现断路器的功能，</p>
</li>
<li><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</p>
</li>
<li><p>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</p>
</li>
<li><p>断路器模式也使应用程序能够检测故障是否已经解决，如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p>
</li>
<li><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。</p>
</li>
<li><p>它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。</p>
</li>
<li><p>如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，</p>
</li>
<li><p>或以提醒管理员当断路器跳闸，以在打开状态。</p>
</li>
</ul>
<h2 id="9-spring-cloud-的核心组件有哪些？"><a href="#9-spring-cloud-的核心组件有哪些？" class="headerlink" title="9. spring cloud 的核心组件有哪些？"></a>9. spring cloud 的核心组件有哪些？</h2><ul>
<li><p>服务发现——Netflix Eureka</p>
<ul>
<li>一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。</li>
<li>由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。</li>
<li>Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li>
<li>Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。</li>
</ul>
</li>
<li><p>客服端负载均衡——Netflix Ribbon</p>
<ul>
<li>Ribbon，主要提供客户侧的软件负载均衡算法。</li>
<li>Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。</li>
<li>Ribbon内置可插拔、可定制的负载均衡组件。</li>
</ul>
</li>
<li><p>断路器——Netflix Hystrix</p>
<ul>
<li>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，</li>
<li>允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。</li>
<li>断路器模式也使应用程序能够检测故障是否已经解决。</li>
<li>如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</li>
</ul>
</li>
<li><p>服务网关——Netflix Zuul</p>
<ul>
<li>类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</li>
</ul>
</li>
<li><p>分布式配置——Spring Cloud Config</p>
<ul>
<li>这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</li>
</ul>
</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/10SpringSpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/10SpringSpringMVC/" class="post-title-link" itemprop="url">Spring/Spring MVC</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:20" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:20+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Spring-Spring-MVC"><a href="#Spring-Spring-MVC" class="headerlink" title="Spring/Spring MVC"></a>Spring/Spring MVC</h1><h2 id="为什么要使用-spring？"><a href="#为什么要使用-spring？" class="headerlink" title="为什么要使用 spring？"></a>为什么要使用 spring？</h2><ul>
<li><p>简介</p>
<ul>
<li>目的：解决企业应用开发的复杂性</li>
<li>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能</li>
<li>范围：任何Java应用</li>
<li>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</li>
</ul>
</li>
<li><p>轻量　　</p>
<ul>
<li>从大小与开销两方面而言Spring都是轻量的。</li>
<li>完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。</li>
<li>并且Spring所需的处理开销也是微不足道的。</li>
<li>此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</li>
</ul>
</li>
<li><p>控制反转　　</p>
<ul>
<li>Sping通过一种称作控制反转（IoC）的技术促进了松耦合。</li>
<li>当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。</li>
<li>你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</li>
</ul>
</li>
<li><p>面向切面　　</p>
<ul>
<li>Spring提供了面向切面编程的丰富支持，</li>
<li>允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。</li>
<li>应用对象只实现它们应该做的——完成业务逻辑——仅此而已。</li>
<li>它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</li>
</ul>
</li>
<li><p>容器</p>
<ul>
<li>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，</li>
<li>你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），</li>
<li>你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。</li>
<li>然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li>Spring可以将简单的组件配置、组合成为复杂的应用。</li>
<li>在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。</li>
<li>Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</li>
</ul>
</li>
<li><p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>
</li>
</ul>
<h2 id="Spring的设计模式有几种？"><a href="#Spring的设计模式有几种？" class="headerlink" title="Spring的设计模式有几种？"></a>Spring的设计模式有几种？</h2><ul>
<li><p>9种。</p>
</li>
<li><p>简单工厂：FactoryBean。</p>
</li>
<li><p>工厂方法：xml文件的factory-bean属性指定工厂方法。</p>
</li>
<li><p>单例模式：默认唯一的访问点是BeanFactory访问点。</p>
</li>
<li><p>适配器模式：HanderAdapter，AdvisorAdaptor。</p>
</li>
<li><p>装饰器模式：Wrapper，Decorator。</p>
</li>
<li><p>代理模式：AOP功能的原理就使用代理模式。</p>
</li>
<li><p>观察者模式：监听器。</p>
</li>
<li><p>策略模式：实例化对象的时候使用策略模式。</p>
</li>
<li><p>模板方法模式：JdbcTemplate。</p>
</li>
</ul>
<h2 id="spring-有哪些主要模块？"><a href="#spring-有哪些主要模块？" class="headerlink" title="spring 有哪些主要模块？"></a>spring 有哪些主要模块？</h2><ul>
<li><p>主要有七个模块；</p>
</li>
<li><p>核心容器（Spring Core）</p>
<ul>
<li>核心容器提供Spring框架的基本功能。</li>
<li>Spring以bean的方式组织和管理Java应用中的各个组件及其关系。</li>
<li>Spring使用BeanFactory来产生和管理Bean，它是工厂模式的实现。</li>
<li>BeanFactory使用控制反转(IoC)模式将应用的配置和依赖性规范与实际的应用程序代码分开。</li>
</ul>
</li>
<li><p>应用上下文（Spring Context）</p>
<ul>
<li>Spring上下文是一个配置文件，向Spring框架提供上下文信息。</li>
<li>Spring上下文包括企业服务，如JNDI、EJB、电子邮件、国际化、校验和调度功能。</li>
</ul>
</li>
<li><p>Spring面向切面编程（Spring AOP）</p>
<ul>
<li>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring框架中。</li>
<li>所以，可以很容易地使 Spring框架管理的任何对象支持 AOP。</li>
<li>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</li>
<li>通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</li>
</ul>
</li>
<li><p>JDBC和DAO模块（Spring DAO）</p>
<ul>
<li>JDBC、DAO的抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理，和不同数据库供应商所抛出的错误信息。</li>
<li>异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。</li>
</ul>
</li>
<li><p>对象实体映射（Spring ORM）</p>
<ul>
<li>Spring框架插入了若干个ORM框架，从而提供了ORM对象的关系工具，</li>
<li>其中包括了Hibernate、JDO和 IBatis SQL Map等，所有这些都遵从Spring的通用事物和DAO异常层次结构。</li>
</ul>
</li>
<li><p>Web模块（Spring Web）</p>
<ul>
<li>Web上下文模块建立在应用程序上下文模块之上，为基于web的应用程序提供了上下文。</li>
<li>所以Spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li>
</ul>
</li>
<li><p>MVC模块（Spring Web MVC）</p>
<ul>
<li>MVC框架是一个全功能的构建Web应用程序的MVC实现。</li>
<li>通过策略接口，MVC框架变成为高度可配置的。</li>
<li>MVC容纳了大量视图技术，其中包括JSP、POI等，</li>
<li>模型来有JavaBean来构成，存放于 model 当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码，由c的事情。</li>
<li>Spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境。</li>
<li>Spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问的对象，</li>
<li>毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用。</li>
</ul>
</li>
</ul>
<h2 id="Spring容器有几种？"><a href="#Spring容器有几种？" class="headerlink" title="Spring容器有几种？"></a>Spring容器有几种？</h2><ul>
<li>BeanFactory是最简答的容器，提供了基本的DI支持。最常用的BeanFactory实现就是XmlBeanFactory类。</li>
<li>ApplicationContext扩展了BeanFactory的功能，提供面向应用的服务。</li>
<li>通过缓存在map中，实现了类的复用。</li>
</ul>
<h2 id="beanfactory和applicationcontext是什么关系，使用有什么区别。"><a href="#beanfactory和applicationcontext是什么关系，使用有什么区别。" class="headerlink" title="beanfactory和applicationcontext是什么关系，使用有什么区别。"></a>beanfactory和applicationcontext是什么关系，使用有什么区别。</h2><ul>
<li>ApplicationContex提供了一种解析文本消息的方法，一种加载文件资源（如图像）的通用方法，它们可以将事件发布到注册为侦听器的bean。</li>
<li>此外，可以在应用程序上下文中以声明方式处理容器中的容器或容器上的操作，这些操作必须以编程方式与Bean Factory一起处理。</li>
<li>ApplicationContex实现MessageSource，一个用于获取本地化消息的接口，实际的实现是可插入的。</li>
</ul>
<h2 id="FactoryBean如何使用？"><a href="#FactoryBean如何使用？" class="headerlink" title="FactoryBean如何使用？"></a>FactoryBean如何使用？</h2><ul>
<li>一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean. </li>
<li>如果类的配置复杂，那么就可以实现一个FactoryBean接口的工厂类，在getObject()方法中定制实例化逻辑。</li>
<li>当使用这个类的时候，Spring通过反射机制发现这个类实现了该工厂接口，就通过getObject()方法返回实例。</li>
<li>如果要获得工厂类本身的实例，则需要在beanName前面加&quot;&amp;&quot;。</li>
</ul>
<h1 id="AOP和IOC"><a href="#AOP和IOC" class="headerlink" title="AOP和IOC"></a>AOP和IOC</h1><h2 id="解释一下什么是-aop？"><a href="#解释一下什么是-aop？" class="headerlink" title="解释一下什么是 aop？"></a>解释一下什么是 aop？</h2><ul>
<li><p>面向方面的编程（AOP）是一种编程技术，它允许程序员模块化横切关注点或行为，这些问题或行为跨越典型的责任分工，例如日志记录和事务管理。</p>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。</p>
</li>
<li><p>OOP（Object-Oriented Programing，面向对象编程）</p>
<ul>
<li>OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。</li>
<li>当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。</li>
<li>也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。</li>
<li>例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。</li>
<li>对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。</li>
<li>这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</li>
</ul>
</li>
<li><p>AOP（Aspect-Oriented Programming，面向方面编程）</p>
<ul>
<li>它利用一种称为“横切”的技术，剖解开封装的对象内部，</li>
<li>并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。</li>
<li>所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，</li>
<li>便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</li>
<li>AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；</li>
<li>那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。</li>
<li>然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</li>
</ul>
</li>
<li><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。</p>
<ul>
<li>业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。</li>
<li>横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。</li>
<li>比如权限认证、日志、事务处理。</li>
<li>AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</li>
<li>AOP的核心思想就是，将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。</li>
</ul>
</li>
</ul>
<h2 id="Spring-AOP中的关注点和交叉关注点之间有什么区别？"><a href="#Spring-AOP中的关注点和交叉关注点之间有什么区别？" class="headerlink" title="Spring AOP中的关注点和交叉关注点之间有什么区别？"></a>Spring AOP中的关注点和交叉关注点之间有什么区别？</h2><ul>
<li><p>关注点是我们希望在应用程序模块中拥有的行为。关注点可以定义为我们想要实现的功能。</p>
</li>
<li><p>跨领域的关注点是一个适用于整个应用程序的问题，它会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要的问题，因此它们是跨领域的问题。</p>
</li>
</ul>
<h2 id="解释一下什么是-ioc？"><a href="#解释一下什么是-ioc？" class="headerlink" title="解释一下什么是 ioc？"></a>解释一下什么是 ioc？</h2><ul>
<li>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</li>
<li>把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</li>
</ul>
<h2 id="AOP和IOC的原理是什么？"><a href="#AOP和IOC的原理是什么？" class="headerlink" title="AOP和IOC的原理是什么？"></a>AOP和IOC的原理是什么？</h2><ul>
<li><p>ioc控制反转是由Spring容器负责创建对象，管理对象（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。</p>
</li>
<li><p>di依赖注入是spring容器根据描述配置将被依赖的类通过构造器或者setter方法注入正在被实例化的类。</p>
</li>
<li><p>aop切面编程是通过抽取公共的日志、权限、事务等切面逻辑，通过jdk或者cglib的动态代理生成代理类将增强代码织入原代码中。合并类的公共处理逻辑可以减少重复代码和耦合，侵入性小，便于容器测试。</p>
</li>
<li><p>AOP 和 IOC是Spring精华部分，AOP可以看做是对OOP的补充，对代码进行横向的扩展，通过代理模式实现，代理模式有静态代理，动态代理，Spring利用的是动态代理，在程序运行过程中将增强代码织入原代码中。</p>
</li>
</ul>
<h2 id="spring-常用的注入方式有哪些？"><a href="#spring-常用的注入方式有哪些？" class="headerlink" title="spring 常用的注入方式有哪些？"></a>spring 常用的注入方式有哪些？</h2><ul>
<li>set 注入</li>
<li>构造方法注入</li>
<li>接口注入</li>
</ul>
<h2 id="如何创建动态AOP代理？"><a href="#如何创建动态AOP代理？" class="headerlink" title="如何创建动态AOP代理？"></a>如何创建动态AOP代理？</h2><ul>
<li><p>创建代理的步骤：获取增强方法/增强器，根据增强方法/增强器进行代理。</p>
</li>
<li><p>目标对象如果实现了接口，默认通过JDK代理，也可以强制cglib代理。如果没有实现接口，就必须使用cglib库，Spring会自动实现jdk动态代理和cglib之间的转换。</p>
</li>
<li><p>加载时织入(LTW)是在虚拟机载入字节码文件是动态植入AspectJ切面。LTM参数在虚拟机层面的的设置不够具体，Spring的对LTW的设置可以在类加载器的粒度上打开，通过外部增强实现效果，就不必在工程内部修改代码。</p>
</li>
</ul>
<h2 id="如何创建静态AOP代理？"><a href="#如何创建静态AOP代理？" class="headerlink" title="如何创建静态AOP代理？"></a>如何创建静态AOP代理？</h2><ul>
<li>将动态代理改为静态代理，配置文件需要添加：<code>&lt;context:load-time-weaver /&gt;</code>，然后在META-INF文件夹下建立aop.xml：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE aspectj PUBLIC &quot;-//AspectJ//DTD//EN&quot; &quot;http://www.eclipse.org/aspectj/dtd/aspectj.dtd&quot;&gt;</span><br><span class="line">&lt;aspectj&gt;</span><br><span class="line">	&lt;weaver&gt;&lt;include within=&quot;xx.*&quot; /&gt;&lt;/weaver&gt;</span><br><span class="line">	&lt;aspects&gt;&lt;aspect name=&quot;xx.AspectConfig&quot; /&gt;&lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="Spring-bean的定义和作用域是什么？"><a href="#Spring-bean的定义和作用域是什么？" class="headerlink" title="Spring bean的定义和作用域是什么？"></a>Spring bean的定义和作用域是什么？</h2><ul>
<li><p>Spring Beans是构成Spring应用程序主干的Java对象。</p>
<ul>
<li>它们由Spring IoC容器实例化，组装和管理。</li>
<li>这些bean是使用提供给容器的配置元数据创建的，例如，以XML定义的形式。</li>
</ul>
</li>
<li><p>bean的作用域包括单例，原型，请求，回话，全局。</p>
</li>
</ul>
<h2 id="Bean的生命周期是什么？"><a href="#Bean的生命周期是什么？" class="headerlink" title="Bean的生命周期是什么？"></a>Bean的生命周期是什么？</h2><ul>
<li>创建Bean的实例；</li>
<li>按照配置注入属性；</li>
<li>调用可能实现的BeanNameAware接口方法，传参id。</li>
<li>调用可能实现的BeanFactoryAware接口方法，传参Spring工厂。</li>
<li>调用可能实现的ApplicationContextAware接口方法，传参Spring上下文。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化前方法。</li>
<li>调用可能配置的init-method初始化方法。</li>
<li>调用可能关联的BeanPostProcessor接口的初始化后方法。开始使用。</li>
<li>销毁时，调用可能实现的DisposableBean的destroy方法。</li>
<li>最后，调用可能配置的destroy-method销毁方法。</li>
</ul>
<h2 id="bean的加载过程是什么？"><a href="#bean的加载过程是什么？" class="headerlink" title="bean的加载过程是什么？"></a>bean的加载过程是什么？</h2><ul>
<li>转换对应的beanName。</li>
<li>尝试从缓存中加载单例。</li>
<li>bean的实例化。</li>
<li>对原型模式检查类的依赖。</li>
<li>检查父类工厂。</li>
<li>转化bean的定义类。</li>
<li>寻找依赖。</li>
<li>针对不同的scope创建bean。</li>
<li>类型转换。</li>
</ul>
<h2 id="Spring中如何让A和B两个bean按顺序加载？"><a href="#Spring中如何让A和B两个bean按顺序加载？" class="headerlink" title="Spring中如何让A和B两个bean按顺序加载？"></a>Spring中如何让A和B两个bean按顺序加载？</h2><ul>
<li>用dependon注解依赖关系。</li>
</ul>
<h2 id="什么是循环依赖，Spring如何解决？"><a href="#什么是循环依赖，Spring如何解决？" class="headerlink" title="什么是循环依赖，Spring如何解决？"></a>什么是循环依赖，Spring如何解决？</h2><ul>
<li><p>循环依赖就是循环引用，方法之间的环调用，构成有向环。 </p>
<ul>
<li>Spring的构造器循环依赖将正在创建的 beanName(id) 标志符记录到“当前创建bean池”（构造状态表），</li>
<li>构造所需的类的beanName继续添加到表中，如果已有记录，就说明有环结构，抛出循环依赖的异常。</li>
</ul>
</li>
<li><p>Spring的setter注入的循环依赖是通过提前暴露刚构造完（尚未setter注入）的bean来完成的，且只能解决单例范围的依赖。</p>
<ul>
<li>通过提前暴露一个单例工厂方法，使其他bean能引用到该bean，把beanName标志符加入到“当前创建bean池”中，</li>
<li>然后setter注入后续类，后续类因此创建单例，加入自己的标志符。</li>
<li>当后续类检测到setter需要的类已经位于池中，就通过该标志符在另一个表中找到对应的ObjectFactory工厂，</li>
<li>进而返回工厂类创建的bean. 然后在第二个循环中依次setter注入工厂类创建的bean。</li>
</ul>
</li>
<li><p>Spring的prototype作用域的bean, Spring容器无法完成依赖注入，因为不缓存该作用域的bean,因此无法提前暴露。</p>
</li>
</ul>
<h2 id="如何获取单例？"><a href="#如何获取单例？" class="headerlink" title="如何获取单例？"></a>如何获取单例？</h2><ul>
<li>在全局变量加锁的情况下。</li>
<li>检查singletonObjects缓存类中是否已加载，</li>
<li>没有加载就把beanName记录到加载状态表，</li>
<li>通过ObjectFactory的方法得到实例化bean，</li>
<li>从加载状态表中移除这个beanName，</li>
<li>缓存实例并删除其他状态表的记录。</li>
</ul>
<h2 id="如何从缓存中获取单例bean？"><a href="#如何从缓存中获取单例bean？" class="headerlink" title="如何从缓存中获取单例bean？"></a>如何从缓存中获取单例bean？</h2><ul>
<li>创建单例的时候会存在依赖注入的情况，</li>
<li>而在创建依赖的时候为了避免循环依赖，</li>
<li>Spring创建Bean的原则是不等bean创建完成就会将创建bean的ObjectFactory加入到缓存，</li>
<li>一旦下一个bean创建时需要依赖上个bean，就直接使用ObjectFactory.</li>
</ul>
<h2 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="Bean 是线程安全的吗？"></a>Bean 是线程安全的吗？</h2><ul>
<li>单例的bean不安全，prototype和request作用域的，安全。</li>
<li>通过无状态的设计实现线程安全。</li>
</ul>
<h2 id="创建bean的实例"><a href="#创建bean的实例" class="headerlink" title="创建bean的实例"></a>创建bean的实例</h2><ul>
<li>初始化前先解析，如果已经创建了代理或者在初始化前的后处理器方法中改变了bean, 则直接返回就可以了。否则需要进行常规bean的创建。</li>
<li>创建过程包括：清除单例缓存，创建bean的实例(将BeanDefinition转换为BeanWrapper)，合并类定义的后处理器类解析父类和注解等，依赖处理，属性填充，检查循环依赖，注册DisposableBean, 完成创建并返回。</li>
<li>创建bean的实例，优先使用根定义类的工厂方法实例化，解析构造函数并构造实例。构造实例，要先检查缓存的构造器的唯一解析结果，没解析过的要重新先解析。然后对这个解析结果进行自动注入构造或者默认构造器构造(直接实例化)。</li>
<li>自动注入构造，初始化一个新的类包装器，依次从指定传参、根类定义缓存和配置中获取构造方法参数列表（并转换类型）和参数的个数，从指定传参或者反射获取构造器数组，按照构造器参数从多到少和公开优先的顺序排序，遍历解析构造器并加入缓存，参数类型转换，验证构造函数不是父类重写关系，根据实例化策略和构造函数与参数实例化bean.</li>
<li>实例化策略，如果没有使用replace(覆盖方法)或者lookup(动态替换)配置的方法，直接反射即可实例化。否则就需要使用cglib进行动态代理，将动态的拦截器增强切面方法织入类中，返回代理类。</li>
<li>记录创建bean的ObjectFactory。属性注入，包括根据根据名称、类型注入。</li>
<li>初始化bean，包括激活Aware三个方法，后处理器的前后使用，激活自定义的init方法。</li>
<li>ApplicationContext是对BeanFactory的功能扩展，详见refresh()函数对AC的初始化：</li>
<li>准备刷新上下文环境（准备并验证系统属性或者环境变量），初始化FactoryBean并读取xml，填充FB的功能(如自动注入的注解)，开发者定制的子类覆盖方法(postProcessBeanFactory)执行，FB的后处理器执行，注册拦截bean创建的bean处理器（获取bean时调用），为上下文初始化Message国际化语言源，初始化应用消息广播器并AEM中，留给子类来初始化其他的bean, 在注册的bean中查找监听器bean并注册，初始化剩下的单例，完成刷新过程后，通知生命周期处理器刷新过程，同时发出上下文刷新时间通知其他类。</li>
<li>开发者定制的工厂类后处理方法，为类的创建提供了灵活性。</li>
</ul>
<h2 id="Bean-的创建过程是什么？"><a href="#Bean-的创建过程是什么？" class="headerlink" title="Bean 的创建过程是什么？"></a>Bean 的创建过程是什么？</h2><ul>
<li><p>根据class属性或名称解析类，通过override属性的同名方法个数验证合理性或者标记为没有重载方法，然后进行初始化前的预处理，创建bean.</p>
</li>
<li><p>lookup-method和replace-method两个配置功能的加载就是设置到RootBeanDefinition的methodOverrides属性中。实现原理是在bean实例化时如果检测到存在methodOverrides属性，就会动态地为当前bean生成代理并使用对应的拦截器为bean作增强处理。</p>
</li>
<li><p>实例化的前置处理过程的bean经短路判断非空，则直接返回这个bean，忽略后续bean的创建。AOP功能就是基于这种判断。</p>
</li>
</ul>
<h2 id="如何从bean的实例中获取对象？"><a href="#如何从bean的实例中获取对象？" class="headerlink" title="如何从bean的实例中获取对象？"></a>如何从bean的实例中获取对象？</h2><ul>
<li>加载bean后通过getObjectForBeanInstance方法检测当前bean是否是FactoryBean类型，</li>
<li>是则调用该类型的工厂方法返回真正需要的bean实例，并进行后处理。</li>
</ul>
<h2 id="spring-支持几种-bean-的作用域？"><a href="#spring-支持几种-bean-的作用域？" class="headerlink" title="spring 支持几种 bean 的作用域？"></a>spring 支持几种 bean 的作用域？</h2><ul>
<li>spring 支持 5 种作用域，如下：<ul>
<li>singleton：spring ioc 容器中只存在一个 bean 实例，bean 以单例模式存在，是系统默认值；</li>
<li>prototype：每次从容器调用 bean 时都会创建一个新的示例，既每次 getBean()相当于执行 new Bean()操作；</li>
<li>Web 环境下的作用域：</li>
<li>request：每次 http 请求都会创建一个 bean；</li>
<li>session：同一个 http session 共享一个 bean 实例；</li>
<li>global-session：用于 portlet 容器，因为每个 portlet 有单独的 session，globalsession 提供一个全局性的 http session。</li>
</ul>
</li>
<li>注意： 使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。</li>
</ul>
<h2 id="spring-自动装配-bean-有哪些方式？"><a href="#spring-自动装配-bean-有哪些方式？" class="headerlink" title="spring 自动装配 bean 有哪些方式？"></a>spring 自动装配 bean 有哪些方式？</h2><ul>
<li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li>
<li>byName：它根据 bean 的名称注入对象依赖项。</li>
<li>byType：它根据类型注入对象依赖项。</li>
<li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li>
<li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li>
</ul>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h1><h2 id="spring-事务实现方式有哪些？"><a href="#spring-事务实现方式有哪些？" class="headerlink" title="spring 事务实现方式有哪些？"></a>spring 事务实现方式有哪些？</h2><ul>
<li>声明式事务：声明式事务也有两种实现方式，基于 xml 配置文件的方式和注解方式（在类上添加 @Transaction 注解）。</li>
<li>程序化事务：提供编码的形式管理和维护事务。</li>
</ul>
<h2 id="哪种事务管理类型更可取？"><a href="#哪种事务管理类型更可取？" class="headerlink" title="哪种事务管理类型更可取？"></a>哪种事务管理类型更可取？</h2><ul>
<li>Spring Framework的大多数用户选择声明式事务管理，因为它是对应用程序代码影响最小的选项，因此最符合非侵入式轻量级容器的理想。</li>
<li>声明式事务管理优于程序化事务管理，但它不如程序化事务管理灵活，后者允许您通过代码控制事务。</li>
</ul>
<h2 id="说一下-spring-的事务隔离？"><a href="#说一下-spring-的事务隔离？" class="headerlink" title="说一下 spring 的事务隔离？"></a>说一下 spring 的事务隔离？</h2><ul>
<li><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p>
</li>
<li><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p>
</li>
<li><p>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p>
</li>
<li><p>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p>
</li>
<li><p>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p>
</li>
<li><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>
</li>
<li><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>
</li>
<li><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>
</li>
<li><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>
</li>
</ul>
<h2 id="Spring-Framework的事务管理有哪些好处？"><a href="#Spring-Framework的事务管理有哪些好处？" class="headerlink" title="Spring Framework的事务管理有哪些好处？"></a>Spring Framework的事务管理有哪些好处？</h2><ul>
<li>它在不同的事务API（如JTA，JDBC，Hibernate，JPA和JDO）之间提供了一致的编程模型。 </li>
<li>与许多复杂的事务API（如JTA）相比，它为程序化事务管理提供了更简单的API。 </li>
<li>它支持声明式事务管理。 </li>
<li>它与Spring的各种数据访问抽象集成得非常好。</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="说一下-spring-mvc-运行流程？"><a href="#说一下-spring-mvc-运行流程？" class="headerlink" title="说一下 spring mvc 运行流程？"></a>说一下 spring mvc 运行流程？</h2><ul>
<li>spring mvc 先将请求发送给 DispatcherServlet。</li>
<li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li>
<li>DispatcherServlet 再把请求提交到对应的 Controller。</li>
<li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li>
<li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li>
<li>视图对象负责渲染返回给客户端。</li>
</ul>
<h2 id="spring-mvc-有哪些组件？"><a href="#spring-mvc-有哪些组件？" class="headerlink" title="spring mvc 有哪些组件？"></a>spring mvc 有哪些组件？</h2><ul>
<li>前置控制器 DispatcherServlet。</li>
<li>映射控制器 HandlerMapping。</li>
<li>处理器 Controller。</li>
<li>模型和视图 ModelAndView。</li>
<li>视图解析器 ViewResolver。</li>
</ul>
<h2 id="RequestMapping-的作用是什么？"><a href="#RequestMapping-的作用是什么？" class="headerlink" title="@RequestMapping 的作用是什么？"></a>@RequestMapping 的作用是什么？</h2><ul>
<li>将 http 请求映射到相应的类/方法上。</li>
</ul>
<h2 id="Autowired-的作用是什么？"><a href="#Autowired-的作用是什么？" class="headerlink" title="@Autowired 的作用是什么？"></a>@Autowired 的作用是什么？</h2><ul>
<li>@Autowired 它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，</li>
<li>通过@Autowired 的使用来消除 set/get 方法。</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/09设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/09设计模式/" class="post-title-link" itemprop="url">设计模式</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:19" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:19+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="1-说一下你熟悉的设计模式？"><a href="#1-说一下你熟悉的设计模式？" class="headerlink" title="1. 说一下你熟悉的设计模式？"></a>1. 说一下你熟悉的设计模式？</h2><ul>
<li>根据目的来分可以可以分成3类，创建型、结构型、行为型；<ul>
<li>创建型有5种，工厂方法，抽象工厂，原型，单例，建造者；</li>
<li>结构型有7种，适配器，代理，桥接，装饰，外观，享元，组合；</li>
<li>行为型有11种，模板方法，解释器，策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录；</li>
</ul>
</li>
<li>根据作用范围来分，可以有两类，分别是类模式、对象模式；<ul>
<li>类模式主要有4种，工厂方法，类的适配器，模板方法，解释器；</li>
<li>对象模式有20种，单例，原型，抽象工厂，建造者，代理，对象的适配器，桥接，装饰，外观，享元，组合，策略，命令，责任链，状态，观察者，中介者，迭代器，访问者，备忘录；</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>范围\目的</th>
<th>创建型模式</th>
<th>结构型模式</th>
<th>行为型模式</th>
</tr>
</thead>
<tbody><tr>
<td>类模式</td>
<td>工厂方法</td>
<td>(类）适配器</td>
<td>模板方法、解释器</td>
</tr>
<tr>
<td>对象模式</td>
<td>单例，原型，抽象工厂，建造者</td>
<td>代理，(对象）适配器，桥接，装饰，外观，享元，组合</td>
<td>策略，命令，职责链，状态，观察者，中介者，迭代器，访问，备忘录</td>
</tr>
</tbody></table>
<h2 id="2-简单工厂和抽象工厂有什么区别？"><a href="#2-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2. 简单工厂和抽象工厂有什么区别？"></a>2. 简单工厂和抽象工厂有什么区别？</h2><ul>
<li>简单工厂，可以理解为专门生产某一个产品的工厂；</li>
<li>工厂方法，是生产某一类产品的工厂，是生产具体产品的工厂的父类；</li>
<li>抽象工厂，生产多类产品的工厂；</li>
</ul>
<h2 id="3-设计的基本原则有哪些？"><a href="#3-设计的基本原则有哪些？" class="headerlink" title="3. 设计的基本原则有哪些？"></a>3. 设计的基本原则有哪些？</h2><ul>
<li><p>设置模式的六大原则，开闭原则，里氏代换原则，依赖倒转原则，接口隔离原则，迪米特法则，合成复用原则；</p>
</li>
<li><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果；</p>
</li>
<li><p>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现；</p>
</li>
<li><p>依赖倒转原则，针对接口编程，依赖于抽象而不依赖于具体；</p>
</li>
<li><p>接口隔离原则，使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度；</p>
</li>
<li><p>迪米特法则又称为，最少知道原则，是指一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立；</p>
</li>
<li><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
</li>
</ul>
<h2 id="4-设计模式简介"><a href="#4-设计模式简介" class="headerlink" title="4. 设计模式简介"></a>4. 设计模式简介</h2><ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/08网络/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/08网络/" class="post-title-link" itemprop="url">网络</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:18" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:18+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1-http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1. http 响应码 301 和 302 代表的是什么？有什么区别？"></a>1. http 响应码 301 和 302 代表的是什么？有什么区别？</h2><ul>
<li><p>301：永久重定向。</p>
</li>
<li><p>302：暂时重定向。</p>
</li>
<li><p>它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。</p>
</li>
</ul>
<h2 id="2-forward-和-redirect-的区别？"><a href="#2-forward-和-redirect-的区别？" class="headerlink" title="2. forward 和 redirect 的区别？"></a>2. forward 和 redirect 的区别？</h2><ul>
<li>forward 是转发 和 redirect 是重定向：</li>
<li>地址栏 url 显示：foward url 不会发生改变，redirect url 会发生改变；</li>
<li>数据共享：forward 可以共享 request 里的数据，redirect 不能共享；</li>
<li>效率：forward 比 redirect 效率高。</li>
</ul>
<h2 id="3-简述-tcp-和-udp-的区别？"><a href="#3-简述-tcp-和-udp-的区别？" class="headerlink" title="3. 简述 tcp 和 udp 的区别？"></a>3. 简述 tcp 和 udp 的区别？</h2><ul>
<li><p>tcp 和 udp 是 OSI 模型中的运输层中的协议。tcp 提供可靠的通信传输，而 udp 则常被用于让广播和细节控制交给应用的通信传输。</p>
</li>
<li><p>两者的区别大致如下：</p>
<ul>
<li>tcp 面向连接，udp 面向非连接即发送数据前不需要建立链接；</li>
<li>tcp 提供可靠的服务（数据传输），udp 无法保证；</li>
<li>tcp 面向字节流，udp 面向报文；</li>
<li>tcp 数据传输慢，udp 数据传输快；</li>
</ul>
</li>
</ul>
<h2 id="4-tcp-为什么要三次握手-两次不行吗？为什么？"><a href="#4-tcp-为什么要三次握手-两次不行吗？为什么？" class="headerlink" title="4. tcp 为什么要三次握手,两次不行吗？为什么？"></a>4. tcp 为什么要三次握手,两次不行吗？为什么？</h2><ul>
<li>如果采用两次握手，<ul>
<li>那么只要服务器发出确认数据包就会建立连接，</li>
<li>但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，</li>
<li>这样服务器端就白白浪费了一定的资源。</li>
</ul>
</li>
<li>若采用三次握手，<ul>
<li>服务器端没有收到来自客户端的再此确认，</li>
<li>则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-tcp-粘包是怎么产生的？"><a href="#5-说一下-tcp-粘包是怎么产生的？" class="headerlink" title="5. 说一下 tcp 粘包是怎么产生的？"></a>5. 说一下 tcp 粘包是怎么产生的？</h2><ul>
<li>tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：<ul>
<li>发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；</li>
<li>接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。</li>
</ul>
</li>
</ul>
<h2 id="6-OSI-的七层模型都有哪些？"><a href="#6-OSI-的七层模型都有哪些？" class="headerlink" title="6. OSI 的七层模型都有哪些？"></a>6. OSI 的七层模型都有哪些？</h2><ul>
<li>物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</li>
<li>数据链路层：负责建立和管理节点间的链路。</li>
<li>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。</li>
<li>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。</li>
<li>会话层：向两个实体的表示层提供建立和使用连接的方法。</li>
<li>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密等。</li>
<li>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。</li>
</ul>
<h2 id="7-get-和-post-请求有哪些区别？"><a href="#7-get-和-post-请求有哪些区别？" class="headerlink" title="7. get 和 post 请求有哪些区别？"></a>7. get 和 post 请求有哪些区别？</h2><ul>
<li>get 请求会被浏览器主动缓存，而 post 不会。</li>
<li>get 传递参数有大小限制，而 post 没有。</li>
<li>post 参数传输更安全，get 的参数会明文限制在 url 上，post 不会。</li>
</ul>
<h2 id="8-如何实现跨域？"><a href="#8-如何实现跨域？" class="headerlink" title="8. 如何实现跨域？"></a>8. 如何实现跨域？</h2><ul>
<li>服务器端运行跨域 设置 CORS 等于 *；</li>
<li>在单个接口使用注解 @CrossOrigin 运行跨域；</li>
<li>使用 jsonp 跨域；</li>
</ul>
<h2 id="9-说一下-JSONP-实现原理？"><a href="#9-说一下-JSONP-实现原理？" class="headerlink" title="9. 说一下 JSONP 实现原理？"></a>9. 说一下 JSONP 实现原理？</h2><ul>
<li>jsonp：JSON with Padding，</li>
<li>它是利用script标签的 src 连接可以访问不同源的特性，加载远程返回的“JS 函数”来执行的。</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/07异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/07异常/" class="post-title-link" itemprop="url">异常</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:17" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:17+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><blockquote>
<p>Java 的异常处理是通过 5 个关键字来实现的：try，catch，throw，throws，finally。</p>
</blockquote>
<h2 id="1-throw-和-throws-的区别？"><a href="#1-throw-和-throws-的区别？" class="headerlink" title="1. throw 和 throws 的区别？"></a>1. throw 和 throws 的区别？</h2><ul>
<li>throw：是真实抛出一个异常。</li>
<li>throws：是声明可能会抛出一个异常。</li>
</ul>
<h2 id="2-final、finally、finalize-有什么区别？"><a href="#2-final、finally、finalize-有什么区别？" class="headerlink" title="2. final、finally、finalize 有什么区别？"></a>2. final、finally、finalize 有什么区别？</h2><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能在被改变，只能使用。</li>
<li>finally：是 try{} catch{} finally{} 最后一部分，表示不论发生任何情况都会执行，finally 部分可以省略，但如果 finally 部分存在，则一定会执行 finally 里面的代码。</li>
<li>finalize： 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法。</li>
</ul>
<h2 id="3-try-catch-finally-中哪个部分可以省略？"><a href="#3-try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3. try-catch-finally 中哪个部分可以省略？"></a>3. try-catch-finally 中哪个部分可以省略？</h2><ul>
<li>try-catch-finally 其中 catch 和 finally 都可以被省略，但是不能同时省略，</li>
<li>也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。</li>
</ul>
<h2 id="4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？"><a href="#4-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗？" class="headerlink" title="4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？"></a>4. try-catch-finally 中,如果 catch 中 return 了,finally 还会执行吗？</h2><ul>
<li>finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。</li>
</ul>
<h2 id="5-常见的异常类有哪些？"><a href="#5-常见的异常类有哪些？" class="headerlink" title="5. 常见的异常类有哪些？"></a>5. 常见的异常类有哪些？</h2><ul>
<li>NullPointerException 空指针异常</li>
<li>ClassNotFoundException 指定类不存在</li>
<li>NumberFormatException 字符串转换为数字异常</li>
<li>IndexOutOfBoundsException 数组下标越界异常</li>
<li>ClassCastException 数据类型转换异常</li>
<li>FileNotFoundException 文件未找到异常</li>
<li>NoSuchMethodException 方法不存在异常</li>
<li>IOException IO 异常</li>
<li>SocketException Socket 异常</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/06JavaWeb模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/06JavaWeb模块/" class="post-title-link" itemprop="url">Java Web</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:16" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:16+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><!-- TOC -->

<ul>
<li><a href="#java-web">Java Web</a><ul>
<li><a href="#1-jsp-和-servlet-有什么区别">1. jsp 和 servlet 有什么区别？</a></li>
<li><a href="#2-jsp-有哪些内置对象作用分别是什么">2. jsp 有哪些内置对象？作用分别是什么？</a></li>
<li><a href="#3-说一下-jsp-的-4-种作用域">3. 说一下 jsp 的 4 种作用域？</a></li>
<li><a href="#4-session-和-cookie-有什么区别">4. session 和 cookie 有什么区别？</a></li>
<li><a href="#5-说一下-session-的工作原理">5. 说一下 session 的工作原理？</a></li>
<li><a href="#6-如果客户端禁止-cookie-能实现-session-还能用吗">6. 如果客户端禁止 cookie 能实现 session 还能用吗？</a></li>
<li><a href="#7-spring-mvc-和-struts-的区别是什么">7. spring mvc 和 struts 的区别是什么？</a></li>
<li><a href="#8-如何避免-sql-注入">8. 如何避免 sql 注入？</a></li>
<li><a href="#9-什么是-xss-攻击如何避免">9. 什么是 XSS 攻击,如何避免？</a></li>
<li><a href="#10-什么是-csrf-攻击如何避免">10. 什么是 CSRF 攻击,如何避免？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="1-jsp-和-servlet-有什么区别？"><a href="#1-jsp-和-servlet-有什么区别？" class="headerlink" title="1. jsp 和 servlet 有什么区别？"></a>1. jsp 和 servlet 有什么区别？</h2><h2 id="2-jsp-有哪些内置对象？作用分别是什么？"><a href="#2-jsp-有哪些内置对象？作用分别是什么？" class="headerlink" title="2. jsp 有哪些内置对象？作用分别是什么？"></a>2. jsp 有哪些内置对象？作用分别是什么？</h2><h2 id="3-说一下-jsp-的-4-种作用域？"><a href="#3-说一下-jsp-的-4-种作用域？" class="headerlink" title="3. 说一下 jsp 的 4 种作用域？"></a>3. 说一下 jsp 的 4 种作用域？</h2><h2 id="4-session-和-cookie-有什么区别？"><a href="#4-session-和-cookie-有什么区别？" class="headerlink" title="4. session 和 cookie 有什么区别？"></a>4. session 和 cookie 有什么区别？</h2><h2 id="5-说一下-session-的工作原理？"><a href="#5-说一下-session-的工作原理？" class="headerlink" title="5. 说一下 session 的工作原理？"></a>5. 说一下 session 的工作原理？</h2><h2 id="6-如果客户端禁止-cookie-能实现-session-还能用吗？"><a href="#6-如果客户端禁止-cookie-能实现-session-还能用吗？" class="headerlink" title="6. 如果客户端禁止 cookie 能实现 session 还能用吗？"></a>6. 如果客户端禁止 cookie 能实现 session 还能用吗？</h2><h2 id="7-spring-mvc-和-struts-的区别是什么？"><a href="#7-spring-mvc-和-struts-的区别是什么？" class="headerlink" title="7. spring mvc 和 struts 的区别是什么？"></a>7. spring mvc 和 struts 的区别是什么？</h2><h2 id="8-如何避免-sql-注入？"><a href="#8-如何避免-sql-注入？" class="headerlink" title="8. 如何避免 sql 注入？"></a>8. 如何避免 sql 注入？</h2><h2 id="9-什么是-XSS-攻击-如何避免？"><a href="#9-什么是-XSS-攻击-如何避免？" class="headerlink" title="9. 什么是 XSS 攻击,如何避免？"></a>9. 什么是 XSS 攻击,如何避免？</h2><h2 id="10-什么是-CSRF-攻击-如何避免？"><a href="#10-什么是-CSRF-攻击-如何避免？" class="headerlink" title="10. 什么是 CSRF 攻击,如何避免？"></a>10. 什么是 CSRF 攻击,如何避免？</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/05对象拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/05对象拷贝/" class="post-title-link" itemprop="url">对象拷贝</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:15" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:15+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h1><p><a href="https://www.cnblogs.com/Qian123/p/5710533.html" target="_blank" rel="noopener">link</a></p>
<!-- TOC -->

<ul>
<li><a href="#对象拷贝">对象拷贝</a><ul>
<li><a href="#1-为什么要使用克隆">1. 为什么要使用克隆？</a></li>
<li><a href="#2-如何实现对象克隆">2. 如何实现对象克隆？</a></li>
<li><a href="#3-深拷贝和浅拷贝区别是什么">3. 深拷贝和浅拷贝区别是什么？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="1-为什么要使用克隆？"><a href="#1-为什么要使用克隆？" class="headerlink" title="1. 为什么要使用克隆？"></a>1. 为什么要使用克隆？</h2><p>克隆的对象可能包含一些已经修改过的属性，而 new 出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠 clone 方法了</p>
<h2 id="2-如何实现对象克隆？"><a href="#2-如何实现对象克隆？" class="headerlink" title="2. 如何实现对象克隆？"></a>2. 如何实现对象克隆？</h2><p><strong>浅克隆(ShallowClone)</strong>和<strong>深克隆(DeepClone)</strong></p>
<h2 id="3-深拷贝和浅拷贝区别是什么？"><a href="#3-深拷贝和浅拷贝区别是什么？" class="headerlink" title="3. 深拷贝和浅拷贝区别是什么？"></a>3. 深拷贝和浅拷贝区别是什么？</h2><ul>
<li>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。(在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。)</li>
<li>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。(在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。)</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/04反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/04反射/" class="post-title-link" itemprop="url">反射</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:14" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:14+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><!-- TOC -->

<ul>
<li><a href="#反射">反射</a><ul>
<li><a href="#1-什么是反射">1. 什么是反射？</a></li>
<li><a href="#2-什么是-java-序列化什么情况下需要序列化">2. 什么是 java 序列化？什么情况下需要序列化？</a></li>
<li><a href="#3-动态代理是什么有哪些应用">3. 动态代理是什么？有哪些应用？</a></li>
<li><a href="#4-怎么实现动态代理">4. 怎么实现动态代理？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="1-什么是反射？"><a href="#1-什么是反射？" class="headerlink" title="1. 什么是反射？"></a>1. 什么是反射？</h2><p><a href="<https://www.zhihu.com/question/24304289>">link</a></p>
<p><img src="..%5Cpic%5Cjava%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.jpg" alt="java的运行流程.jpg"></p>
<p><strong><a href="[https://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F](https://www.sczyh30.com/posts/Java/java-reflection-1/#一、回顾：什么是反射？)">深入解析 Java 反射（1） - 基础</a></strong></p>
<ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
</ul>
<h2 id="2-什么是-java-序列化？什么情况下需要序列化？"><a href="#2-什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="2. 什么是 java 序列化？什么情况下需要序列化？"></a>2. 什么是 java 序列化？什么情况下需要序列化？</h2><p><a href="https://blog.csdn.net/fan2012huan/article/details/49871163" target="_blank" rel="noopener">link</a></p>
<ul>
<li><p>序列化简单来说就<strong>保存对象在内存中的状态</strong>也可以说是<strong>实例化变量</strong>。这是 Java 提供的用来<strong>保存 Object state</strong>，一种保存对象状态的机制。只有实现了 serializable 接口的类的对象才能被实例化。</p>
<ul>
<li>1 当你想把内存中的对象写入到硬盘时</li>
<li>2 当你想用套接字在网络上传输对象时</li>
<li>3 当你想通过 RMI 调用对象时</li>
</ul>
<p>​ （RMI 是什么东西？）：RMI 总结来说就是远程调用对象，在一个 jvm 上调用另一个 jvm 的对象。</p>
</li>
</ul>
<h2 id="3-动态代理是什么？有哪些应用？"><a href="#3-动态代理是什么？有哪些应用？" class="headerlink" title="3. 动态代理是什么？有哪些应用？"></a>3. 动态代理是什么？有哪些应用？</h2><h2 id="4-怎么实现动态代理？"><a href="#4-怎么实现动态代理？" class="headerlink" title="4. 怎么实现动态代理？"></a>4. 怎么实现动态代理？</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/03多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/03多线程/" class="post-title-link" itemprop="url">多线程</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:13" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:13+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><!-- TOC -->

<ul>
<li><a href="#多线程">多线程</a><ul>
<li><a href="#1-并行和并发有什么区别">1. 并行和并发有什么区别？</a></li>
<li><a href="#2-线程和进程的区别">2. 线程和进程的区别？</a></li>
<li><a href="#3-守护线程是什么">3. 守护线程是什么？</a></li>
<li><a href="#4-创建线程有哪几种方式">4. 创建线程有哪几种方式？</a></li>
<li><a href="#5-说一下-runnable-和-callable-有什么区别">5. 说一下 runnable 和 callable 有什么区别？</a></li>
<li><a href="#6-线程有哪些状态">6. 线程有哪些状态？</a></li>
<li><a href="#7-sleep-和-wait-有什么区别">7. sleep() 和 wait() 有什么区别？</a></li>
<li><a href="#8-notify和-notifyall有什么区别">8. notify()和 notifyAll()有什么区别？</a></li>
<li><a href="#9-线程的-run和-start有什么区别">9. 线程的 run()和 start()有什么区别？</a></li>
<li><a href="#10-创建线程池有哪几种方式">10. 创建线程池有哪几种方式？</a></li>
<li><a href="#11-线程池都有哪些状态">11. 线程池都有哪些状态？</a></li>
<li><a href="#12-线程池中-submit和-execute方法有什么区别">12. 线程池中 submit()和 execute()方法有什么区别？</a></li>
<li><a href="#13-在-java-程序中怎么保证多线程的运行安全">13. 在 java 程序中怎么保证多线程的运行安全？</a></li>
<li><a href="#14-多线程锁的升级原理是什么">14. 多线程锁的升级原理是什么？</a></li>
<li><a href="#15-什么是死锁">15. 什么是死锁？</a></li>
<li><a href="#16-怎么防止死锁">16. 怎么防止死锁？</a></li>
<li><a href="#17-threadlocal-是什么有哪些使用场景">17. ThreadLocal 是什么？有哪些使用场景？</a></li>
<li><a href="#18-说一下-synchronized-底层实现原理">18. 说一下 synchronized 底层实现原理？</a></li>
<li><a href="#19-synchronized-和-volatile-的区别是什么">19. synchronized 和 volatile 的区别是什么？</a></li>
<li><a href="#20-synchronized-和-lock-有什么区别">20. synchronized 和 Lock 有什么区别？</a></li>
<li><a href="#21-synchronized-和-reentrantlock-区别是什么">21. synchronized 和 ReentrantLock 区别是什么？</a></li>
<li><a href="#22-说一下-atomic-的原理">22. 说一下 atomic 的原理？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="1-并行和并发有什么区别？"><a href="#1-并行和并发有什么区别？" class="headerlink" title="1. 并行和并发有什么区别？"></a>1. 并行和并发有什么区别？</h2><ul>
<li><p>并发:一个处理器同时处理多个任务；</p>
</li>
<li><p>并行:多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
</ul>
<blockquote>
<p>前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生</p>
</blockquote>
<h2 id="2-线程和进程的区别？"><a href="#2-线程和进程的区别？" class="headerlink" title="2. 线程和进程的区别？"></a>2. 线程和进程的区别？</h2><ul>
<li>操作系统都支持运行多个任务，通常一个任务就是一个程序，而一个程序就是一个进程。当一个进程运行时，内部可能包括多个顺序执行流，每个顺序执行流就是一个线程。</li>
<li>进程是指处于运行过程中的程序，并且具有一定的独立功能。进程是系统进行资源分配和调度的一个单位。当程序进入内存运行时，即为线程。</li>
<li>进程代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。</li>
<li>一个进程可以包括多个线程。</li>
<li><strong>进程和线程都是一个时间段的描述，是 CPU 工作时间段的描述，不过是颗粒大小不同。</strong></li>
</ul>
<h2 id="3-守护线程是什么？"><a href="#3-守护线程是什么？" class="headerlink" title="3. 守护线程是什么？"></a>3. 守护线程是什么？</h2><ul>
<li>在 Java 中有三类线程：主线程、User Thread(用户线程)、Daemon Thread(守护线程)；</li>
<li>守护线程指程序运行的时候在后台提供一种通用服务的线程，比如gc；</li>
<li>主线程和守护线程一起销毁，与用户线程互不影响。</li>
</ul>
<h2 id="4-创建线程有哪几种方式？"><a href="#4-创建线程有哪几种方式？" class="headerlink" title="4. 创建线程有哪几种方式？"></a>4. 创建线程有哪几种方式？</h2><ul>
<li><p>三种：继承 Thread 类创建线程类/通过 Runnable 接口创建线程类/通过 Callable 和 Future 创建线程</p>
</li>
<li><p>一、继承Thread类创建线程类</p>
<ol>
<li>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>二、通过Runnable接口创建线程类</p>
<ol>
<li>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li>
<li>调用线程对象的start()方法来启动该线程。</li>
</ol>
</li>
<li><p>三、通过Callable和Future创建线程</p>
<ol>
<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>
<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</li>
<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>
<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</li>
</ol>
</li>
<li><p>采用实现 Runnable、Callable 接口的方式创建多线程时</p>
<ul>
<li>优势是：线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个 target 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</li>
<li>劣势是：编程稍微复杂，如果要访问当前线程，则必须使用 Thread.currentThread()方法</li>
</ul>
</li>
<li><p>使用继承 Thread 类的方式创建多线程时</p>
<ul>
<li>优势是：编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread()方法，直接使用 this 即可获得当前线程。</li>
<li>劣势是：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
</ul>
<h2 id="5-说一下-runnable-和-callable-有什么区别？"><a href="#5-说一下-runnable-和-callable-有什么区别？" class="headerlink" title="5. 说一下 runnable 和 callable 有什么区别？"></a>5. 说一下 runnable 和 callable 有什么区别？</h2><ul>
<li>Callable 规定的方法是 call(), Runnable 规定的方法是 run()</li>
<li>Callable 的任务执行后可返回值，而 Runnable 的任务是不能返回值</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
<li>加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法。<br>Callable 接口也是位于 java.util.concurrent 包中。</li>
</ul>
<h2 id="6-线程有哪些状态？"><a href="#6-线程有哪些状态？" class="headerlink" title="6. 线程有哪些状态？"></a>6. 线程有哪些状态？</h2><p>在 Java 当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ul>
<li>第一是创建状态。在生成线程对象，并没有调用该对象的 start 方法，这是线程处于创建状态；</li>
<li>第二是就绪状态。当调用了线程对象的 start 方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态</li>
<li>第三是运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run 函数当中的代码。</li>
<li>第四是阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生（比如说某项资源就绪）之后再继续运行。sleep,suspend 等方法都可以导致线程阻塞。</li>
<li>第五是死亡状态。如果一个线程的 run 方法执行结束，该线程就会死亡。对于已经死亡的线程，无法再使用 start 方法令其进入就绪状态。</li>
</ul>
<h2 id="7-sleep-和-wait-有什么区别？"><a href="#7-sleep-和-wait-有什么区别？" class="headerlink" title="7. sleep() 和 wait() 有什么区别？"></a>7. sleep() 和 wait() 有什么区别？</h2><ul>
<li>sleep 是 Thread 类的方法,wait 是 Object 类中定义的方法。</li>
<li>Thread.sleep 不会导致锁行为的改变，如果当前线程是拥有锁的，那么 Thread.sleep 不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在 Object 类中，因此调用 Thread.sleep 是不会影响锁的相关行为。</li>
<li>Thread.sleep 和 Object.wait 都会暂停当前的线程，对于 CPU 资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要 CPU 的执行时间。OS 会将执行时间分配给其它线程。区别是，调用 wait 后，需要别的线程执行 notify/notifyAll 才能够重新获得 CPU 执行时间。</li>
</ul>
<h2 id="8-notify-和-notifyAll-有什么区别？"><a href="#8-notify-和-notifyAll-有什么区别？" class="headerlink" title="8. notify()和 notifyAll()有什么区别？"></a>8. notify()和 notifyAll()有什么区别？</h2><ul>
<li>唤醒线程，是将线程由等待池移动到锁池，</li>
<li>notifyAll 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。</li>
<li>notify 只会唤醒一个线程。</li>
</ul>
<h2 id="9-线程的-run-和-start-有什么区别？"><a href="#9-线程的-run-和-start-有什么区别？" class="headerlink" title="9. 线程的 run()和 start()有什么区别？"></a>9. 线程的 run()和 start()有什么区别？</h2><ol>
<li>start() 是启动一个新线程执行 run 代码，run() 是当前线程执行 run 代码；</li>
<li>start() 不能被重复调用，run() 可以</li>
<li>start() 中的 run 代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用 run() 必须等待其代码全部执行完才能继续执行下面的代码。</li>
<li>start() 实现了多线程，run() 没有实现多线程。</li>
</ol>
<h2 id="10-创建线程池有哪几种方式？"><a href="#10-创建线程池有哪几种方式？" class="headerlink" title="10. 创建线程池有哪几种方式？"></a>10. 创建线程池有哪几种方式？</h2><ol>
<li>使用 ThreadPoolExecutor 的构造方法</li>
<li>Executors.newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li>
<li>Executors.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>Executors.newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执</li>
<li>Executors.newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</li>
</ol>
<h2 id="11-线程池都有哪些状态？"><a href="#11-线程池都有哪些状态？" class="headerlink" title="11. 线程池都有哪些状态？"></a>11. 线程池都有哪些状态？</h2><p><img src="..%5Cpic%5C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="线程池的状态.jpg"></p>
<p>1、RUNNING<br>(1) 状态说明：线程池处在 RUNNING 状态时，能够接收新任务，以及对已添加的任务进行处理。<br>(2) 状态切换：线程池的初始化状态是 RUNNING。换句话说，线程池被一旦被创建，就处于 RUNNING 状态，并且线程池中的任务数为 0！</p>
<p>2、 SHUTDOWN<br>(1) 状态说明：线程池处在 SHUTDOWN 状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的 shutdown()接口时，线程池由 RUNNING -&gt; SHUTDOWN。</p>
<p>3、STOP<br>(1) 状态说明：线程池处在 STOP 状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。<br>(2) 状态切换：调用线程池的 shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p>4、TIDYING<br>(1) 状态说明：当所有的任务已终止，ctl 记录的”任务数量”为 0，线程池会变为 TIDYING 状态。当线程池变为 TIDYING 状态时，会执行钩子函数 terminated()。terminated()在 ThreadPoolExecutor 类中是空的，若用户想在线程池变为 TIDYING 时，进行相应的处理；可以通过重载 terminated()函数来实现。<br>(2) 状态切换：当线程池在 SHUTDOWN 状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -&gt; TIDYING。<br>当线程池在 STOP 状态下，线程池中执行的任务为空时，就会由 STOP -&gt; TIDYING。</p>
<p>5、 TERMINATED<br>(1) 状态说明：线程池彻底终止，就变成 TERMINATED 状态。<br>(2) 状态切换：线程池处在 TIDYING 状态时，执行完 terminated()之后，就会由 TIDYING -&gt; TERMINATED。</p>
<h2 id="12-线程池中-submit-和-execute-方法有什么区别？"><a href="#12-线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="12. 线程池中 submit()和 execute()方法有什么区别？"></a>12. 线程池中 submit()和 execute()方法有什么区别？</h2><ul>
<li><p>execute 提交的方式只能提交一个 Runnable 的对象，且该方法的返回值是 void，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过 ThreadFactory 主动设置线程的异常处理类才能感知到提交的线程中的异常信息。</p>
</li>
<li><p>submit 提交的方式</p>
</li>
<li><p><t> Future<t> submit(Callable<t> task);而 Callable 接口中是一个有返回值的 call 方法。如果在线程的执行过程中发生了异常，get 会获取到异常的信息。</t></t></t></p>
</li>
<li><p>Future&lt;?&gt; submit(Runnable task);也可以提交一个 Runable 接口的对象，这样当调用 get 方法的时候，如果线程执行成功会直接返回 null，如果线程执行异常会返回异常的信息</p>
</li>
<li><p><t> Future<t> submit(Runnable task, T result);除了 task 之外还有一个 result 对象，</t></t></p>
<p>当线程正常结束的时候调用 Future 的 get 方法会返回 result 对象，当线程抛出异常的时候会获取到对应的异常的信息。</p>
</li>
</ul>
<h2 id="13-在-java-程序中怎么保证多线程的运行安全？"><a href="#13-在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="13. 在 java 程序中怎么保证多线程的运行安全？"></a>13. 在 java 程序中怎么保证多线程的运行安全？</h2><ol>
<li>使用安全类，比如 Java. util. concurrent 下的类;</li>
<li>使用自动锁 synchronized;</li>
<li>使用手动锁 Lock.</li>
</ol>
<p>1、互斥同步<br>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。而互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。<br>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。<br>此外，ReentrantLock也是通过互斥来实现同步。在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性。<br>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p>
<p>2、非阻塞同步<br>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。<br>非阻塞的实现CAS（CompareAndSwap）：CAS指令需要有3个操作数，分别是内存地址（在java中理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，CAS指令指令时，当且仅当V处的值符合旧预期值A时，处理器用B更新V处的值，否则它就不执行更新，但是无论是否更新了V处的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p>
<p>CAS缺点：<br>ABA问题：因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。<br>ABA问题的解决思路就是使用版本号。在变量前面追加版本号，每次变量更新的时候把版本号加一，那么A-B-A就变成了1A-2B-3C。JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<p>3、无需同步方案<br>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无需任何同步操作去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<p>1）可重入代码<br>可重入代码（ReentrantCode）也称为纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。所有的可重入代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。<br>可重入代码的特点是不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是由参数中传入、不调用 非可重入的方法等。<br>（类比：synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁）</p>
<p>2）线程本地存储 ThreadLocal<br>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内。这样无需同步也能保证线程之间不出现数据的争用问题。<br>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典的Web交互模型中的“一个请求对应一个服务器线程（Thread-per-Request）”的处理方式，这种处理方式的广泛应用使得很多Web服务器应用都可以使用线程本地存储来解决线程安全问题。</p>
<h2 id="14-多线程锁的升级原理是什么？"><a href="#14-多线程锁的升级原理是什么？" class="headerlink" title="14. 多线程锁的升级原理是什么？"></a>14. 多线程锁的升级原理是什么？</h2><h2 id="15-什么是死锁？"><a href="#15-什么是死锁？" class="headerlink" title="15. 什么是死锁？"></a>15. 什么是死锁？</h2><p>如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。<br>举例来说：有两个进程A和B,A持有资源a等待b资源，B持有资源b等待a资源，两个进程都在等待另一个资源的同时不释放资源，就形成死锁。<br>死锁的发生必须具备以下四个必要条件。</p>
<p>1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p>
<p>2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p>
<p>3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p>4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p>
<h2 id="16-怎么防止死锁？"><a href="#16-怎么防止死锁？" class="headerlink" title="16. 怎么防止死锁？"></a>16. 怎么防止死锁？</h2><blockquote>
<p>处理死锁的思路如下：</p>
</blockquote>
<p>预防死锁：<br>破坏四个必要件中的一个或多个来预防死锁</p>
<p>避免死锁：<br>在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。</p>
<p>检测死锁：<br>运行时产生死锁，及时发现思索，将程序解脱出来。</p>
<p>解除死锁：<br>发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程</p>
<blockquote>
<p>预防死锁的办法：</p>
</blockquote>
<p>破坏请求和保持条件：</p>
<ol>
<li>一次性的申请所有资源。之后不在申请资源，如果不满足资源条件则得不到资源分配。</li>
<li>只获得初期资源运行，之后将运行完的资源释放，请求新的资源。</li>
</ol>
<blockquote>
<p>破坏不可抢占条件：</p>
</blockquote>
<p>当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。</p>
<blockquote>
<p>死锁的解除办法：</p>
<ol>
<li>抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。</li>
<li>终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。</li>
</ol>
</blockquote>
<h2 id="17-ThreadLocal-是什么？有哪些使用场景？"><a href="#17-ThreadLocal-是什么？有哪些使用场景？" class="headerlink" title="17. ThreadLocal 是什么？有哪些使用场景？"></a>17. ThreadLocal 是什么？有哪些使用场景？</h2><h2 id="18-说一下-synchronized-底层实现原理？"><a href="#18-说一下-synchronized-底层实现原理？" class="headerlink" title="18. 说一下 synchronized 底层实现原理？"></a>18. 说一下 synchronized 底层实现原理？</h2><h2 id="19-synchronized-和-volatile-的区别是什么？"><a href="#19-synchronized-和-volatile-的区别是什么？" class="headerlink" title="19. synchronized 和 volatile 的区别是什么？"></a>19. synchronized 和 volatile 的区别是什么？</h2><h2 id="20-synchronized-和-Lock-有什么区别？"><a href="#20-synchronized-和-Lock-有什么区别？" class="headerlink" title="20. synchronized 和 Lock 有什么区别？"></a>20. synchronized 和 Lock 有什么区别？</h2><ul>
<li><p>synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p>
</li>
<li><p>Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p>
</li>
</ul>
<blockquote>
<p>synchronized和Lock比较</p>
</blockquote>
<ul>
<li>synchronized是关键字，内置语言实现，Lock是接口。</li>
<li>synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</li>
<li>Lock是可以中断锁，synchronized是非中断锁，必须等待线程执行完成释放锁。</li>
<li>Lock可以使用读锁提高多线程读效率。</li>
</ul>
<h2 id="21-synchronized-和-ReentrantLock-区别是什么？"><a href="#21-synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="21. synchronized 和 ReentrantLock 区别是什么？"></a>21. synchronized 和 ReentrantLock 区别是什么？</h2><blockquote>
<p>两者的共同点：</p>
</blockquote>
<p>1）协调多线程对共享对象、变量的访问</p>
<p>2）可重入，同一线程可以多次获得同一个锁</p>
<p>3）都保证了可见性和互斥性</p>
<blockquote>
<p>两者的不同点：</p>
</blockquote>
<p>1）ReentrantLock显示获得、释放锁，synchronized隐式获得释放锁</p>
<p>2）ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性</p>
<p>3）ReentrantLock是API级别的，synchronized是JVM级别的</p>
<p>4）ReentrantLock可以实现公平锁</p>
<p>5）ReentrantLock通过Condition可以绑定多个条件</p>
<p>6）底层实现不一样 synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略</p>
<h2 id="22-说一下-atomic-的原理？"><a href="#22-说一下-atomic-的原理？" class="headerlink" title="22. 说一下 atomic 的原理？"></a>22. 说一下 atomic 的原理？</h2>
        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sometwo7.github.io/blog/blog/2019/10/04/02容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Sometwo">
      <meta itemprop="description" content="一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="佚名">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
            
            <a href="/blog/2019/10/04/02容器/" class="post-title-link" itemprop="url">容器</a>
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-04 19:49:12" itemprop="dateCreated datePublished" datetime="2019-10-04T19:49:12+00:00">2019-10-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 09:11:16" itemprop="dateModified" datetime="2019-10-29T09:11:16+00:00">2019-10-29</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/Java学习/" itemprop="url" rel="index"><span itemprop="name">Java学习</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul>
<li><a href="https://blog.csdn.net/dengpeng0419/article/details/47983033" target="_blank" rel="noopener">链接</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java-collection/hashmap.html" target="_blank" rel="noopener">极客学院的 java 集合</a></li>
</ul>
<!-- TOC -->

<ul>
<li><a href="#容器">容器</a><ul>
<li><a href="#1-java-容器都有哪些">1. java 容器都有哪些？</a></li>
<li><a href="#2-collection-和-collections-有什么区别">2. Collection 和 Collections 有什么区别？</a></li>
<li><a href="#3-listsetmap-之间的区别是什么">3. List、Set、Map 之间的区别是什么？</a></li>
<li><a href="#4-hashmap-和-hashtable-有什么区别">4. HashMap 和 Hashtable 有什么区别？</a></li>
<li><a href="#5-如何决定使用-hashmap-还是-treemap">5. 如何决定使用 HashMap 还是 TreeMap？</a></li>
<li><a href="#6-说一下-hashmap-的实现原理">6. 说一下 HashMap 的实现原理？</a></li>
<li><a href="#7-说一下-hashset-的实现原理">7. 说一下 HashSet 的实现原理？</a></li>
<li><a href="#8-arraylist-和-linkedlist-的区别是什么">8. ArrayList 和 LinkedList 的区别是什么？</a></li>
<li><a href="#9-如何实现数组和-list-之间的转换">9. 如何实现数组和 List 之间的转换？</a></li>
<li><a href="#10-arraylist-和-vector-的区别是什么">10. ArrayList 和 Vector 的区别是什么？</a></li>
<li><a href="#11-array-和-arraylist-有何区别">11. Array 和 ArrayList 有何区别？</a></li>
<li><a href="#12-在-queue-中-poll和-remove有什么区别">12. 在 Queue 中 poll()和 remove()有什么区别？</a></li>
<li><a href="#13-哪些集合类是线程安全的">13. 哪些集合类是线程安全的？</a></li>
<li><a href="#14-迭代器-iterator-是什么">14. 迭代器 Iterator 是什么？</a></li>
<li><a href="#15-iterator-怎么使用有什么特点">15. Iterator 怎么使用？有什么特点？</a></li>
<li><a href="#16-iterator-和-listiterator-有什么区别">16. Iterator 和 ListIterator 有什么区别？</a></li>
<li><a href="#17-怎么确保一个集合不能被修改">17. 怎么确保一个集合不能被修改？</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h2 id="1-java-容器都有哪些？"><a href="#1-java-容器都有哪些？" class="headerlink" title="1. java 容器都有哪些？"></a>1. java 容器都有哪些？</h2><blockquote>
<p>Java 容器类类库的用途是“持有对象”，并将其划分为两个不同的概念：</p>
<p>1）Collection集合接口，<br>List 必须按照插入的顺序保存元素，<br>Set 不能有重复的元素。<br>Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）。</p>
<p>2）Map是用来存储成对的“键值”组合容器，允许你使用键来查找值。</p>
</blockquote>
<pre><code>├Collection
│├List
││├LinkedList
││├ArrayList
││└Vector
││ └Stack
│└Set
│ ├HashSet
│ ├TreeSet
│ └LinkedSet
│
└Map
 ├Hashtable
 ├HashMap
 └WeakHashMap</code></pre><h2 id="2-Collection-和-Collections-有什么区别？"><a href="#2-Collection-和-Collections-有什么区别？" class="headerlink" title="2. Collection 和 Collections 有什么区别？"></a>2. Collection 和 Collections 有什么区别？</h2><ol>
<li>java.util.Collection 是一个集合接口。<ul>
<li>提供了对集合对象进行基本操作的通用接口方法。</li>
<li>Collection 接口在 Java 类库中有很多具体的实现。</li>
<li>Collection 接口的意义是为各种具体的集合提供了最大化的统一操作方式。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Collection</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├List</span><br><span class="line">│├LinkedList</span><br><span class="line">│├ArrayList</span><br><span class="line">│└Vector</span><br><span class="line">│　└Stack</span><br><span class="line">└Set</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>java.util.Collections 是一个包装类。<ul>
<li>包含有各种有关集合操作的静态多态方法。</li>
<li>此类不能实例化，就像一个工具类，服务于 Java 的 Collection 框架。</li>
</ul>
</li>
</ol>
<h2 id="3-List、Set、Map-之间的区别是什么？"><a href="#3-List、Set、Map-之间的区别是什么？" class="headerlink" title="3. List、Set、Map 之间的区别是什么？"></a>3. List、Set、Map 之间的区别是什么？</h2><table>
<thead>
<tr>
<th>比较</th>
<th align="center">List</th>
<th align="center">Set</th>
<th align="center">Map</th>
</tr>
</thead>
<tbody><tr>
<td>接口</td>
<td align="center">collection</td>
<td align="center">collection</td>
<td align="center"></td>
</tr>
<tr>
<td>常见实现类</td>
<td align="center">AbstractList(其常用子类有 ArrayList、LinkedList、Vector)</td>
<td align="center">AbstractSet(其常用子类有 HashSet、LinkedHashSet、TreeSet)</td>
<td align="center">HashMap、HashTable、TreeMap</td>
</tr>
<tr>
<td>常见方法</td>
<td align="center">add( )、remove( )、clear( )、get( )、contains( )、size( )</td>
<td align="center">add( )、remove( )、clear( )、contains( )、size( )</td>
<td align="center">put( )、get( )、remove( )、clear( )、containsKey( )、containsValue( )、keySet( )、values( )、size( )</td>
</tr>
<tr>
<td>元素</td>
<td align="center">可重复</td>
<td align="center">不可重复(用<code>equals()</code>判断)</td>
<td align="center">不可重复</td>
</tr>
<tr>
<td>顺序</td>
<td align="center">有序</td>
<td align="center">无序(实际上由 HashCode 决定)</td>
<td align="center"></td>
</tr>
<tr>
<td>线程安全</td>
<td align="center">Vector 线程安全</td>
<td align="center"></td>
<td align="center">Hashtable 线程安全</td>
</tr>
</tbody></table>
<h2 id="4-HashMap-和-Hashtable-有什么区别？"><a href="#4-HashMap-和-Hashtable-有什么区别？" class="headerlink" title="4. HashMap 和 Hashtable 有什么区别？"></a>4. HashMap 和 Hashtable 有什么区别？</h2><blockquote>
<p><strong>相同点：</strong></p>
<ul>
<li>HashMap 和 Hashtable 都实现了接口 Map, Cloneable, Serializable；</li>
<li>都是将键映射到值的集合对象，其中键与值都是对象，不能包含重复键，但可以包含重复值。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>区别如下：</strong></p>
<ul>
<li>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许；</li>
<li>HashTable 继承自 Dictionary 类，而 HashMap 继承自 AbstractMap 类；</li>
<li>HashTable 的方法使用 synchronized 修饰，是线程安全的， HashMap 线程不安全。</li>
</ul>
</blockquote>
<h2 id="5-如何决定使用-HashMap-还是-TreeMap？"><a href="#5-如何决定使用-HashMap-还是-TreeMap？" class="headerlink" title="5. 如何决定使用 HashMap 还是 TreeMap？"></a>5. 如何决定使用 HashMap 还是 TreeMap？</h2><ul>
<li>TreeMap&lt;K,V&gt; 内存储的 Key 是有序的，其 Key 值是要求实现 java.lang.Comparable，所以迭代的时候 TreeMap 默认是按照 Key 值升序排序的；TreeMap 的实现也是基于红黑树结构。</li>
<li>HashMap&lt;K,V&gt;的 Key 值实现散列 hashCode(),分布是散列的均匀的，不支持排序；数据结构主要是桶(数组),链表或红黑树。</li>
<li>大多情况下 HashMap 有更好的性能，所以大多不需要排序的时候我们会使用 HashMap.</li>
</ul>
<h2 id="6-说一下-HashMap-的实现原理？"><a href="#6-说一下-HashMap-的实现原理？" class="headerlink" title="6. 说一下 HashMap 的实现原理？"></a>6. 说一下 HashMap 的实现原理？</h2><ul>
<li>底层实现是数组+链表，JDK8 以后是数组+链表+红黑树；</li>
<li>当我们往 HashMap 中 put 元素的时候，会将新元素存进去，如果存在相等的 Key 则会替换原先的值；</li>
<li>根据 Key的 hash 值得到这个元素在数组中的位置（即下标），</li>
<li>如果数组该位置上已经存放有其他元素了，</li>
<li>那么在这个位置上的元素将以链表的形式存放，</li>
<li>新加入的放在链头，最先加入的放在链尾；</li>
<li>如果链表长度大于等于7 ，则会将链表转换成红黑树；</li>
<li>如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li>
</ul>
<h2 id="7-说一下-HashSet-的实现原理？"><a href="#7-说一下-HashSet-的实现原理？" class="headerlink" title="7. 说一下 HashSet 的实现原理？"></a>7. 说一下 HashSet 的实现原理？</h2><p>底层使用HashMap实现</p>
<h2 id="8-ArrayList-和-LinkedList-的区别是什么？"><a href="#8-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="8. ArrayList 和 LinkedList 的区别是什么？"></a>8. ArrayList 和 LinkedList 的区别是什么？</h2><ul>
<li>ArrayList 是实现了基于动态数组的结构；</li>
<li>LinkedList 则是基于实现链表的数据结构；</li>
<li>数据的更新和查找，ArrayList 效率高于 LinkedList，ArrayList 可以根据下标快速定位， LinkedList 只能从头依次查询；</li>
<li>数据的增加和删除，LinkedList效率更高一些，ArrayList 需要同时变更其后的数据下标， LinkedList只需变更前后节点的下一步引用。</li>
</ul>
<h2 id="9-如何实现数组和-List-之间的转换？"><a href="#9-如何实现数组和-List-之间的转换？" class="headerlink" title="9. 如何实现数组和 List 之间的转换？"></a>9. 如何实现数组和 List 之间的转换？</h2><ul>
<li>list 转数组， List 的方法 toArray;</li>
<li>数组转 list， Arrays 的方法 asList.</li>
</ul>
<h2 id="10-ArrayList-和-Vector-的区别是什么？"><a href="#10-ArrayList-和-Vector-的区别是什么？" class="headerlink" title="10. ArrayList 和 Vector 的区别是什么？"></a>10. ArrayList 和 Vector 的区别是什么？</h2><ul>
<li>ArrayList 和 Vector 都继承了 AbstractList，都实现了接口List, RandomAccess, Cloneable, Serializable；</li>
<li>Vector 中的方法大多使用 synchronized 关键字修饰，是线程安全的， ArrayList 是线程不安全的。</li>
</ul>
<h2 id="11-Array-和-ArrayList-有何区别？"><a href="#11-Array-和-ArrayList-有何区别？" class="headerlink" title="11. Array 和 ArrayList 有何区别？"></a>11. Array 和 ArrayList 有何区别？</h2><blockquote>
<p>存储内容比较：</p>
<ul>
<li>​ Array 数组可以包含基本类型和对象类型，</li>
<li>​ ArrayList 却只能包含对象类型。</li>
</ul>
</blockquote>
<blockquote>
<p>空间大小比较：</p>
<ul>
<li>它的空间大小是固定的，空间不够时也不能再次申请，所以需要事前确定合适的空间大小。</li>
<li>ArrayList 的空间是动态增长的，如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。</li>
</ul>
</blockquote>
<h2 id="12-在-Queue-中-poll-和-remove-有什么区别？"><a href="#12-在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="12. 在 Queue 中 poll()和 remove()有什么区别？"></a>12. 在 Queue 中 poll()和 remove()有什么区别？</h2><ul>
<li>Queue 队列是一个先入先出（FIFO）的数据结构;</li>
<li><strong>remove</strong> 移除并返回队列头部的元素如果队列为空，则抛出一个 NoSuchElementException 异常;</li>
<li><strong>poll</strong> 移除并返问队列头部的元素如果队列为空，则返回 null.</li>
</ul>
<h2 id="13-哪些集合类是线程安全的？"><a href="#13-哪些集合类是线程安全的？" class="headerlink" title="13. 哪些集合类是线程安全的？"></a>13. 哪些集合类是线程安全的？</h2><p>Hashtable, ConcurrentHashMap, Vector, Stack</p>
<h2 id="14-迭代器-Iterator-是什么？"><a href="#14-迭代器-Iterator-是什么？" class="headerlink" title="14. 迭代器 Iterator 是什么？"></a>14. 迭代器 Iterator 是什么？</h2><ul>
<li>Iterator接口提供遍历任何Collection的接口；</li>
<li>Collection的实现类使用迭代器方法来获取迭代器实例；</li>
<li>迭代器允许调用者在迭代过程中移除元素。</li>
</ul>
<h2 id="15-Iterator-怎么使用？有什么特点？"><a href="#15-Iterator-怎么使用？有什么特点？" class="headerlink" title="15. Iterator 怎么使用？有什么特点？"></a>15. Iterator 怎么使用？有什么特点？</h2><ul>
<li>Java 中使用 Iterator 来遍历集合元素，Iterator 遍历集合元素有以下几个特点:<ul>
<li>Iterator 遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出 ConcurrentModificationEception 的异常。</li>
<li>Iterator 遍历集合元素的过程中可以通过 remove 方法来移除集合中的元素。</li>
<li>Iterator 必须依附某个 Collection 对象而存在，Iterator 本身不具有装载数据对象的功能。</li>
<li>Iterator.remove 方法删除的是上一次 Iterator.next()方法返回的对象。</li>
<li>强调以下 next（）方法，该方法通过游标指向的形式返回 Iterator 下一个元素。</li>
</ul>
</li>
<li><strong>Iterator 的常用方法</strong>:<ul>
<li>boolean hasNext() ;判断迭代器中是否还有下一个元素，有则返回 true</li>
<li>Object next(); 返回迭代器中下一个元素</li>
<li>void remove() ; 删除集合里上一个 next 方法调用的时候返回的对象元素</li>
<li>void forEachRemaining(Consumer action) ;使用 Lambdda 表达式的形式输出 Iterator 中所以的元素。注意该方法其实是间接调用 next()方法进行遍历，所以再次是 next（）方法的时候 Iterator 中的对象已经被遍历完了。</li>
</ul>
</li>
</ul>
<h2 id="16-Iterator-和-ListIterator-有什么区别？"><a href="#16-Iterator-和-ListIterator-有什么区别？" class="headerlink" title="16. Iterator 和 ListIterator 有什么区别？"></a>16. Iterator 和 ListIterator 有什么区别？</h2><p>一．相同点</p>
<ul>
<li>都是迭代器，当需要对集合中元素进行遍历不需要干涉其遍历过程时，这两种迭代器都可以使用。</li>
</ul>
<p>二．不同点</p>
<ol>
<li>使用范围不同，Iterator 可以应用于所有的集合，Set、List 和 Map 和这些集合的子类型。而 ListIterator 只能用于 List 及其子类型。</li>
<li>ListIterator 有 add 方法，可以向 List 中添加对象，而 Iterator 不能。</li>
<li>ListIterator 和 Iterator 都有 hasNext()和 next()方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious()和 previous()方法，可以实现逆向（顺序向前）遍历。Iterator 不可以。</li>
<li>ListIterator 可以定位当前索引的位置，nextIndex()和 previousIndex()可以实现。Iterator 没有此功能。</li>
<li>都可实现删除操作，但是 ListIterator 可以实现对象的修改，set()方法可以实现。Iterator 仅能遍历，不能修改。</li>
</ol>
<h2 id="17-怎么确保一个集合不能被修改？"><a href="#17-怎么确保一个集合不能被修改？" class="headerlink" title="17. 怎么确保一个集合不能被修改？"></a>17. 怎么确保一个集合不能被修改？</h2><ul>
<li>利用 Collections 提供的 unmodifiableCollection 方法</li>
</ul>

        
      
    </div>

    
    
    
      <footer class="post-footer">
          <div class="post-eof"></div>
        
      </footer>
  </article>
  
  
  

    
  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image"
      src="https://avatars2.githubusercontent.com/u/29475073?s=88&v=4"
      alt="Sometwo">
  <p class="site-author-name" itemprop="name">Sometwo</p>
  <div class="site-description" itemprop="description">一些学习笔记与人生的妄想。<br/>Nameless want to be someone, <br/> but end to nobody. <br/> Maybe sometwo this time.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
          
            <a href="/blog/categories/">
          
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
          
            <a href="/blog/tags/">
          
        
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
        </a>
      </div>
    
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
      
      
        
      
      
        
      
        <a href="https://github.com/sometwo7" title="GitHub &rarr; https://github.com/sometwo7" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
    
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sometwo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a></div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js?v=3.1.0"></script>
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/blog/js/utils.js?v=7.4.1"></script><script src="/blog/js/motion.js?v=7.4.1"></script>
<script src="/blog/js/schemes/pisces.js?v=7.4.1"></script>

<script src="/blog/js/next-boot.js?v=7.4.1"></script>



  








  <script src="/blog/js/local-search.js?v=7.4.1"></script>














  

  

  

</body>
</html>
