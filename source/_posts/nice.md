---
title: JAVA 基础
tags:
  - java
categories:
  - java
comments: true
abbrlink: 94c303a9
date: 2019-12-17 09:49:19
---
# JAVA基础

## JAVA中的几种基本数据类型是什么，各自占用多少字节。
8种基本数据类型，
byte，1
char，2
short，2
float，4
int，4
double，8
long，8
boolean，1 或 4，变量 boolean 占4个字节， boolean 数组占1个字节

## String类能被继承吗，为什么。
String 是 final 修饰的类，不能被继承

## String，Stringbuffer，StringBuilder的区别。
String 是字符串，StringBuffer 及 StringBuilder 是可变字符串
StringBuffer 是线程安全的，使用 synchronized 修饰方法
StringBuilder 线程不安全

## ArrayList和LinkedList有什么区别。
ArrayList 底层基于动态数组，随机访问效率较高，对数组内的增删除效率低，动态扩容为原数组的1.5倍，
LinkedList 底层基于链表的动态数组，随机访问效率低，对数组类的增删效率高，动态扩容增加相应链表节点。

## 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。
类实例化的过程是，加载，连接，初始化
原则是先父类再子类，先静态再普通，先变量再方法
顺序是，
父类静态变量
父类静态代码块
子类静态变量
子类静态代码块
父类普通字段
父类构造方法
子类普通字段
子类构造方法

## 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
HashMap，LinkedHashMap，TreeMap，ConcurrentHashMap
HashMap 线程不安全，底层是数组+链表或红黑树的结构，使用 hashcode 对数组长度取模，得到 key 在数组中的位置，扩容 2 倍，默认容量 16
并发下使用 ConcurrentHashMap，


## JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
jdk7 采用分段锁设计 ConcurrentHashMap
ConcurrentHashMap 是线程安全的，使用分段锁来提高并发度，分段是一开始就确定的，后期不能再进行扩容。
其中段 Segment 继承了重入锁 ReentrantLock， 有了锁的功能，数据结构是数组+链表，
Segment 个数不能增加，但是单个 Segment 里的数组可以扩容

## 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
LinkedHashMap，默认按插入顺序排序，底层使用链表
TreeMap，默认 key 升序，基于比较器 Comparator 来实现有序

## 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
类只能继承一个父类，可以实现多个接口；
接口可以继承多个接口；

## 继承和聚合的区别在哪。
类A被类B继承，类B的实例是类A的实例；
类A被类C聚合，类C的实例可以包含类A的实例。

## IO模型有哪些，讲讲你理解的 nio ，他和 bio，aio 的区别是啥，谈谈 reactor 模型。
nio 同步非阻塞 IO，服务器实现模式是一个连接对应一个线程；
bio 同步阻塞 IO，服务器实现模式是一个请求对应一个线程，客户端发送的连接都会注册到多路复用器上，有 IO 请求才会启动线程处理；
aio 异步非阻塞 IO，一个有效请求对应一个线程。

reactor 模型，负责多路分离套接字，Accept 新连接，并分配请求到 Handler 处理。


## 反射的原理，反射创建类实例的三种方式是什么。
获取 class 文件：
.class 对象
实例类的 getClass 方法，
调用 Class.forName 方法，

实例化对象：
class 对象调用 newInstance 方法
class 对象调用 构造方法


## 反射中，Class.forName和ClassLoader区别 。
Class.forName 加载类后会执行类的静态变量，静态代码块；
ClassLoader 只会加载类的 class 对象。


## 描述动态代理的几种实现方式，分别说出相应的优缺点。
动态代理两种实现方式，jdk 动态代理，cglib 动态代理；

### jdk 动态代理
通过反射设置代理对象，用传入的接口创建一个新类，只能有接口引用指向代理；
创建代理对象快，执行效率一般；

### cglib 动态代理
通过字节码技术，创建子类继承代理对象，子类中拦截父类方法加入横切逻辑；
创建代理对象慢，执行效率较快。


## jdk 动态代理与 cglib 实现的区别。


## 为什么CGlib方式可以对接口实现代理。
对接口进行代理的，实现了该接口和 Factory 接口
对实现类进行代理的，继承了该实现类和 Factory 接口


## final的用途。
修饰 类， 变量，方法
类，不能被继承
变量，初次赋值后，不能被修改
方法，不能被重写


## 写出三种单例模式实现 。
私有化构造方法
1. 饿汉，内部单例属性
2. 懒汉，两层同步判断是否创建
3. 静态内部类，重写 readResolve 方法 防止反序列化多个对象

## 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。
父类重写 hashcode 及 equals 方法，


## 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。


## 深拷贝和浅拷贝区别。


## 数组和链表数据结构描述，各自的时间复杂度。


## error和exception的区别，CheckedException，RuntimeException的区别。



## 请列出5个运行时异常。


## 在自己的代码中，如果创建一个 java.lang.String 类，这个类是否可以被类加载器加载？为什么。
不能，双亲委派模型来加载

## 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。


## 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
解决强制转换带来的内存消耗

## 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。


## 有没有可能2个不相等的对象有相同的hashcode。


## Java中的HashSet内部是如何工作的。


## 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。

## java8的新特性。
lamda 表达式及函数式接口

# JVM知识

## 什么情况下会发生栈内存溢出。
### 栈溢出，StackOverflowError,
栈是线程私有的，他的生命周期与线程相同;
每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息
我们可以理解为栈溢出就是方法执行是创建的栈帧超过了栈的深度；
那么最有可能的就是方法递归调用产生这种结果。

### 堆溢出，OutOfMemoryError:java heap space
堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出


## JVM的内存结构，Eden和Survivor比例。
Eden 一块， Survivor 两块，比例是 8,1,1

## JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
主要是针对不同生命周期的对象、数据采用不同的垃圾回收机制
新生代存储新创建的对象，
老年代存储在年轻代中经历了N次垃圾回收后仍然存活的对象
持久代存储静态文件，如java类、方法等，持久代也称为方法区
新生代垃圾回收是 Minor GC，当Eden区满时触发，采用复制算法，同时清空eden和1块survivor区，将存活的对象保存到另一块survivor区
老年代采用Full GC，采用标记-清除垃圾回收


## JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
Minor GC，当Eden区满时触发，采用复制算法，
同时清空eden和1块survivor区，
将存活的对象保存到另一块survivor区，
如果survivor区存储不了则存储到老年代，
如果老年代空间不足，则会触发Full GC, 采用标记-清除算法


## 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。



## 垃圾回收算法的实现原理。

## 当出现了内存溢出，你怎么排错。
对于jvm虚拟机内存中，除了程序计数器意外，其他虚拟机栈、本地方法栈，方法区、堆都存在溢出的可能。

### 1.堆溢出

java堆是用来存储对象的，只要保证不断的生成对象，而且让他们的GC root不断掉，而不会引起垃圾回收，这样堆就会由于对象的不断创建而不断变大而溢出。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。先通过内存映像分析，判断是内存溢出还是泄漏。

如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。

如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

-Xmx用来设置你的应用程序(不是JVM)能够使用的最大内存数，如果你的程序要花很大内存的话，那就需要修改缺省的设置，比如配置tomcat的时候，如果流量啊程序啊都很大的话就需要加大这个值了，BUT不要大得超过你的机器的内存。

另一个-Xms用来设置程序初始化的时候内存栈的大小，增加这个值的话你的程序的启动性能会得到提高。不过同样有前面的限制，以及受到-Xmx的限制。

### 2.虚拟机栈和本地方法栈溢出

通过-xss可以设置栈的大小

当线程所需要的栈深度大于虚拟机所设置的允许的栈大小时候，会出现StackOverflowError异常。

当虚拟机想要扩充栈的数量而缺少内存空间时候，就会出现outofmemoryError异常。

### 3.运行时常量池溢出

方法区与java堆一样，是各个线程共享的内存区域，它用于储存已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区中其实还有一块运行常量池，当class文件中的常量池在类加载之后就被放入运行常量池，运行常量池还可以通过String.intern将常量放入进去，因此其具有动态性，一旦方法区中空间不足时候会抛出OutofMemoryerror异常。

### 4.方法区溢出

通过不停的类加载去产生大量的类，造成方法区中存放太多的类信息等而溢出、

设置-XX:PermSize持久代初始值和-XX:MaxPermSize持久代最大值参数

### 5.元数据溢出

在jdk1.8中方法区溢出变成了元数据溢出

### 6.直接内存溢出

DirectMemory 容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与 Java 堆最大值（-Xmx指定）一样，下面程序利用 DirectByteBuffe 模拟直接内存溢出的情况。

Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。
使用 Netty 的堆外的 ByteBuf 对象，在使用完后，并未归还，导致使用的一点一点在泄露

### 当出现了内存溢出，你怎么排错？
1. 首先，控制台查看错误日志。
2. 然后，使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。
3. 定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。
如果是堆内存溢出，看是否创建了超大的对象。
如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。

## JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。

## 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
类加载器主要有启动类加载器，扩展类加载器，应用程序类加载器，自定义类加载器

### 双亲委派机制
类加载器收到类加载请求，自己不会去加载，会让父类加载器去尝试加载，每一层类加载器都是如此，直到顶层类加载器，
父类加载器加载不了，才会使用子类加载器加载

### 打破双亲委派机制
重新自定义类加载器的 loadClass 方法；
设置 线程上下文类加载器，Thread.setContextClassLoader()

## 讲讲JAVA的反射机制。
> 在运行状态中，对于任意一个类，都能够获取到这个类的所有属性和方法，
对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，
这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。

1. 通过字节码对象创建实例对象
2. 获取指定构造器方法。constructor 如果没有无参构造，只有有参构造如何创建实例呢？看下面
3. 获取成员变量并使用
4. 获得方法并使用
5. 获得该类的所有接口
6. 获取指定资源的输入流
### 动态代理的概述和实现
动态代理：一种设计模式，其非常简单，很容易理解，你自己可以做这件事，但是觉得自己做非常麻烦或者不方便，所以就叫一个另一个人(代理)来帮你做这个事情，而你就不用管了，这就是动态代理。举个例子，买火车票叫人代买。
在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理
在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象　

分三步，但是注意JDK提供的代理正能针对接口做代理，也就是下面的第二步返回的必须要是一个接口。
1. new 出代理对象，通过实现 InvacationHandler 接口，然后new出代理对象来。
2. 通过 Proxy 类中的静态方法 newProxyInstance，来将代理对象假装成那个被代理的对象，也就是如果叫人帮我们代买火车票一样，那个代理就假装成我们自己本人
3. 执行方法，代理成功

注意 newProxyInstance 的三个参数，第一个，类加载器，第二个被代理对象的接口，第三个代理对象。　　

## 你们线上应用的JVM参数有哪些。


## g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。


## 怎么打出线程栈信息。


## 请解释如下jvm参数的含义：
```
-server
-Xms512m // 设置堆最小值
-Xmx512m // 设置堆最大值
-Xss1024k // 设置虚拟机栈大小
-Xoss 128k // 设置本地方法栈大小
-XX:PermSize=256m // 设置永久代容量
-XX:MaxPermSize=512m // 设置永久代最大容量
-XX:MaxTenuringThreshold=20
-XX:CMSInitiatingOccupancyFraction=80
-XX:+UseCMSInitiatingOccupancyOnly。
```

# 开源框架知识

## 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
## tomcat如何调优，涉及哪些参数 。
## 讲讲Spring加载流程。
## Spring AOP的实现原理。
## 讲讲Spring事务的传播属性。
## Spring如何管理事务的。
## Spring怎么配置事务（具体说出一些关键的xml 元素）。
## 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原
## 理，说说aop中的几个术语，它们是怎么相互工作的。
## Springmvc 中 DispatcherServlet 初始化过程。
## netty的线程模型，netty如何基于reactor模型上实现的。
## 为什么选择netty。
## 什么是TCP粘包，拆包。解决方式是什么。

## netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
## netty的心跳处理在弱网下怎么办。
## netty的通讯协议是什么样的。
## springmvc 用到的注解，作用是什么，原理。

## springboot 启动机制。

# 操作系统

## Linux系统下你关注过哪些内核参数，说说你知道的。
## Linux下IO模型有几种，各自的含义是什么。
## epoll和poll有什么区别。
## 平时用到哪些Linux命令。
## 用一行命令查看文件的最后五行。
## 用一行命令输出正在运行的java进程。
## 介绍下你理解的操作系统中线程切换过程。
## 进程和线程的区别。
## top 命令之后有哪些内容，有什么作用。
## 线上CPU爆高，请问你如何找到问题所在。

# 多线程

## 多线程的几种实现方式，什么是线程安全。

## volatile的原理，作用，能代替锁么。

## 画一个线程的生命周期状态图。

## sleep和wait的区别。
## sleep和sleep(0)的区别。
## Lock与Synchronized的区别 。
## synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静
## 态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻
## 量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
## 用过哪些原子类，他们的原理是什么。
## JUC下研究过哪些并发工具，讲讲原理。
## 用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函
## 数的各个参数的含义是什么，比如coreSize，maxsize等。
## 线程池的关闭方式有几种，各自的区别是什么。
## 假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
## spring的controller是单例还是多例，怎么保证并发的安全。
## 用三个线程按顺序循环打印abc三个字母，比如abcabcabc。
## ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
## 如果让你实现一个并发安全的链表，你会怎么做。
## 有哪些无锁数据结构，他们实现的原理是什么。
## 讲讲java同步机制的wait和notify。
## CAS机制是什么，如何解决ABA问题。
## 多线程如果线程挂住了怎么办。
## countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如
## countdownlatch的await方法和是怎么实现的)。
## 对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平所加锁有什么不同。
## 使用synchronized修饰静态方法和非静态方法有什么区别。
## 简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
## 导致线程死锁的原因？怎么解除线程死锁。
## 非常多个线程（可能是不同机器），相互之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案。
## 用过读写锁吗，原理是什么，一般在什么场景下用。

## 开启多个线程，如果保证顺序执行，有哪几种实现方式，或者如何保证多个线程都执行完再拿到结果。

## 延迟队列的实现方式，delayQueue和时间轮算法的异同。


# TCP与HTTP

## http1.0和http1.1有什么区别。
## TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
## TIME_WAIT和CLOSE_WAIT的区别。
## 说说你知道的几种HTTP响应码，比如200, 302, 404。
## 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
## TCP/IP如何保证可靠性，说说TCP头的结构。
## 如何避免浏览器缓存。
## 如何理解HTTP协议的无状态性。
## 简述Http请求get和post的区别以及数据包格式。
## HTTP有哪些method
## 简述HTTP请求的报文格式。
## HTTP的长连接是什么意思。
## HTTPS的加密方式是什么，讲讲整个加密解密流程。
## Http和https的三次握手有什么区别。
## 什么是分块传送。
## Session和cookie的区别。
## 点击这里有一套答案版的试题。

# 架构设计与分布式

## 用java自己实现一个LRU。
## 分布式集群下如何做到唯一序列号。
## 设计一个秒杀系统，30分钟没付款就自动关闭交易。
## 如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么
## 场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
## 如果有人恶意创建非法连接，怎么解决。
## 分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有
## 哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
## 什么是一致性hash。
## 什么是restful，讲讲你理解的restful。
## 如何设计一个良好的API。
## 如何设计建立和保持100w的长连接。
## 解释什么是MESI协议(缓存一致性)。
## 说说你知道的几种HASH算法，简单的也可以。
## 什么是paxos算法， 什么是zab协议。
## 一个在线文档系统，文档可以被编辑，如何防止多人同时对同
## 一份文档进行编辑更新。
## 线上系统突然变得异常缓慢，你如何查找问题。
## 说说你平时用到的设计模式。
## Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册
## 和发现，重试转发，快速失败的策略是怎样的 。
## 一次RPC请求的流程是什么。
## 自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
## 异步模式的用途和意义。
## 编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
## 设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
## MVC模式，即常见的MVC框架。
## 聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
## 应用服务器怎么监控性能，各种方式的区别。
## 如何设计一套高并发支付方案，架构如何设计。
## 如何实现负载均衡，有哪些算法可以实现。
## Zookeeper的用途，选举的原理是什么。
## Zookeeper watch机制原理。
## Mybatis的底层实现原理。
## 请思考一个方案，实现分布式环境下的countDownLatch。
## 后台系统怎么防止请求重复提交。
## 描述一个服务从发布到被消费的详细过程。
## 讲讲你理解的服务治理。
## 如何做到接口的幂等性。
## 如何做限流策略，令牌桶和漏斗算法的使用场景。
## 什么叫数据一致性，你怎么理解数据一致性。
## 分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求
## 的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎
## 么做到最小的资源浪费，流量半开的实现机制是什么。
## dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
## 远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。

# 算法

## 10亿个数字里里面找最小的10个。
## 有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
## 2亿个随机生成的无序整数,找出中间大小的值。
## 给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
## 遍历二叉树。
## 有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
## 写一个字符串（如：www.javastack.cn）反转函数。
## 常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的优化方案。
## 二分查找的时间复杂度，优势。
## 一个已经构建好的TreeSet，怎么完成倒排序。
## 什么是B+树，B-树，列出实际的使用场景。

## 一个单向链表，删除倒数第N个数据。
## 200个有序的数组，每个数组里面100个元素，找出top20的元素。
## 单向链表，查找中间的那个元素。

# 数据库知识

## 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。

## 什么是幻读。

## MYSQL有哪些存储引擎，各自优缺点。

## 高并发下，如何做到安全的修改同一行数据。
## 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
## SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
## 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。
## MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
## 聚集索引和非聚集索引的区别。
## select for update 是什么含义，会锁表还是锁行或是其他。
## 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。
## 数据库的ACID是什么。
## 某个表有近千万数据，CRUD比较慢，如何优化。
## Mysql怎么优化table scan的。
## 如何写sql能够有效的使用到复合索引。
## mysql中in 和exists 区别。
## 数据库自增主键可能的问题。
## MVCC的含义，如何实现的。
## 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他
## 们的原理知道么。
## MYSQL的主从延迟怎么解决。

# 消息队列

## 消息队列的使用场景。
## 消息的重发，补充策略。
## 如何保证消息的有序性。
## 用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务
## 架构怎样的。
## MQ系统的数据如何保证不丢失。
## rabbitmq如何实现集群高可用。
## kafka吞吐量高的原因。
## kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
## 利用mq怎么实现最终一致性。
## 使用kafka有没有遇到什么问题，怎么解决的。
## MQ有可能发生重复消费，如何避免，如何做到幂等。
## MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。

# 缓存
 https://blog.csdn.net/qq_34988624/article/details/86412393

## 常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。
缓存与数据库一致性之缓存更新设计


## 如何防止缓存穿透、缓存击穿和雪崩。
https://blog.csdn.net/kongtiao5/article/details/82771694
缓存穿透，就是缓存没有，数据库没有，重复。导致数据库压力过大。业务类设置 30s 的 null 返回。
缓存击穿，就是缓存没有，数据库有，第一个请求没有结束，第二个请求来了，数据库突然压力加大
雪崩，缓存同时大量过期，数据库压力同时增加

## 缓存数据过期后的更新如何设计。


## redis的list结构相关的操作。


## Redis的数据结构都有哪些。
string
list
hash
set
zset

## Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。


## redis2和redis3的区别，redis3内部通讯机制。

## 当前redis集群有哪些玩法，各自优缺点，场景。

## Memcache的原理，哪些数据适合放在缓存中。

## redis和memcached 的内存管理的区别。

## Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。

## Redis的选举算法和流程是怎样的。

## redis的持久化的机制，aof和rdb的区别。
AOF 日志文件
rdb 内存快照



## redis的集群怎么同步的数据的。

## 知道哪些redis的优化操作。

## Reids的主从复制机制原理。

## Redis的线程模型是什么。

## 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。

## 如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。

## 本地缓存在并发使用时的注意事项。

# 搜索
(面试小结之 Elasticsearch 篇)[https://segmentfault.com/p/1210000009823111/read]

## elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段 。
一主两从，分片三份


## elasticsearch的倒排索引是什么。
是一个索引表，包含一个属性值和具有该属性值的各记录的地址

## elasticsearch 索引数据多了怎么办，如何调优，部署。

### 软件
重新划分索引，根据业务规则或者时间，分成功多个索引；
### 硬件
增加服务器，相应增加一个分片，
根据cpu消耗、内存消耗、硬盘读写情况，相应提高硬件性能，比如增加cpu、内存、采用固态硬盘。


## elasticsearch是如何实现 master 选举的。

1. master 候选服务器启动后，投票选自己，
2. 和其他服务器链接，交换投票，维护一个投票列表记录，其他服务器的投票结果，
3. 对得到的选票的服务器节点ID排序，投票给第一个，
4. 重复过程 2 和 3，直到本机投票结果，和维护的投票列表中一半以上服务器投票结果一致，
5. 最终投票结果为 master

## 详细描述一下Elasticsearch索引文档的过程。
1. 一个文件发送到 ES 的实例，
2. ES 根据文档 ID 路由至相应分片
3. 分片收到请求后，把数据写入 Memory Buffer 及 日志文件里
4. Memory Buffer 里的数据定时刷新 refresh 进入系统缓存的索引数据中
5. 系统缓存的索引数据定时，或当索引数据过大，就会 flush 持久化到磁盘中去，并删除相关日志

## 详细描述一下Elasticsearch更新和删除文档的过程。

1. 删除和更新也都是写操作，但是Elasticsearch中的文档是不可变的，
因此不能被删除或者改动以展示其变更；
2. 磁盘上的每个段都有一个相应的.del文件。
当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。
该文档依然能匹配查询，但是会在结果中被过滤掉。
当段合并时，在.del文件中被标记为删除的文档将不会被写入新段。
3. 在新的文档被创建时，Elasticsearch会为该文档指定一个版本号，
当执行更新时，旧版本的文档在.del文件中被标记为删除，
新版本的文档被索引到一个新段。
旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。

## 详细描述一下Elasticsearch搜索的过程。
1. 搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；
2. 在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。
 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。
 PS：在搜索的时候是会查询Filesystem Cache的，
 但是有部分数据还在Memory Buffer，所以搜索是近实时的。
2. 每个分片返回各自优先队列中，所有文档的 ID 和排序值 给协调节点，
它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。
3. 接下来就是 取回阶段，协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。
每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。
一旦所有的文档都被取回了，协调节点返回结果给客户端。
4. 补充：Query Then Fetch的搜索类型在文档相关性打分的时候参考的是本分片的数据，
这样在文档数量较少的时候可能不够准确，DFS Query Then Fetch增加了一个预查询的处理，
询问Term和Document frequency，这个评分更准确，但是性能会变差。


## Elasticsearch在部署时，对Linux的设置有哪些优化方法？
1. 64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反。
2. 如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。
2. 如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。
2. 即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。
2. 请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。
2. 通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。
2. Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。
2. 不要随意修改垃圾回收器（CMS）和各个线程池的大小。
2. 把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过ES_HEAP_SIZE 环境变量设置。
2. 内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。
2. Lucene 使用了大量的文件。同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。
### 补充：索引阶段性能提升方法

1. 使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点。
2. 存储：使用 SSD
3. 段和合并：Elasticsearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD，可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段。
4. 如果你的搜索结果不需要近实时的准确度，考虑把每个索引的index.refresh_interval 改到30s。
5. 如果你在做大批量导入，考虑通过设置index.number_of_replicas: 0 关闭副本。



## lucence内部结构是什么。

